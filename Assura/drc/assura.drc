; **************************************************************************************
; * 0.18um/0.16um Assura DRC COMMAND FILE - ULM18_LM16_6M.28a     09/09/2009           *
; * FOR TSMC 0.18UM CMOS LOGIC/MS/RF AND 0.16UM CMOS LOGIC/MS 1P6M PROCESS DESIGN RULE *
; *          (CL018G/LV/LP, CM018, CR018 CL016G, CM016)                                *
; * (DESIGN RULE DOCUMENT: T-018-LO-DR-001 Rev2.8)                                     *
; * (DRC COMMAND FILE DOCUMENT: T-018-LO-DR-001-U1 Rev 2.8a)          	               *
; **************************************************************************************
;
;  DISCLAIMER
;
;  The information contained herein is provided by TSMC on an "AS IS" basis
;  without any warranty, and TSMC has no obligation to support or otherwise
;  maintain the information.  TSMC disclaims any representation that the
;  information does not infringe any intellectual property rights or proprietary
;  rights of any third parties.  There are no other warranties given by TSMC,
;  whether express, implied or statutory, including, without limitation, implied
;  warranties of merchantability and fitness for a particular purpose.
;
;  STATEMENT OF USE
;
;  This information contains confidential and proprietary information of TSMC.
;  No part of this information may be reproduced, transmitted, transcribed,
;  stored in a retrieval system, or translated into any human or computer
;  language, in any form or by any means, electronic, mechanical, magnetic,
;  optical, chemical, manual, or otherwise, without the prior written permission
;  of TSMC.  This information was prepared for informational purpose and is for
;  use by TSMC's customers only.  TSMC reserves the right to make changes in the
;  information at any time and without notice.
;
;-------------------------------------------------------------------------------------------
;
;  NOTICE: (Read Me First!)
;
;  1. The error output are divided into two groups: errors
;     and recommendations which are reported to the output
;     layer 63 and 64 respectively.
;   - Errors are corresponding to the rule violations. Any
;     violation will stop the mask making.
;   - Recommendations are suggesions for design guideline.
;     It is only for reference.
;
;  2. If the input GDS file does not include all the layers in the
;     INPUT LAYER BLOCK, for example, they are generated by logic
;     operations, please make sure the consistence with original
;     layer definition.
;
;  3. The runset is tested and developed on Assura AV41, please use 
;     this or newer TSMC qualified version of Assura to execute this runset.
;
;----------------------------------------------------------------------------------------
;
; REVISION:
; 
; 2.7a 04/21/2008 - Third Party (Cadence)
;      Official release.
; 2.7b 01/20/2009 - M. Feng
;      1) Remove DRC UNSELECT CHECK.  
;      2) Modify PO.W.1_HR to enable check more exactly.  
;      3) Change ADP.C.3 to ADP.C.1 and ADP.C.2 to align design rule. 
;      4) Modify some rule name to align design rule.
;                Change VTMP.X.X to VTM_P.X.X,
;                Change VTMN.X.X to VTM_N.X.X,
;                Change NT_N.W.3 to NTN.W.3 in C016 process.
;      5) Modify CURRENT STATUS part.
;	     6) Change the rule name from NT_N.W.2 to NT_N.W.2_LV
;	     7) Change the rule writing of the ESD.24g, ESD.28g
;	     8) Change the rule check of LUP.5.4 according to design rule owner's comment.
;	     9) Change the rule check of MIMVIA.S.1 and MIMVIA.S.2 according to design rule owner's comment.
; 2.8a 09/09/2009 - M.Feng
;	1) Change the rule writing of rule NT_N.I.4, NP.R.3, PP.R.3,PP.O.1,PP.E.1,RPO.C.3,CO.W.1,CO.E.3,VIAx.W.1,
;	   VIAn.W.1,DNW.E.1,CTM.W.4,ESD.20g,ESD.21g,LOGO.R.1 according to the DRM
;	2) Add the new rules NWR.R.3,NWR.R.4,NWR.R.5,NWR.R.6,RES.9,RES.10,RES.11,DNW.S.2,IMD crack rules,ESD.35g
;	   SBD rules according to the DRM.
;	3) Delete the rules VTM_N.R.1,VTM_P.R.1,DNW.C.2,DNW.C.3,WARN.HRI according to the DRM
;	4) Change the layer definition of the EXCL for LOGO.R.2.
;	5) Change the recognition method for I/O device according to the advance process.
;	6) Change the rule name from ESD.8 to ESD.8g,ADP.S.2 to ADP.S.2g, ADP.W.3 to ADP.W.3g, ADP.W.4 to ADP.W.4g
;	   LUP rules according to the DRM.
;	7) Put the VIAD rules and the M6/MD density rules into the normal top metal option. 
;	8) Add the warning for the ESD implant (ESD.WARN.3) according to the DRM owner's comment.
;	9) Change the UTM20K.C.1, UTM40K.C.1 to recomendation rules according to the design rule change.
;	10) Change the rule wrinting of meatl/via enclosure rules.
;	11) Add the RES.HRI recommendation rules in the C016 MM according to the design rule
;
;-------------------------------------------------------------------------------------------
;
; DUMMY LAYER REQUIRED:
;
;  1) HOTWL   - Hot N-Well
;               N-Well not connected to the most positive voltage Vdd is defined as Hot N-Well. 
;               It must follow different width and space rules from the N-Well connected to 
;               Vdd (Cold N-Well). Use "HOTWL" layer to exactly cover the Hot N-Well area for 
;               correct N-Well DRC.
;
;  2) EXCL    - UN-DRC area
;               If there's any area with different rules and not to be checked in this run, 
;               use the "EXCL" layer to exactly cover the area to be excluded.
;
;  3) SDI     - I/O ESD Protection Circuit
;               For I/O guidance rule checking, use "SDI" layer to designate the ESD area to 
;               checked. The whole ESD devices should be covered by "SDI".
;
;  4) DPDMY   - Dummy Pad area
;               For chip corner dummy pad, use "DPDUMMY" layer to cover dummy pad area.
;
;  5) PLDMY   - Power Line
;               For chip corner power line, use "PLDUMMY" layer to cover whole power line area.
;
;  6) RWDMY   - NWell Resistor
;               The N-Well region covered by both RWDMY and RPO is the NW within OD resistor.
;               The N-Well region covered by only RWDMY is the NW under STI resistor.
;
;  7) DRCDMY  - TSMC reserved layer.
; 
;  8) ESD1DMY - IO ESD region dummy layer, RPO must enclose whole gate.
;     ESD2DMY - RPO enclose gate 0.05 for 3.3V.
;
;  9) DMN2V   - Dummy layer to ensure N2V in N+ poly/od resistor.
;     DMP2V   - Dummy layer to ensure P2V in P+ poly/od resistor.
;
; 10) RLPPDMY - LPP high resistance poly resistor
;               Use "RLPPDMY" to exactly cover LPP high resistance poly resistor area.
;
; 11) WBDMY   - Dummy layer to cover the CUP pad.
;
; 12) CTMDMY  - Capacitor bottom plate
;               Use "CTMDMY" to cover capacitor bottom plate in mixed-signal process.
; 13) INDDMY  - Dummy layer for inductor recognition in mixed-signal process.
;
; 14) LUPWDMY - DRC dummy layer to waive Latch-Up rules for verified IP. 
;
; 15) SBDDMY   - dummy layer to fully cover schottky barrier diode.
;
; 16) VSSDMY   - dummy layer to cover VSS PAD
;
; 17) VDDDMY   - dummy layer to cover VDD PAD
;-------------------------------------------------------------------------------------------
;
;                      CURRENT STATUS
;
;  RULES NOT IMPLEMENTED:
;
;  The following rules are not coded in this rule file:
;
;  rule                      description/explanation/alternate file
;  ------------------------  ----------------------------------------------------
;  Part I recommendations    Not coded (page 3 of spec.)
;
;  Antenna rules             Please refer to Antenna DRC deck.
;
;  Passivation rules         Please refer to Bond PAD DRC deck.
;
;  Metal Fuse rules          Please refer to Metal Fuse DRC deck.
;
;  Seal Ring rules           Not coded.
;
;  SRAM rules                Not coded.
;
;  Chip Corner Power Line    Only ADP.1/ADP.S.1/ADP.C.1/ADP.C.2/ADP.E.1
;  and Dummy PAD             /ADP.W.1/ADP.W.2/ADP.E.2 
;                            rules are coded.
;
;  Un-Checkable rules        DNW.R.3(R), RES.8(R),RES.HRI.6(R),MIMVIA.S.1/S.2(R), MIMVIA.R.1/R.2(R),CTM.R.4,DNW.R.6
;
;  * Guidelines implemented :
;
;    1) Partial I/O ESD GuideLines are implemented: 6,8,18~34,35,36,37.
;       Others are not implemented because of guideline.
;
;    2) Partial LatchUp GuideLines are implemented: 1,2,3,4,5,6
;       Others are not implemented because of guideline.
;
;    3) Dummy PAD Guidlines implemented: ADP.S.2 ADP.W.3 ADP.W.4
;
;    4) Seal Ring rules are not implemented: SR.S.1 SR.E.1 
; 
;    5) Metal stress relief guideline rules are not implemented.
;

;-------------------------------------------------------------------------------------------
;	
;  * To correctly use this DRC deck, the following settings are very important in
;    this DRC command file:
;	
;  (0) Assura AV41 is used to develop and QA this command file. 
;	Please execute the DRC with this or newer TSMC qualified version of Assura.
;
;==================================================================================================================
;
;
;  Pay attention to!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
;
;     
;     Pls set variable ( C016 = 1 ) if you use 0.16um process, Otherwise, It will cause a big risk.
;
;
;
;
;******************************************************************************************************************
;  This drc deck can be used to do check for C018 and C016 process as below:
;     
;       a. For 0.18um process
; 
;             1) C018 logic 1.8V/3.3V process (general purpose)     
;             2) C018 logic 1.8V/3.3V process (low power)           
;             3) C018 logic 1.8V/5V process   (general purpose)     
;             4) C018 logic 1.8V/5V process   (low power)           
;             5) C018 logic 1.5V/3.3V process (low voltage)         
;             6) C018 logic 1.5V/2.5V process (low voltage)         
;             7) C018 Mixed-Singal/RF 1.8V/3.V process              
;	       8) C018 RF SBD 1.8V/3.V process
;
;       b. For 0.16um process
; 
;             1) C016 logic/Mixed-Singal 1.8V/3.3V process          
;
;     Note: The default of this DRC command file is for 0.18um logic 1.8V/3.3V(general purpose) design rule
;           you can turn on/off relted switch correctly if other process are used,.
;                  
;                    turn on  in Assura drc means set the variable to be "1" .
;                    turn off in Assura drc means set the variable to be "0" .
;
;********************************************************************************************************************
;  
;  There are some MUST switchs and OPTIONAL switchs in this drc deck. You must keep MUST switch turn on or trun off correctly.
;  Otherwise, you could not check drc correctly. As to OPTIONAL switch, you can turn on/off according to you requirement.
;  The default of this DRC command file is for 0.18um logic 1.8V/3.3V(general purpose) design rule
;  
;
;   MUST ssetting: 
;              
;      HIGH_VOLTAGE = 3.3 	 // Set ( HIGH_VOLTAGE = 3.3 ) only when HIGH_VOLTAGE = 3.3V
;     ;HIGH_VOLTAGE = 5  	 // set ( HIGH_VOLTAGE = 5   ) only when HIGH_VOLTAGE = 5V
;     ;HIGH_VOLTAGE = 2.5        // set ( HIGH_VOLTAGE = 2.5 ) only when HIGH_VOLTAGE = 2.5V
;     
;      CORE_VOLTAGE = 1.8        // set ( CORE_VOLTAGE = 1.8 ) only when CORE_VOLTAGE = 1.8V
;     ;CORE_VOLTAGE = 1.5    	 // set ( CORE_VOLTAGE = 1.5 ) only when CORE_VOLTAGE = 1.5V
;
;                LP = 0          // turn on ( LP = 1 ) only when you use Low Power process,otherwise please turn off( LP = 0 ) it 
;              C016 = 0          // turn on ( C016 = 1 ) only when you use 0.16um process,otherwise please turn off ( C016 = 0 ) it
;          MIX_MODE = 0          // turn on ( MIX_MODE = 1 ) only when you use Mixed-Singal/RF process,otherwise please turn off ( MIX_MODE = 0 ) it
;                        
;         THICK_40K = 0          // turn on ( THICK_40K = 1 ) only when 40KA Thick Top Metal is used.otherwise please turn off ( THICK_40K = 0 ) it
;         THICK_20K = 0          // turn on ( THICK_20K = 1 ) only when 20KA Thick Top Metal is used.otherwise please turn off ( THICK_20K = 0 ) it           
;                          
; OPTIONAL switch:
;
;   CHECK_SRAM_EXCL = 0          // turn on  when M2 and upward layers in SRAM region covered by EXCL are checked.
;       CHECK_ALRDL = 1          // turn off when MD&VIAD rules are not checked.
;  CHECK_DUMMY_ODPO = 1          // turn off when Dummy OD&PO are not checked.
;         Recommend = 0          // turn on  when Recommended rules are checked.
;     GUIDELINE_LUP = 1          // turn off when you don't want check latchup guideline rules.   
;     GUIDELINE_ESD = 1          // turn off when you don't want check ESD guideline rules.
;
; For example:
;  
;    1) If your design use 0.18um Mixed-Singal/RF 1.8V/3.3V process.
; 
; Please turn on MUST setting (
;              HIGH_VOLTAGE = 3.3 ; 
;              CORE_VOLTAGE = 1.8 ; 
;              MIX_MODE     = 1   ; 
;              THICK_40K    = 1 or THICK_20K = 1
;                              ) 
;    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement.
;    
;    2) If your design use 0.18um logic 1.8V/5V Low Power process.
; 
; Please turn on MUST setting (
;              HIGH_VOLTAGE = 5   ;
;              CORE_VOLTAGE = 1.8 ;
;                        LP = 1   ;
;                             ) 
;    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement.
;
;    3) If your design use 0.18um logic 1.5V/3.3V low voltage process.
; 
; Please turn on MUST setting (
;              CORE_VOLTAGE = 1.5 ; 
;              HIGH_VOLTAGE = 3.3 ; 
;                              ). 
;    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement
;
;    
;    4) If your design use 0.16um logic 1.8V/3.3V process.
; 
; Please turn on MUST switchs (
;              HIGH_VOLTAGE = 3.3 ; 
;              ORE_VOLTAGE  = 1.8 ; 
;                      C016 = 1   ;
;                              ) 
;    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement.
;
;    5) If your design use 0.16um Mixed-Singal 1.8V/3.3V process.
; 
; Please turn on MUST switchs (
;                   HIGH_VOLTAGE = 3.3 ;
;                   ORE_VOLTAGE  = 1.8 ;
;                           C016 = 1   ;
;                   MIX_MODE     = 1   ;
;                              ) 
;    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement.
;    
;    
;********************************************************************************************************************
;
;  (1) Process selection:
;      
;      The default of this DRC command file is for 0.18um logic 1.8V/3.3V(general purpose) design rule(T-018-LO-DR-001)
;      If other process are used, Pls turn on you use process switch and turn off other process switch.
;
;                 LP = 0      // set ( LP   = 1 ) only when you use Low Power process,otherwise please turn off it  
;               C016 = 0      // set ( C016 = 1 ) only when you use 0.16um process,otherwise please turn off it
;  (2) Variable for High Voltage:
;
;	The default of this DRC command file assumes 3.3V is used as high (I/O) voltage.
;	If other high voltages are used, please DEFINE other variables. For example,
;	if 2.5V is used as high voltage, then the settings should be:
;
;	  HIGH_VOLTAGE = 3.3 	     // when HIGH_VOLTAGE = 3.3V
;	 ;HIGH_VOLTAGE = 2.5 	     // when HIGH_VOLTAGE = 2.5V
;	 ;HIGH_VOLTAGE = 5 	     // when HIGH_VOLTAGE = 5V
;	
;	* If 5V is enabled, NT_N rule sections will be disabled.
;
;  (3) Variable for Core Voltage:
;
;	The default of this DRC command file assumes 1.8V is used as core voltage.
;	If other core voltages are used, please DEFINE other variables. For example,
;	if 1.5V is used as core voltage, then the settings should be:
;
;	  CORE_VOLTAGE = 1.8 	     // when CORE_VOLTAGE = 1.8V
;	 ;CORE_VOLTAGE = 1.5 	     // when CORE_VOLTAGE = 1.5V
;
;  (4) Variable for High Voltage & Core Voltage:
;
;	Please choose proper voltages for the core and I/O devices in the logic section.
;	The setting should be:
;
;	  HIGH_VOLTAGE = 3.3 	   // when HIGH_VOLTAGE = 3.3V
;        ;HIGH_VOLTAGE = 2.5       // when HIGH_VOLTAGE = 2.5V
;        ;HIGH_VOLTAGE = 5 	   // when HIGH_VOLTAGE = 5V
;	  CORE_VOLTAGE = 1.8       // when CORE_VOLTAGE = 1.8V
;	 ;CORE_VOLTAGE = 1.5 	   // when CORE_VOLTAGE = 1.5V
;
;	To execute the runset with I/O voltage equals 3.3V and core voltage as 1.8V.
;
;  (5) Variable for check SRAM inside layer EXCL:
;
;	By default, we exclude DRC check inside SRAM region covered by exclude layer "EXCL(55)".
;	However, customers could enable this option to check M2 and upward layers inside EXCL
;	in order to check logic rules inside SRAM.
;	Please notice that turn on this option will also disable the waiving function of EXCL, 
;	and the region covered by EXCL will be examined with M2 and upward layers' rules.
;	Please remove set the "CHECK_SRAM_EXCL = 0" to be "CHECK_SRAM_EXCL = 1" to enable this function:
;
;		     CHECK_SRAM_EXCL = 1
;
;  (6) Variable for MD&VIAD rule checking:
;
;	By default,( CHECK_ALRDL = 1 ) MD&VIAD rules are checked in this deck. If MD&VIAD rules are not required
;	to check, please set ( CHECK_ALRDL = 0 ) to disable this option:
;
;		    CHECK_ALRDL = 0
;
;  (7) Variable for dummy OD&PO rule checking:
;
;	By default, dummy OD&PO are checked by rules in this deck. But some unnecessary rule 
;	checks may induce false alarm. If dummy OD&PO are not required to check, please
;	set variable to " 0 " to disable this option:
;
;		CHECK_DUMMY_ODPO = 0;
;
;	Note: If this option is disabled, please make sure the LVS result is correct after 
;	      dummy insertion to prevent from dummy pattern induced layout circuit short.
;
;  (8) Variable for Mixed-Signal/RF circuit design:
;
;	By default, this DRC deck is used for Mixed-Signal/RF process. When this DRC deck is
;	used for general Logic process, please set variable to " 0 " to disable this option:
;
;		MIX_MODE = 0
;
;  (9) Variable for Thick Top Metal check:
;
;	By default, the Top Metal is Normal Top Metal. If customer uses 20KA or 40KA Thick Top 
;	Metal, please set variable to " 1 " to enable the option 'THICK_40K' or 'THICK_20K',
;  But only one should be turn on every time.
;
;		THICK_40K = 1 
;		THICK_20K = 0 
;
;  (10) Variable for recommended rule check:
;
;	By default, recommended rules are not checked, but it is suggested to set variable to " 1 " 
;  to enable this option from the point of view of noise isolation and SPICE model accuracy.
;	The recommended rule check includes DNW.E.1 and RES rules.
;
;		Recommend = 1
;
;  (11) Latch-up guideline check:
;
;	By default, This command file will check Latch-up guideline rules,
;	please set variable to " 0 " if you don't want check these rules:
;
;		GUIDELINE_LUP = 0
;
;  (12) ESD guideline check:
;
;	By default, This command file will check ESD guideline rules,
;	please set variable to " 0 " if you don't want check these rules:
;
;		GUIDELINE_ESD = 0
;
;  (13) CHECK_LATCHUP_BY_TEXT: (default is off) 
;       DRC uses CB/CBD/CB2/UBM layer to recognize PAD, and uses the connection
;       of well strap to distinguish IO PAD and VDD/VSS PAD. So latch-up rules can not be
;       checked in cell level if no CB/CBD/CB2/UBM layer exists. Also,if VDD/VSS pad is not
;       connected to strap, it will be falsely recognized as IO pad. 
;       You can turn on this option to solve these inconveniences. Assign the PAD/VDD/VSS pin name in
;       Variables (PAD_TEXT/VDD_TEXT/VSS_TEXT). Notice that only text by metal pin layer in top cell
;       is used for latch-up check.
; 
;         CHECK_LATCHUP_BY_TEXT = 1
; 
;  (14) CHECK_LATCHUP_BY_PAD_CONNECTION: (default is on)
;      DRC use following two methods to recognize the ACTIVE which needs to check latch-up rules. 
;      1. Active are covered by SDI dummy layer
;      2. Active connects to the IO pad directly.
;      If you don't want to use pad connection (method 2) to check latch-up rules, please turn off this option.
;      Then only ACTIVE covered by SDI layer will be checked. 
;          
;         CHECK_LATCHUP_BY_PAD_CONNECTION = 0
;
;------------------------------------------------------------------------------------------- 

 CHECK_SRAM_EXCL  = 0     ;  enable  when M2 and upward layers in SRAM region covered by EXCL are checked. 
 CHECK_ALRDL      = 1     ;  disable when MD&VIAD rules are not checked.                 
 CHECK_DUMMY_ODPO = 1     ;  disable when Dummy OD&PO are not checked.                   
 GUIDELINE_LUP    = 1     ;  turn off when you don't want check latchup guideline rules. 
 GUIDELINE_ESD    = 1     ;  turn off when you don't want check ESD guideline rules.     
 Recommend        = 0     ;  enable  when Recommended rules are checked.                 

 MIX_MODE         = 1     ;  turn on only when you use Mixed-Singal/RF process,otherwise please turn off it.
 THICK_40K        = 0     ;  turn on only when 40KA Thick Top Metal is used.otherwise please turn off it.
 THICK_20K        = 1     ;  turn on only when 20KA Thick Top Metal is used.otherwise please turn off it.    
 LP               = 0     ;  turn on only when you use Low Power process,otherwise please turn off it        
 C016             = 0     ;  turn on only when you use 0.16um process,otherwise please turn off it           

 CHECK_LATCHUP_BY_TEXT = 0            ; Turn on to recognize IO PAD by following text   
 CHECK_LATCHUP_BY_PAD_CONNECTION = 1; ; Turn on to recognize recognize the MOS connected to I/O by connection 

 HIGH_VOLTAGE     = 3.3
;HIGH_VOLTAGE     = 5 
;HIGH_VOLTAGE     = 2.5 
 CORE_VOLTAGE     = 1.8
;CORE_VOLTAGE     = 1.5 


PAD_TEXT = '( "*" )
VDD_TEXT = '( "AVDDBG" "AVDDR" "AVDWELL" "VDWELL" "VD33APST" "VDD5V" "TAVD33" "VD33PST" "AVDD" "TAVDD" "TAVD33PST" "TAVDDPST" "AVD33B" "VDD" "AVD33G" "DVDD" "AVDDG" "AVDDB" "VDDG" "VDDPST" "VD33REF" "VD33" "AVD33R" "VDDSA" )
VSS_TEXT = '( "VSSPST" "AVS33R" "AVSSUB" "VSSREF" "VSSAPST" "VS33APST" "DVSS" "AVS33G" "AVSSBG" "TAVSS" "AVS33B" "AVSSB" "GND" "VSSG" "VSSUB" "VSS" "AVSS" "TAVSSPST" "AGND" "AVSSR" "AVSSG" )



;------------------------------------------------------------------------------------------- 
; ENVIRONMENT SETUP
;------------------------------------------------------------------------------------------- 
;------------------------ 
; DRAWN LAYER DEFINITIONS 
;------------------------ 
drcExtractRules(

layerDefs( "df2"
chip = cellBoundary(root)
	nweli	 = layer(  "NWELL" ) 
	/*  Nwell technology */
	diffi	 = layer(  "DIFF"  type("drawing") ) 
	/*  Active areas */
	dod	 = layer( "DIFF" type("dummy") ) 
	/*  Dummy OD (DIFF) */
	odblk	 = layer( "ODBLK" type("dummy") ) 
	/*  DOD blocking for insertion */
	pdiffi	 = layer(  "PDIFF" ) 
	/*  Active areas */
	ndiffi	 = layer(  "NDIFF" ) 
	/*  Active areas */
	od2i	 = layer(  "OD2" ) 
	/*  Define thick gate oxides */
	polyi	 = layer(  "POLY1"  type("drawing") ) 
	/*  Polysilicon gates, interconnect */
	dpo	 = layer( "POLY1" type("dummy") ) 
	/*  Dummy Poly */
	poblk	 = layer( "POBLK" type("dummy") ) 
	/*  DPO blocking for insertion */
	ppi	 = layer(  "PIMP" ) 
	/*  P+ S/D imlant */
	npi	 = layer(  "NIMP" ) 
	/*  N+ S/D imlant */
	bjtdummy	 = layer(  "BJTDUMMY" ) 
	/*  BJT dummy layer */
	diodummy	 = layer(  "DIODUMMY" ) 
	/*  Diode dummy layer */
	coi	 = layer(  "CONT" ) 
	/*  Define connection from M1 to S/D and Gate */
	m1i	 = layer(  "METAL1"  type("drawing") ) 
	/*  First Metal layer */
	via1i	 = layer(  "VIA12" ) 
	/*  Define connection from M2 to M1 */
	m2i	 = layer(  "METAL2"  type("drawing") ) 
	/*  Second Metal layer */
	via2i	 = layer(  "VIA23" ) 
	/*  Define connection from M3 to M2 */
	m3i	 = layer(  "METAL3"  type("drawing") ) 
	/*  Third Metal layer */
	via3i	 = layer(  "VIA34" ) 
	/*  Define connection from M4 to M3 */
	m4i	 = layer(  "METAL4"  type("drawing") ) 
	/*  Fourth Metal layer */
	via4i	 = layer(  "VIA45" ) 
	/*  Define connection from M5 to M4 */
	m5i	 = layer(  "METAL5"  type("drawing") ) 
	/*  Fifth Metal layer */
	via5i	 = layer(  "VIA56" ) 
	/*  Define connection from M6 to M5 */
	m6i	 = layer(  "METAL6"  type("drawing") ) 
	/*  Sixth Metal layer   */
	viadi	 = layer(  "VIAD" ) 
	/*  Define connect from MD to Top Metal */
	mdi	 = layer(  "MD"  type("drawing") ) 
	/*  RDL Metal layer above Top Metal */
	cbi	 = layer(  "PAD" ) 
	/*  Passivation opening for Bond Pad */
	cbdi	 = layer(  "CBD" ) 
	/*  Definition of passivation window for bump */
	ubmi	 = layer(  "UBM" ) 
	/*  Bond Pad definition for RDL */
	ppii	 = layer(  "PPI"  type("drawing") ) 
	/*  Post Passivation RDL */
	rpoi	 = layer(  "RPO" ) 
	/*  Salicided Block Layer */
	ntni	 = layer(  "NTN" ) 
	/*  Native NMOS blocked implantation */
	plmidei	 = layer(  "PLMIDE" ) 
	/*  Polymide (if drawn) */
	dnwi	 = layer(  "DNW" ) 
	/*  Deep N-WELL */
	vtmpi	 = layer(  "VTM_P" ) 
	/*  Blocking region of PMOS VT implantation */
	vtmni	 = layer(  "VTM_N" ) 
	/*  Blocking region of NMOS VT implantation */
	pv_p	 = layer(  "PV_P" ) 
	/*  PV_P pmos varactor p+ implant layer */
	pv_n	 = layer(  "PV_N" ) 
	/*  PV_N pmos varactor n+ blocking layer */
	hrii	 = layer(  "HRI" ) 
	/*  High Resistor implant */
;========================
;== Dummy Metal layers ==
;========================
	m1dmy	 = layer( "METAL1" type("dummy") ) 
	/*  Metal1 dummy (if drawn) */
	m2dmy	 = layer( "METAL2" type("dummy") ) 
	/*  Metal2 dummy (if drawn) */
	m3dmy	 = layer( "METAL3" type("dummy") ) 
	/*  Metal3 dummy (if drawn) */
	m4dmy	 = layer( "METAL4" type("dummy") ) 
	/*  Metal4 dummy (if drawn) */
	m5dmy	 = layer( "METAL5" type("dummy") ) 
	/*  Metal5 dummy (if drawn) */
	m6dmy	 = layer( "METAL6" type("dummy") ) 
	/*  Metal6 dummy (if drawn) */
	mddmy	 = layer( "MD" type("dummy") ) 
	/*  MD dummy (if drawn) */
;=======================
;== Metal Slot layers ==
;=======================
	m1sloti	 = layer( "METAL1" type("slot") ) 
	/*  Metal1 slot (if drawn) */
	m2sloti	 = layer( "METAL2" type("slot") ) 
	/*  Metal2 slot (if drawn) */
	m3sloti	 = layer( "METAL3" type("slot") ) 
	/*  Metal3 slot (if drawn) */
	m4sloti	 = layer( "METAL4" type("slot") ) 
	/*  Metal4 slot (if drawn) */
	m5sloti	 = layer( "METAL5" type("slot") ) 
	/*  Metal5 slot (if drawn) */
	m6sloti	 = layer( "METAL6" type("slot") ) 
	/*  Metal6 slot (if drawn) */
	mdsloti	 = layer( "MD" type("slot") ) 
	/*  MD slot (if drawn) */
;=================================
;==  Capacitor Top Metal Layers ==
;=================================
	ctm2i	 = layer( "CTM2" type("drawing") ) 
	/*  Capacitor Top Metal-2 */
	ctm3i	 = layer( "CTM3" type("drawing") ) 
	/*  Capacitor Top Metal-3 */
	ctm4i	 = layer( "CTM4" type("drawing") ) 
	/*  Capacitor Top Metal-4 */
	ctm5i	 = layer( "CTM5" type("drawing") ) 
	/*  Capacitor Top Metal-5 */
;===================
;==  Dummy Layers ==
;===================
	hotwl	 = layer(  "HOTWL" ) 
	/*  Hot N-Well (SEE README HOT_NWEL NOTES) */
	excli	 = layer(  "EXCL" ) 
	/*  Exclude layer */
	drcdmy	 = layer(  "DRCDUMMY" ) 
	/*  DRC I/O waiver */
	rwdmy	 = layer(  "RWDUMMY" ) 
	/*  NWEL Resistor dummy layer */
	dpdmy	 = layer(  "DPDUMMY" ) 
	/*  Dummy Pad area dummy layer */
	pldmy	 = layer(  "PLDUMMY" ) 
	/*  Power Line area dummy layer */
	sdi	 = layer(  "SDI" ) 
	/*  IO ESD region dummy layer */
	esd1dmy	 = layer(  "ESD1DUMMY" ) 
	/*  IO ESD region dummy layer, RPO must enclose whole gate */
	esd2dmy	 = layer(  "ESD2DUMMY" ) 
	/*  IO ESD region dummy layer, RPO enclose gate 0.05 foravGetVariable( "AVDDBG" "AVDDR" "AVDWELL" "VDWELL" "VD33APST" "VDD5V" "TAVD33" "VD33PST" "AVDD" "TAVDD" "TAVD33PST" "TAVDDPST" "AVD33B" "VDD" "AVD33G" "DVDD" " 3.3V */
	esd3dmy	 = layer(  "ESD3DUMMY" ) 
	
	ctmdmy	 = layer(  "CTMDUMMY" ) 
	/*  Cover metal as a capacitor bottom plate */
	rlppdmy	 = layer(  "RLPPDUMMY" ) 
	/*  HRI high Poly resistor dummy layer */
	dmn2v	 = layer(  "DMN2V" ) 
	/*  Dummy layer to ensure N2V in N+ poly/OD resistor */
	dmp2v	 = layer(  "DMP2V" ) 
	/*  Dummy layer to ensure P2V in P+ poly/OD resistor */
	vardmy	 = layer(  "VARDUMMY" ) 
	/*  Dummy layer to cover varactor device */
	pmdmy	 = layer(  "PMDMY" ) 
	/*  Dummy layer to cover fuse window and protection ring structur */
	fwi	 = layer(  "FW" ) 
	/*  Fuse window when x, (x+1) = 3  */
	lmark	 = layer( "LMARK" type("drawing") ) 
	/*  L target window for bump process */
	lwi	 = layer( "LW" type("drawing") ) 
	/*  L target window for bump process */
	wbdmy	 = layer(  "WBDMY" ) 
	/*  Dummy layer to cover the CUP pad */
	esdi	 = layer(  "ESD" ) 
	/*  For 0.18um 1.8V/5V on i/o esd's implant only. */
	inddmy	 = layer( "INDDUMMY" type("drawing") ) 
	/*  Dummy layer to define inductor */
	sealring	 = layer(  "SEALRING" ) 
	/*  SEAL-RING Layer used for SR.S.1 check */
	logo	 = layer(  "LOGO" ) 
	/*  Dummy layer for product labels and LOGO */
	lupwdmy	 = layer( "LUPWDMY" type("drawing") ) 
	/*  DRC dummy layer to waive Latch-Up rules for verified IP. */
	sbddmy	 = layer( "SBDDMY" type("drawing") ) 
	/* A layer for DRC,LVS and creating mask logic operation Use "SBDDMY" to fully cover schottky barrier diode. */
	rfdummy	 = layer( "RFDUMMY" type("drawing1") ) 
	/*  recognize RF dummy layer for LVS purpose. */
	vdddmy	 = layer( "LUPWDMY" type("dummy1") ) 
	
	vssdmy	 = layer( "LUPWDMY" type("dummy2") ) 
	
	dm1excl	 = layer( "DMEXCL" type("dummy1") ) 
	
	dm2excl	 = layer( "DMEXCL" type("dummy2") ) 
	
	dm3excl	 = layer( "DMEXCL" type("dummy3") ) 
	
	dm4excl	 = layer( "DMEXCL" type("dummy4") ) 
	
	dm5excl	 = layer( "DMEXCL" type("dummy5") ) 
	
	dm6excl	 = layer( "DMEXCL" type("dummy6") ) 
	
	dmdexcl	 = layer( "DMEXCL" type("dummyf") ) 
        m1pin = text( "METAL1" type("pin") )
        m2pin = text( "METAL2" type("pin") )
        m3pin = text( "METAL3" type("pin") )
        m4pin = text( "METAL4" type("pin") )
        m5pin = text( "METAL5" type("pin") )
        m6pin = text( "METAL6" type("pin") )
	)
layerDefs( "gds2"
chip = cellBoundary(root)
	nweli	 = layer(  2 ) 
	/*  Nwell technology */
	diffi	 = layer(  3 type( 0 ( 2:255 )  ) ) 
	/*  Active areas */
	dod	 = layer(  3 type( 1) ) 
	/*  Dummy OD (DIFF) */
	odblk	 = layer(  150 type( 20) ) 
	/*  DOD blocking for insertion */
	pdiffi	 = layer(  11 ) 
	/*  Active areas */
	ndiffi	 = layer(  12 ) 
	/*  Active areas */
	od2i	 = layer(  4 ) 
	/*  Define thick gate oxides */
	polyi	 = layer(  13 type( 0 ( 2:255 )  ) ) 
	/*  Polysilicon gates, interconnect */
	dpo	 = layer(  13 type( 1) ) 
	/*  Dummy Poly */
	poblk	 = layer(  150 type( 21) ) 
	/*  DPO blocking for insertion */
	ppi	 = layer(  7 ) 
	/*  P+ S/D imlant */
	npi	 = layer(  8 ) 
	/*  N+ S/D imlant */
	bjtdummy	 = layer(  49 ) 
	/*  BJT dummy layer */
	diodummy	 = layer(  56 ) 
	/*  Diode dummy layer */
	coi	 = layer(  15 ) 
	/*  Define connection from M1 to S/D and Gate */
	m1i	 = layer(  16 type( 0 ( 3:255 )  ) ) 
	/*  First Metal layer */
	via1i	 = layer(  17 ) 
	/*  Define connection from M2 to M1 */
	m2i	 = layer(  18 type( 0 ( 3:255 )  ) ) 
	/*  Second Metal layer */
	via2i	 = layer(  27 ) 
	/*  Define connection from M3 to M2 */
	m3i	 = layer(  28 type( 0 ( 3:255 )  ) ) 
	/*  Third Metal layer */
	via3i	 = layer(  29 ) 
	/*  Define connection from M4 to M3 */
	m4i	 = layer(  31 type( 0 ( 3:255 )  ) ) 
	/*  Fourth Metal layer */
	via4i	 = layer(  32 ) 
	/*  Define connection from M5 to M4 */
	m5i	 = layer(  33 type( 0 ( 3:255 )  ) ) 
	/*  Fifth Metal layer */
	via5i	 = layer(  39 ) 
	/*  Define connection from M6 to M5 */
	m6i	 = layer(  38 type( 0 ( 3:255 )  ) ) 
	/*  Sixth Metal layer   */
	viadi	 = layer(  167 ) 
	/*  Define connect from MD to Top Metal */
	mdi	 = layer(  168 type( 0 ( 3:255 )  ) ) 
	/*  RDL Metal layer above Top Metal */
	cbi	 = layer(  19 ) 
	/*  Passivation opening for Bond Pad */
	cbdi	 = layer(  169 ) 
	/*  Definition of passivation window for bump */
	ubmi	 = layer(  170 ) 
	/*  Bond Pad definition for RDL */
	ppii	 = layer(  189 type( 0 ) ) 
	/*  Post Passivation RDL */
	rpoi	 = layer(  34 ) 
	/*  Salicided Block Layer */
	ntni	 = layer(  129 ) 
	/*  Native NMOS blocked implantation */
	plmidei	 = layer(  89 ) 
	/*  Polymide (if drawn) */
	dnwi	 = layer(  82 ) 
	/*  Deep N-WELL */
	vtmpi	 = layer(  23 ) 
	/*  Blocking region of PMOS VT implantation */
	vtmni	 = layer(  24 ) 
	/*  Blocking region of NMOS VT implantation */
	pv_p	 = layer(  71 ) 
	/*  PV_P pmos varactor p+ implant layer */
	pv_n	 = layer(  72 ) 
	/*  PV_N pmos varactor n+ blocking layer */
	hrii	 = layer(  48 ) 
	/*  High Resistor implant */
;========================
;== Dummy Metal layers ==
;========================
	m1dmy	 = layer(  16 type( 1) ) 
	/*  Metal1 dummy (if drawn) */
	m2dmy	 = layer(  18 type( 1) ) 
	/*  Metal2 dummy (if drawn) */
	m3dmy	 = layer(  28 type( 1) ) 
	/*  Metal3 dummy (if drawn) */
	m4dmy	 = layer(  31 type( 1) ) 
	/*  Metal4 dummy (if drawn) */
	m5dmy	 = layer(  33 type( 1) ) 
	/*  Metal5 dummy (if drawn) */
	m6dmy	 = layer(  38 type( 1) ) 
	/*  Metal6 dummy (if drawn) */
	mddmy	 = layer(  168 type( 1) ) 
	/*  MD dummy (if drawn) */
;=======================
;== Metal Slot layers ==
;=======================
	m1sloti	 = layer(  16 type( 2) ) 
	/*  Metal1 slot (if drawn) */
	m2sloti	 = layer(  18 type( 2) ) 
	/*  Metal2 slot (if drawn) */
	m3sloti	 = layer(  28 type( 2) ) 
	/*  Metal3 slot (if drawn) */
	m4sloti	 = layer(  31 type( 2) ) 
	/*  Metal4 slot (if drawn) */
	m5sloti	 = layer(  33 type( 2) ) 
	/*  Metal5 slot (if drawn) */
	m6sloti	 = layer(  38 type( 2) ) 
	/*  Metal6 slot (if drawn) */
	mdsloti	 = layer(  168 type( 2) ) 
	/*  MD slot (if drawn) */
;=================================
;==  Capacitor Top Metal Layers ==
;=================================
	ctm2i	 = layer(  67 type( 2) ) 
	/*  Capacitor Top Metal-2 */
	ctm3i	 = layer(  67 type( 3) ) 
	/*  Capacitor Top Metal-3 */
	ctm4i	 = layer(  67 type( 4) ) 
	/*  Capacitor Top Metal-4 */
	ctm5i	 = layer(  67 type( 5) ) 
	/*  Capacitor Top Metal-5 */
;===================
;==  Dummy Layers ==
;===================
	hotwl	 = layer(  51 ) 
	/*  Hot N-Well (SEE README HOT_NWEL NOTES) */
	excli	 = layer(  55 ) 
	/*  Exclude layer */
	drcdmy	 = layer(  60 ) 
	/*  DRC I/O waiver */
	rwdmy	 = layer(  52 ) 
	/*  NWEL Resistor dummy layer */
	dpdmy	 = layer(  65 ) 
	/*  Dummy Pad area dummy layer */
	pldmy	 = layer(  66 ) 
	/*  Power Line area dummy layer */
	sdi	 = layer(  58 ) 
	/*  IO ESD region dummy layer */
	esd1dmy	 = layer(  136 ) 
	/*  IO ESD region dummy layer, RPO must enclose whole gate */
	esd2dmy	 = layer(  137 ) 
	/*  IO ESD region dummy layer, RPO enclose gate 0.05 for 3.3V */
	esd3dmy	 = layer(  234 ) 
	
	ctmdmy	 = layer(  131 ) 
	/*  Cover metal as a capacitor bottom plate */
	rlppdmy	 = layer(  134 ) 
	/*  HRI high Poly resistor dummy layer */
	dmn2v	 = layer(  184 ) 
	/*  Dummy layer to ensure N2V in N+ poly/OD resistor */
	dmp2v	 = layer(  149 ) 
	/*  Dummy layer to ensure P2V in P+ poly/OD resistor */
	vardmy	 = layer(  138 ) 
	/*  Dummy layer to cover varactor device */
	pmdmy	 = layer(  236 ) 
	/*  Dummy layer to cover fuse window and protection ring structur */
	fwi	 = layer(  235 ) 
	/*  Fuse window when x, (x+1) = 3  */
	lmark	 = layer(  63 type( 1) ) 
	/*  L target window for bump process */
	lwi	 = layer(  63 type( 2) ) 
	/*  L target window for bump process */
	wbdmy	 = layer(  183 ) 
	/*  Dummy layer to cover the CUP pad */
	esdi	 = layer(  30 ) 
	/*  For 0.18um 1.8V/5V on i/o esd's implant only. */
	inddmy	 = layer(  139 type( 0) ) 
	/*  Dummy layer to define inductor */
	sealring	 = layer(  126 ) 
	/*  SEAL-RING Layer used for SR.S.1 check */
	logo	 = layer(  178 ) 
	/*  Dummy layer for product labels and LOGO */
	lupwdmy	 = layer(  255 type( 1) ) 
	/*  DRC dummy layer to waive Latch-Up rules for verified IP. */
	sbddmy	 = layer(  144 type( 0) ) 
	/* A layer for DRC,LVS and creating mask logic operation Use "SBDDMY" to fully cover schottky barrier diode. */
	rfdummy	 = layer(  160 type( 1) ) 
	/*  recognize RF dummy layer for LVS purpose. */
	vdddmy	 = layer(  255 type( 4) ) 
	
	vssdmy	 = layer(  255 type( 5) ) 
	
	dm1excl	 = layer(  150 type( 1) ) 
	
	dm2excl	 = layer(  150 type( 2) ) 
	
	dm3excl	 = layer(  150 type( 3) ) 
	
	dm4excl	 = layer(  150 type( 4) ) 
	
	dm5excl	 = layer(  150 type( 5) ) 
	
	dm6excl	 = layer(  150 type( 6) ) 
	
	dmdexcl	 = layer(  150 type( 15) ) 
        m1pin = text( 40 type( 0 ) ) 
        m2pin = text( 41 type( 0 ) ) 
        m3pin = text( 42 type( 0 ) ) 
        m4pin = text( 43 type( 0 ) ) 
        m5pin = text( 44 type( 0 ) ) 
        m6pin = text( 45 type( 0 ) ) 
	)


ivIf(!switch("SkipGridCheck") then
offGrid( nweli 0.005 1 "nweli offgrid")
offGrid( diffi 0.005 1 "diffi offgrid")
offGrid( dod 0.005 1 "dod offgrid")
offGrid( odblk 0.005 1 "odblk offgrid")
offGrid( pdiffi 0.005 1 "pdiffi offgrid")
offGrid( ndiffi 0.005 1 "ndiffi offgrid")
offGrid( od2i 0.005 1 "od2i offgrid")
offGrid( polyi 0.005 1 "polyi offgrid")
offGrid( dpo 0.005 1 "dpo offgrid")
offGrid( poblk 0.005 1 "poblk offgrid")
offGrid( ppi 0.005 1 "ppi offgrid")
offGrid( npi 0.005 1 "npi offgrid")
offGrid( bjtdummy 0.005 1 "bjtdummy offgrid")
offGrid( diodummy 0.005 1 "diodummy offgrid")
offGrid( coi 0.005 1 "coi offgrid")
offGrid( m1i 0.005 1 "m1i offgrid")
offGrid( via1i 0.005 1 "via1i offgrid")
offGrid( m2i 0.005 1 "m2i offgrid")
offGrid( via2i 0.005 1 "via2i offgrid")
offGrid( m3i 0.005 1 "m3i offgrid")
offGrid( via3i 0.005 1 "via3i offgrid")
offGrid( m4i 0.005 1 "m4i offgrid")
offGrid( via4i 0.005 1 "via4i offgrid")
offGrid( m5i 0.005 1 "m5i offgrid")
offGrid( via5i 0.005 1 "via5i offgrid")
offGrid( m6i 0.005 1 "m6i offgrid")
offGrid( viadi 0.005 1 "viadi offgrid")
offGrid( mdi 0.005 1 "mdi offgrid")
offGrid( cbi 0.005 1 "cbi offgrid")
offGrid( cbdi 0.005 1 "cbdi offgrid")
offGrid( ubmi 0.005 1 "ubmi offgrid")
offGrid( ppii 0.005 1 "ppii offgrid")
offGrid( rpoi 0.005 1 "rpoi offgrid")
offGrid( ntni 0.005 1 "ntni offgrid")
offGrid( plmidei 0.005 1 "plmidei offgrid")
offGrid( dnwi 0.005 1 "dnwi offgrid")
offGrid( vtmpi 0.005 1 "vtmpi offgrid")
offGrid( vtmni 0.005 1 "vtmni offgrid")
offGrid( pv_p 0.005 1 "pv_p offgrid")
offGrid( pv_n 0.005 1 "pv_n offgrid")
offGrid( hrii 0.005 1 "hrii offgrid")
offGrid( m1dmy 0.005 1 "m1dmy offgrid")
offGrid( m2dmy 0.005 1 "m2dmy offgrid")
offGrid( m3dmy 0.005 1 "m3dmy offgrid")
offGrid( m4dmy 0.005 1 "m4dmy offgrid")
offGrid( m5dmy 0.005 1 "m5dmy offgrid")
offGrid( m6dmy 0.005 1 "m6dmy offgrid")
offGrid( mddmy 0.005 1 "mddmy offgrid")
offGrid( m1sloti 0.005 1 "m1sloti offgrid")
offGrid( m2sloti 0.005 1 "m2sloti offgrid")
offGrid( m3sloti 0.005 1 "m3sloti offgrid")
offGrid( m4sloti 0.005 1 "m4sloti offgrid")
offGrid( m5sloti 0.005 1 "m5sloti offgrid")
offGrid( m6sloti 0.005 1 "m6sloti offgrid")
offGrid( mdsloti 0.005 1 "mdsloti offgrid")
offGrid( ctm2i 0.005 1 "ctm2i offgrid")
offGrid( ctm3i 0.005 1 "ctm3i offgrid")
offGrid( ctm4i 0.005 1 "ctm4i offgrid")
offGrid( ctm5i 0.005 1 "ctm5i offgrid")
offGrid( hotwl 0.005 1 "hotwl offgrid")
offGrid( excli 0.005 1 "excli offgrid")
offGrid( drcdmy 0.005 1 "drcdmy offgrid")
offGrid( rwdmy 0.005 1 "rwdmy offgrid")
offGrid( dpdmy 0.005 1 "dpdmy offgrid")
offGrid( pldmy 0.005 1 "pldmy offgrid")
offGrid( sdi 0.005 1 "sdi offgrid")
offGrid( esd1dmy 0.005 1 "esd1dmy offgrid")
offGrid( esd2dmy 0.005 1 "esd2dmy offgrid")
offGrid( esd3dmy 0.005 1 "esd3dmy offgrid")
offGrid( ctmdmy 0.005 1 "ctmdmy offgrid")
offGrid( rlppdmy 0.005 1 "rlppdmy offgrid")
offGrid( dmn2v 0.005 1 "dmn2v offgrid")
offGrid( dmp2v 0.005 1 "dmp2v offgrid")
offGrid( vardmy 0.005 1 "vardmy offgrid")
offGrid( pmdmy 0.005 1 "pmdmy offgrid")
offGrid( fwi 0.005 1 "fwi offgrid")
offGrid( lmark 0.005 1 "lmark offgrid")
offGrid( lwi 0.005 1 "lwi offgrid")
offGrid( wbdmy 0.005 1 "wbdmy offgrid")
offGrid( esdi 0.005 1 "esdi offgrid")
offGrid( inddmy 0.005 1 "inddmy offgrid")
offGrid( sealring 0.005 1 "sealring offgrid")
offGrid( logo 0.005 1 "logo offgrid")
offGrid( lupwdmy 0.005 1 "lupwdmy offgrid")
offGrid( sbddmy 0.005 1 "sbddmy offgrid")
offGrid( rfdummy 0.005 1 "rfdummy offgrid")
offGrid( vdddmy 0.005 1 "vdddmy offgrid")
offGrid( vssdmy 0.005 1 "vssdmy offgrid")
offGrid( dm1excl 0.005 1 "dm1excl offgrid")
offGrid( dm2excl 0.005 1 "dm2excl offgrid")
offGrid( dm3excl 0.005 1 "dm3excl offgrid")
offGrid( dm4excl 0.005 1 "dm4excl offgrid")
offGrid( dm5excl 0.005 1 "dm5excl offgrid")
offGrid( dm6excl 0.005 1 "dm6excl offgrid")
offGrid( dmdexcl 0.005 1 "dmdexcl offgrid")

)

;============================
;====DRC check procedure ====
;============================
;=== MX.W.1 ===
;==============

procedure( MxW1( Mx Mx_Width )
           let( ()
           MxW1a  = drc( Mx   width < Mx_Width withCornerTouch )
           MxW1b  = geomStretchCorner(geomGetCorner( Mx keep < 90 ) Mx_Width angleAll)
           Mx_W_1 = geomOr( MxW1a MxW1b )
              ) ;end of let
          ) ;end of procedure

;==============
;=== MX.S.2 ===
;==============

procedure( MxS2( Mx_ORIG Mx_NEW Mx_WIDE GRID Mx_SPACE Mx_INCR Mx_DIST ANGLE1 ANGLE2 )
           let( ()
                Mx_S5            = geomGrow( Mx_ORIG -Mx_WIDE/2 -Mx_WIDE/2 -Mx_WIDE/2 -Mx_WIDE/2 )
                Mx_G5            = geomGrow( Mx_S5    Mx_WIDE/2  Mx_WIDE/2  Mx_WIDE/2  Mx_WIDE/2  )
                Mx_Wide          = geomAnd( Mx_G5 Mx_ORIG )
                Mx_Exp           = geomSizeAnd( Mx_Wide Mx_ORIG Mx_INCR Mx_DIST )
                Mx_Branch        = geomAndNot( Mx_Exp Mx_Wide )
                Mx_Branch_edge   = geomGetEdge( Mx_Branch coincident Mx_ORIG  wholeEdge   )
                Mx_Check         = geomAnd( Mx_ORIG geomSize( Mx_Exp Mx_SPACE noClipAcute ) )
                Mx_Branch_Check0 = geomSize( Mx_Branch_edge Mx_SPACE chainEdges noClipAcute )
                Mx_Branch_Check1 = geomSize( Mx_Branch_edge GRID chainEdges noClipAcute )
                Mx_Branch_Check2 = drc( Mx_Branch_Check1   sepNotch < GRID withSingularPoint )
                Mx_Branch_Check3 = geomSize( Mx_Branch_Check2 (Mx_SPACE-GRID) noClipAcute )
                Mx_Branch_Check  = geomAnd( Mx_ORIG geomOr( Mx_Branch_Check0 Mx_Branch_Check3 ) )
                Mx_WideC         = geomCat( Mx_Wide )
                Mx_CheckC        = geomCat( Mx_Check )
                Mx_BranchC       = geomCat( Mx_Branch )
                Mx_Branch_CheckC = geomCat( Mx_Branch_Check )
                geomStamp( Mx_WideC        Mx_NEW )
                geomStamp( Mx_CheckC       Mx_NEW )
                geomStamp( Mx_BranchC      Mx_NEW )
                geomStamp( Mx_Branch_Check Mx_NEW )
                MxS2a = drc( Mx_WideC   Mx_CheckC        ANGLE1 < sep < Mx_SPACE diffNet ANGLE1 < withIntersection < ANGLE2 )
                MxS2b = drc( Mx_BranchC Mx_Branch_CheckC ANGLE1 < sep < Mx_SPACE diffNet ANGLE1 < withIntersection < ANGLE2 )
                MxS2  = geomOr( MxS2a MxS2b )
               ) ;end of let
            ) ;end of procedure

;=============
;==== END ====
;=============


 m1i_or1 =  geomOr(m1i m1dmy)  
 m1xd = geomAndNot(m1i_or1 m1sloti)  
 m1x = geomAndNot(m1i m1sloti)  
 m2i_or1 =  geomOr(m2i m2dmy)  
 m2xd = geomAndNot(m2i_or1 m2sloti)  
 m2x = geomAndNot(m2i m2sloti)  
 m3i_or1 =  geomOr(m3i m3dmy)  
 m3xd = geomAndNot(m3i_or1 m3sloti)  
 m3x = geomAndNot(m3i m3sloti)  
 m4i_or1 =  geomOr(m4i m4dmy)  
 m4xd = geomAndNot(m4i_or1 m4sloti)  
 m4x = geomAndNot(m4i m4sloti)  
 m5i_or1 =  geomOr(m5i m5dmy)  
 m5xd = geomAndNot(m5i_or1 m5sloti)  
 m5x = geomAndNot(m5i m5sloti)  
 m6i_or1 =  geomOr(m6i m6dmy)  
 m6xd = geomAndNot(m6i_or1 m6sloti)  
 m6x = geomAndNot(m6i m6sloti)  
 mdi_or1 =  geomOr(mdi mddmy)  
 mdxd = geomAndNot(mdi_or1 mdsloti)  
 mdx = geomAndNot(mdi mdsloti)  
/* /////////////////////////////////////////////////////////////////////////////// */
/*  EXCLUDE UNCHECKED REGIONS */
/* -------------------------- */
 bulk = geomSize( chip 1.0 noClipAcute )   
 excl = geomAndNot(excli logo)  
if((CHECK_SRAM_EXCL == 1) then
 excl_s = geomAndNot(chip bulk)  /*  Use an empty layer to disable the usage of EXCL */
else;
 excl_s = geomCat(excl)  /*  EXCL_S = EXCL */ 
) ; 
/*  Front-End Layer */
/* ---------------- */
 pweli = geomAndNot(bulk nweli)  
 diffi_or1 =  geomOr(diffi ndiffi)  
 odi = geomOr(diffi_or1 pdiffi)  
 pwel = geomAndNot(pweli excl)  
 nwel = geomAndNot(nweli geomInside(nweli excl ))   
 dnw = geomAndNot(dnwi excl)  
 vtmp = geomAndNot(vtmpi excl)  
 vtmn = geomAndNot(vtmni excl)  
if((CHECK_DUMMY_ODPO == 1) then
 odi_or1 =  geomOr(odi dod)  
 od = geomAndNot(odi_or1 excl)  
 polyi_or1 =  geomOr(polyi dpo)  
 poly = geomAndNot(polyi_or1 excl)  
else;
 od = geomAndNot(odi excl)  
 poly = geomAndNot(polyi excl)  
) ; 
 od2 = geomAndNot(od2i excl)  
 pp = geomAndNot(ppi geomInside(ppi excl ))   
 np = geomAndNot(npi geomInside(npi excl ))   
 co = geomAndNot(coi excl)  
/*  Back-End Layer */
/* --------------- */
 m1 = geomAndNot(m1xd excl)  
 m1_a = geomAndNot(m1xd geomInside(m1xd excl ))   
 via1 = geomAndNot(via1i excl)  
 m2 = geomAndNot(m2xd geomInside(m2xd excl_s ))   
 via2 = geomAndNot(via2i geomInside(via2i excl_s ))   
 m3 = geomAndNot(m3xd geomInside(m3xd excl_s ))   
 via3 = geomAndNot(via3i geomInside(via3i excl_s ))   
 m4 = geomAndNot(m4xd geomInside(m4xd excl_s ))   
 via4 = geomAndNot(via4i geomInside(via4i excl_s ))   
 m5 = geomAndNot(m5xd geomInside(m5xd excl_s ))   
 via5 = geomAndNot(via5i geomInside(via5i excl_s ))   
 m6 = geomAndNot(m6xd geomInside(m6xd excl_s ))   
 viad = geomAndNot(viadi geomInside(viadi excl_s ))   
 md = geomAndNot(mdxd geomInside(mdxd excl_s ))   
 cb = geomAndNot(cbi excl_s)  
 cbd = geomAndNot(cbdi excl_s)  
 rpo = geomAndNot(rpoi excl)  
 ntn = geomAndNot(ntni excl)  
 plmide = geomAndNot(plmidei excl_s)  
/* FUSE	= FUSEi	NOT EXCL */
 fw = geomAndNot(fwi excl_s)  
 lw = geomAndNot(lwi excl_s)  
 hri = geomAndNot(hrii excl)  
 esd = geomAndNot(esdi excl_s)  
 ctm2 = geomAndNot(ctm2i excl_s)  
 ctm3 = geomAndNot(ctm3i excl_s)  
 ctm4 = geomAndNot(ctm4i excl_s)  
 ctm5 = geomAndNot(ctm5i excl_s)  
/*  GLOBAL DERIVED LAYERS FOR RULE CHECKS  */
/* -------------------------------------- */
 nrodi = geomAndNot(odi rpoi)  
 npodi = geomAnd(npi nrodi)  
 ppodi = geomAnd(ppi nrodi)  
 nonwri = geomAndNot(nweli geomButtOrOver(nweli rwdmy ))  /*  NWEL - NWR(OD) - NWR(STI) */ 
 ntapi = geomAnd(npodi nonwri)  /*  NWEL Pick-Up */
 nacti = geomAndNot(npodi nweli)  /*  NMOS Device */
 ptapi = geomAndNot(ppodi nweli)  /*  Substrate(PWEL) Pick-Up */
 pacti = geomAnd(ppodi nonwri)  /*  PMOS Device  */
 psdi = geomAndNot(pacti polyi)  /*  PMOS source/drain,separated */
 nsdi = geomAndNot(nacti polyi)  /*  NMOS source/drain,separated   */
 ilp1i = geomAndNot(polyi rpoi)  /*  Interconnection poly */
 npod = geomAnd(np od)  /*  N+ OD region */
 ppod = geomAnd(pp od)  /*  P+ OD region */
 rnwel = geomButtOrOver( nwel rwdmy  )  /*  NWEL resistor (UNDER OD & STI) */ 
 nonwr = geomAndNot(nwel rnwel)  /*  NWEL - NWR(OD) - NWR(STI) */
 ntap = geomAnd(npod nonwr)  /*  NWEL Pick-Up */
 nact = geomAndNot(npod nwel)  /*  NMOS Device */
 ptap = geomAndNot(ppod nwel)  /*  Substrate(PWEL) Pick-Up */
 pact = geomAnd(ppod nwel)  /*  PMOS Device */
 dact = geomOr(nact pact)  /*  NMOS and PMOS Device */
 dstp = geomOr(ntap ptap)  /*  NWEL and PWEL Pick-Up */
 imp = geomOr(pp np)  /*  N+ and P+ implant  */
 all_gate = geomAnd(poly od)  /*  Gate regions for NMOS and PMOS */
 poly_iso = geomAndNot(poly od)  /*  Interconnect POLY */
 lvgt = geomAndNot(all_gate od2)  /*  1.8V gate */
 hvgt = geomAnd(all_gate od2)  /*  3.3V gate */
 gate_w = geomGetEdge(poly inside od)  /*  Gate width */ 
 gate_l = geomGetEdge(od inside poly)  /*  Channel length */ 
 gate_np = geomAnd(all_gate np)  /*  N+ Gate */
 gate_pp = geomAnd(all_gate pp)  /*  P+ Gate */
 fpo1 = geomCat(poly_iso)  /*  Field poly */ 
 rpo_not_sdi = geomAndNot(rpo sdi)  
 pores = geomAnd(fpo1 rpo_not_sdi)  /*  POLY resistor region */
 ilp1 = geomAndNot(poly_iso rpo)  /*  Interconnection poly */
 od_out1 =  geomOutside( od rwdmy  )   
 ffod = geomOutside( od_out1 all_gate  )   
 odres = geomAnd(ffod rpo_not_sdi)  /*  OD resistor region */
 dmp2v_or1 =  geomOr(dmp2v dmn2v)  /*  High resistance poly resistor dummy layer for DRC */
 hrdmy = geomOr(dmp2v_or1 rlppdmy)  /*  High resistance poly resistor dummy layer for DRC */
 hrep = geomAnd(pores hrdmy)  /*  High precision and resistacne poly resistor */
 hvn_gox = geomAnd(npod od2)  /*  Device n-type diffusion for thick gate NMOS */
 hvp_gox = geomAnd(ppod od2)  /*  Device p-type diffusion for thick gate PMOS */
 hv_ngate_w = geomGetEdge(gate_w inside hvn_gox)  /*  3.3V NMOS gate edges */ 
 hv_pgate_w = geomGetEdge(gate_w inside hvp_gox)  /*  3.3V PMOS gate edges */ 
 butt_ntap = geomButtOnly(geomOutside(ntap pact) pact )  /*  NWEL Tap butting p-type active diffusion */ 
 nonb_ntap =  geomAndNot(ntap geomButtOnly(geomOutside(ntap pact) pact ))  /*  Non-butting ntap */ 
 butt_ptap = geomButtOnly(geomOutside(ptap nact) nact )  /*  PWEL Tap butting n-type active diffusion */ 
 nonb_ptap =  geomAndNot(ptap geomButtOnly(geomOutside(ptap nact) nact ))  /*  Non-butting ptap  */ 
 pp_bedge = geomGetEdge(butt_ptap butting nact)  /*  PP edge to form butted tap */ 
 np_bedge = geomGetEdge(butt_ntap butting pact)  /*  NP edge to form butted tap */ 
 od2_bedge = geomGetEdge(od2 inside od)   
 act_od = geomButtOrOver( od poly  )   
 pnsd = geomAndNot(act_od all_gate)  
 sdpo2 = geomButtOrOver( pnsd poly keep == 2 )  /*  S/D between two Poly gate */ 
 co_diff = geomOutside( co poly_iso  )  /*  Diffusion contacts + floating contacts */ 
 co_poly = geomAndNot(co geomOutside(co poly_iso ))  /*  POLY contacts */ 
 asd1 = geomEnclose( pnsd co_diff  )   
/*  For checks such as PP.C.4/C.5, NP.C.4/C.5. */
 gate_np_sz1 =  geomSize( gate_np 0.03 noClipAcute )   
 gate_np_sz1_and1 =  geomAnd(gate_np_sz1 poly)  
 exgate_np = geomSize( gate_np_sz1_and1 0.32 noClipAcute )   
 gate_pp_sz1 =  geomSize( gate_pp 0.03 noClipAcute )   
 gate_pp_sz1_and1 =  geomAnd(gate_pp_sz1 poly)  
 exgate_pp = geomSize( gate_pp_sz1_and1 0.32 noClipAcute )   
 cb_or1 =  geomOr(cb fw)  
 fuse_lmark = geomOr(cb_or1 lw)  
 rngx = geomAndNot(pmdmy fuse_lmark)  
 chip_core = geomSize( chip -10 noClipAcute )   
cb_out1 = geomHoles(cb  )
 padh = cb_out1  
 score = geomInside( chip_core padh  )   
 sr_chip = geomButtOrOver( chip score  )   
 sr_chip_sz1 =  geomSize( sr_chip -10 noClipAcute )   
 sr = geomAndNot(sr_chip sr_chip_sz1)  
 sr_cb = geomAnd(cb sr)  
 sr_co = geomAnd(co sr)  
 sr_via1 = geomAnd(via1 sr)  
 sr_via2 = geomAnd(via2 sr)  
 sr_via3 = geomAnd(via3 sr)  
 sr_via4 = geomAnd(via4 sr)  
 sr_via5 = geomAnd(via5 sr)  
 sr_viad = geomAnd(viad sr)  
 od_and1 =  geomAnd(od sbddmy)  
 sbdod = geomAnd(od_and1 nwel)  
 nw_sbd = geomButtOrOver( nwel sbdod  )   
 dnw_sbd = geomButtOrOver( dnw sbdod  )   
 pp_sbd = geomButtOrOver( pp sbdod  )   
pp_sbd_out1 = geomHoles(pp_sbd innermost )
 pp_sbd_hole = pp_sbd_out1  
 pp_sbd_all = geomOr(pp_sbd pp_sbd_hole)  
 pp_nsbd = geomAndNot(pp pp_sbd)  
 ppod_sbd = geomButtOrOver( sbdod pp  )   
 npod_sbd = geomAnd(sbdod np)  
 ppod_sbd_gap = geomSize(ppod_sbd 0.48 edges)   
 ppod_sbd_g = geomButtOnly(geomOutside(ppod_sbd_gap npod_sbd) npod_sbd )   
 npod_sbd_gap = geomSize(npod_sbd 0.48 edges)   
 npod_sbd_g = geomButtOnly(geomOutside(npod_sbd_gap ppod_sbd) ppod_sbd )   
 ppod_sbd_or1 =  geomOr(ppod_sbd npod_sbd)  
 sbdod_all = geomOr(ppod_sbd_or1 ppod_sbd_g)  
 ppod_sbd_w = geomGetEdge( ppod_sbd butting npod_sbd_g wholeEdge ) 
 ppod_sbd_l = geomAndNot( ppod_sbd geomGetEdge( ppod_sbd butting npod_sbd_g wholeEdge )) 
 npod_sbd_w = geomGetEdge( npod_sbd butting ppod_sbd_g wholeEdge ) 
 chipx = geomCat(chip)   
GRID = 0.005
/*  BUILD CONNECTION FOR RULE CHECKS  */
/* --------------------------------- */
 viat = geomAndNot(via5i geomButtOrOver(via5i ctm5i ))   
 viac = geomAnd(via5i ctm5i)  
geomConnect( incremental
	buttOrOver(ntapi nweli)
	buttOrOver(ntapi psdi)
	buttOrOver(ptapi nsdi)
	via(coi m1xd ilp1i ntapi ptapi psdi nsdi)
	via(via1i m1xd m2xd)
	via(via2i m2xd m3xd)
	via(via3i m3xd m4xd)
	via(via4i m4xd m5xd)
	via(viat m5xd m6xd)
	via(viac ctm5i m6xd)
	via(viadi m6xd mdxd)
)
 errorLayer( geomAnd(rlppdmy od) 
	"HRI.WARN  RLPPDMY overlap OD is not allowed ") 
/* *************************************************************************************  */
/*  */
/*   warning messages to check whether some switchs are used corretly or not.  */
/*  */
/* ************************************************************************************* */
/* ====================================================================================== */
/*  1. Process selection warning. */
/* ====================================================================================== */
if((MIX_MODE == 0) then
 ctm5i_or1 =  geomOr(ctm5i inddmy)  
 ctm5i_or1_or1 =  geomOr(ctm5i_or1 hrii)  
 ctm5i_or1_or11 =  geomOr(ctm5i_or1_or1 dnwi)  
 ctm5i_or1_or111 =  geomOr(ctm5i_or1_or11 vtmpi)  
 warnprocess_1_mm_layers = geomOr(ctm5i_or1_or111 vtmni)  
 errorLayer( geomButtOrOver( chipx warnprocess_1_mm_layers  ) 
	"WARN.PROCESS_1 2  MIX_MODE switch should be turned on for Mixed Singal/RF process ")  
) ; 
if((MIX_MODE == 1) then
if(!(CORE_VOLTAGE == 1.8) then
 errorLayer( geomCat(chipx) 
	"WARN.PROCESS_2  Pls turn on (#DEFINE 1.8V) switch if you use Mixed Singal/RF process ")  
) ; 
if(!(HIGH_VOLTAGE == 3.3) then
 errorLayer( geomCat(chipx) 
	"WARN.PROCESS_3  Pls turn on (#DEFINE 3.3V) switch if you use Mixed Singal/RF process ")  
) ; 
if((LP == 1) then
 errorLayer( geomCat(chipx) 
	"WARN.PROCESS_4  Pls turn off (#DEFINE LP) switch if you use Mixed Singal/RF process.  Low power is not supported in Mixed Signal process  ")  
) ; 
if((CORE_VOLTAGE == 1.5) then
 errorLayer( geomCat(chipx) 
	"WARN.PROCESS_5  Pls turn off (#DEFINE 1.5V) switch if you use Mixed Singal/RF process Low voltage is not supported in Mixed Signal process ")  
) ; 
if((HIGH_VOLTAGE == 5) then
 errorLayer( geomCat(chipx) 
	"WARN.PROCESS_6  Pls turn off (#DEFINE 5V) switch if you use Mixed Singal/RF process 1.8V/5V is not supported in Mixed Signal process ")  
) ; 
) ; 
if((C016 == 1) then
if((HIGH_VOLTAGE == 5) then
 errorLayer( geomCat(chipx) 
	"WARN.PROCESS_7  Pls turn off (#DEFINE 5V) switch if you use 0.16um process 1.8V/5V is not supported in 0.16um process ")  
) ; 
if((CORE_VOLTAGE == 1.5) then
 errorLayer( geomCat(chipx) 
	"WARN.PROCESS_8  Pls turn off (#DEFINE 1.5V) switch if you use 0.16um process  Low voltage is not supported in 0.16um process ")  
) ; 
if((LP == 1) then
 errorLayer( geomCat(chipx) 
	"WARN.PROCESS_9  Pls turn off (#DEFINE LP) switch if you use 0.16um process  Low power is not supported in 0.16um process ")  
) ; 
) ; 
if((LP == 1) then
if((CORE_VOLTAGE == 1.5) then
 errorLayer( geomCat(chipx) 
	"WARN.PROCESS_10  Pls turn off (#DEFINE 1.5V) switch if you use 0.18um Low power process ")  
) ; 
) ; 
/* ====================================================================================== */
/*  2. Voltage selection warning. */
/* ====================================================================================== */
if(!(HIGH_VOLTAGE == 3.3) then
if(!(HIGH_VOLTAGE == 2.5) then
if(!(HIGH_VOLTAGE == 5) then
 errorLayer( geomCat(chipx) 
	"WARN.VOLTAGE_1  There must be specified an option of HIGH_VOLTAGE ")  
) ; 
) ; 
) ; 
if(!(CORE_VOLTAGE == 1.8) then
if(!(CORE_VOLTAGE == 1.5) then
 errorLayer( geomCat(chipx) 
	"WARN.VOLTAGE_2  There must be specified an option of CORE_VOLTAGE ")  
) ; 
) ; 
if((HIGH_VOLTAGE == 3.3) then
if((HIGH_VOLTAGE == 2.5) then
 errorLayer( geomCat(chipx) 
	"WARN.VOLTAGE_3  Only one HIGH_VOLTAGE can be specified every time.  ")  
) ; 
if((HIGH_VOLTAGE == 5) then
 errorLayer( geomCat(chipx) 
	"WARN.VOLTAGE_4  Only one HIGH_VOLTAGE can be specified every time. ")  
) ; 
) ; 
if((CORE_VOLTAGE == 1.8) then
if((CORE_VOLTAGE == 1.5) then
 errorLayer( geomCat(chipx) 
	"WARN.VOLTAGE_5  Only one CORE_VOLTAGE can be specified every time. ")  
) ; 
) ; 
if((CORE_VOLTAGE == 1.8) then
if((HIGH_VOLTAGE == 2.5) then
 errorLayer( geomCat(chipx) 
	"WARN.VOLTAGE_6  1.8V and 2.5V can not be specified at the same time. ")  
) ; 
) ; 
if((CORE_VOLTAGE == 1.5) then
if((HIGH_VOLTAGE == 5) then
 errorLayer( geomCat(chipx) 
	"WARN.VOLTAGE_7  1.5V and 5V can not be specified at the same time. ")  
) ; 
) ; 
/* ====================================================================================== */
/*  3. Thick top metal selection warning */
/* ====================================================================================== */
if((MIX_MODE == 0) then
if((THICK_40K == 1) then
 errorLayer( geomCat(chipx) 
	"WARN.THICK_TOP_METAL_1  20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process,  Other processes are not provided in this design rule. ")  
) ; 
if((THICK_20K == 1) then
 errorLayer( geomCat(chipx) 
	"WARN.THICK_TOP_METAL_2  20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process,  Other processes are not provided in this design rule. ")  
) ; 
) ; 
if((C016 == 1) then
if((THICK_40K == 1) then
 errorLayer( geomCat(chipx) 
	"WARN.THICK_TOP_METAL_3  20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process,  Other processes are not provided in this design rule. ")  
) ; 
if((THICK_20K == 1) then
 errorLayer( geomCat(chipx) 
	"WARN.THICK_TOP_METAL_4  20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process,  Other processes are not provided in this design rule. ")  
) ; 
) ; 
if((THICK_40K == 1) then
if((THICK_20K == 1) then
 errorLayer( geomCat(chipx) 
	"WARN.THICK_TOP_METAL_5  20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process,  and 20KA and 40KA should not be placed in the same chip. ")  
) ; 
) ; 
/* ====================================================================================== */
/*  4. DNW warning */
/* ====================================================================================== */
if((MIX_MODE == 0) then
 errorLayer( geomCat(dnwi) 
	"WARN.DNW  DNW only provide for MM/RF process ")  
) ; 
/* ====================================================================================== */
/*  5. NTN warning */
/* ====================================================================================== */
if((HIGH_VOLTAGE == 5) then
 errorLayer( geomCat(ntni) 
	"WARN.NTN_1  NTN devices don't provide for 0.18um 1.8V/5V General purpose,Low Power and  1.8V/3.3V Low Power process  ")  
) ; 
if((LP == 1) then
if((HIGH_VOLTAGE == 3.3) then
 errorLayer( geomCat(ntni) 
	"WARN.NTN_2  NTN devices don't provide for 0.18um 1.8V/5V General purpose,Low Power and  1.8V/3.3V Low Power process  ")  
) ; 
) ; 
/* ====================================================================================== */
/*  6. HRI warning */
/* ====================================================================================== */

/*  NWEL CHECKS */
/* ============= */
 nwel_and1 =  geomAnd(nwel hotwl)  
 hot_nwel = geomOr(nwel_and1 rnwel)  
 drc( nwel   width < 0.86  withCornerTouch 
	"NW.W.1  Min. NWEL width < 0.86 ")  
 drc( hot_nwel   width < 2.10  withCornerTouch 
	"NW.W.2  Min. HOT_NWEL width < 2.10 ")  
nws1_nwel_nodal = geomCat( nwel )
geomStamp(nws1_nwel_nodal nweli)  
 drc( nws1_nwel_nodal   sep < 1.40  diffNet shielded 
	"NW.S.1  Min. different potential NWEL space < 1.40 ")  
 drc( rnwel nwel  sep < 1.40  withIntersection withSingularPoint 
	"NW.S.1 2  Min. different potential NWEL space < 1.40 ")  
 drc( rnwel   sepNotch < 1.40  
	"NW.S.1 3  Min. different potential NWEL space < 1.40 ")  
 drc( nwel   sepNotch < 0.60  
	"NW.S.2  Min. same potential NWEL space < 0.6 ")  
/*  NWEL (within OD) RESISTOR CHECKS */
/* ==================================== */
 nwres = geomButtOrOver( rnwel rpo  )  /*  NWEL resistor (UNDER OD) */ 
 odwr = geomButtOrOver( od nwres  )  /*  OD area of NW resistor */ 
 npwr = geomButtOrOver( np nwres  )  /*  N+ implant on NW resistor terminals */ 
 cowr = geomButtOrOver( co_diff nwres  )  /*  Contact on NW resistor terminals */ 
 rhwr = geomAndNot(odwr rpo)  /*  Non-Salicided area of NW resistor */
rpo_out1 = geomHoles(rpo innermost )
 rponwr_h = rpo_out1  
 drc( odwr nwres  enc < 1.0  shielded withIntersection withSingularPoint 
	"NWR.E.1  Min. OD enclose NWEL resistor < 1.0 ")  
 errorLayer( geomStraddle( nwres odwr  ) 
	"NWR.E.1 2  Min. OD enclose NWEL resistor < 1.0 ")  
 drc( nwres cowr  enc < 0.3  shielded withIntersection withSingularPoint 
	"NWR.E.2  Min. NWEL resistor enclose CO < 0.3 ")  
 errorLayer( geomStraddle( cowr nwres  ) 
	"NWR.E.2 2  Min. NWEL resistor enclose CO < 0.3 ")  
 drc( rhwr nwres  enc < 0.3  shielded withIntersection withSingularPoint 
	"NWR.C.1  Min. RPO hole enclose NWEL < 0.3 ")  
 drc( rpo odwr  enc < 0.22  shielded withIntersection withSingularPoint 
	"NWR.C.2  Min. RPO enclose OD (with NWEL resistor) < 0.22 ")  
 drc( rhwr cowr  enc < 0.3  shielded withIntersection withSingularPoint 
	"NWR.C.3  Min. RPO hole enclose NWEL resistor CO < 0.3 ")  
 errorLayer( geomStraddle( cowr rhwr  ) 
	"NWR.C.3 2  Min. RPO hole enclose NWEL resistor CO < 0.3 ")  
 drc( npwr rpo  ovlp < 0.4  shielded withIntersection withSingularPoint 
	"NWR.O.1  Min. RPO overlap NP < 0.4 ")  
 nwro1_x = geomButtOrOver( rpo nwres  )   
nwro1_x_out1 = geomHoles(nwro1_x innermost )
 nwro11_h = nwro1_x_out1  
 errorLayer( geomAndNot(nwro11_h npwr) 
	"NWR.O.1 2  Min. RPO overlap NP < 0.4 ") 
 errorLayer( geomAnd(rwdmy npod) 
	"NWR.R.1  NW resistor doped by implants not allowed. ") 
 errorLayer( geomAnd(rwdmy ppod) 
	"NWR.R.1 2  NW resistor doped by implants not allowed. ") 
/* NWEL under STI */
 nwres_sti = geomAndNot(rnwel geomButtOrOver(rnwel rpo ))  /*  NWEL resistor (UNDER STI) */ 
 odwr_sti = geomButtOrOver( od nwres_sti  )   
 npwr_sti = geomButtOrOver( np nwres_sti  )   
 drc( npwr_sti odwr_sti  enc < 0.18  shielded withIntersection withSingularPoint 
	"NWR.E.3  Min. extension of NP to OD (NWEL resistor under STI) 0.18 um ")  
 errorLayer( geomAndNot(odwr_sti npwr_sti) 
	"NWR.E.3 2  Min. extension of NP to OD (NWEL resistor under STI) 0.18 um ") 
 nwres_and1 =  geomAnd(nwres odwr)  
 nwrr3_a = geomButtOrOver( odwr nwres_and1 keep > 1 )   
 errorLayer( geomButtOrOver( nwres nwrr3_a  ) 
	"NWR.R.3  Only one NW inside NWROD is allowed in one OD. ")  
 np_iact1 =  geomButtOrOver( np nwres  )   
 nwrr4_a = geomButtOrOver( odwr np_iact1 0 < keep < 2 )   
 np_iact2 =  geomButtOrOver( np nwres  )   
 nwrr41_b = geomButtOrOver( odwr np_iact2 keep > 2 )   
 nwrr42_c = geomOr(nwrr4_a nwrr41_b)  
 errorLayer( geomButtOrOver( np nwrr42_c  ) 
	"NWR.R.4  Only two NPS in NWROD is allowed in one od. ")  
 np_iact3 =  geomButtOrOver( np nwres  )   
 errorLayer( geomAndNot(odwr geomButtOrOver(odwr np_iact3 )) 
	"NWR.R.4 2  Only two NPS in NWROD is allowed in one od. ")  
 nwrr5_x = geomButtOrOver( odwr rponwr_h 0 < keep < 2 )   
 nwrr51_y = geomButtOrOver( odwr rponwr_h keep > 2 )   
 nwrr52_a = geomOr(nwrr5_x nwrr51_y)  
 nwrr53_d = geomAndNot(odwr geomButtOrOver(odwr rponwr_h ))   
 a_or1 =  geomOr(nwrr52_a nwrr53_d)  
 errorLayer( geomButtOrOver( rponwr_h a_or1  ) 
	"NWR.R.5  ONLY TWO RPO HOLES IN NWROD ARE ALLOWED. ")  
 nwres_ext1 =  drc( nwres   notch < 5  opposite )
 nwrr6_a = geomAndNot(nwres_ext1 nwres)  
 errorLayer( geomInside( nwrr6_a odwr  ) 
	"NWR.R.6  For U-shape or S-shape NWROD, both OD and NW must be U-shape or S-shape and the OD edge must be  parallel to the NW edge. DRC can only flag the pattern without OD space while 2 edges of NW  [NW space or notch <= 5 um] parallel length > 0 um ")  
if(!(HIGH_VOLTAGE == 5) then
/*  NT_N */
/* ====== */
 ntn_od = geomAndNot(od geomOutside(od ntn ))   
 ntn_po = geomAnd(poly ntn)  
 ntn_gate_w = geomGetEdge(ntn_po inside ntn_od)   
 co_or1 =  geomOr(co od)  
 ntn_po_iact1 =  geomButtOrOver( ntn_po co_or1  )   
 ntn_po_w = geomGetEdge(ntn_po_iact1 coincident poly)   
 errorLayer( geomAnd(ntn dnw) 
	"NT_N.I.1  NT_N interact DNW is not allowed. (Butted is allowed) ") 
 errorLayer( geomEnclose( ntn od keep > 1 ) 
	"NT_N.I.2  only one OD region allowed to be put in an NT_N region ")  
 errorLayer( geomAnd(ntn gate_pp) 
	"NT_N.I.3  A P+GATE is not allowed to be put in an NT_N region ") 
 ntn_po_w_ang01 = geomGetAngledEdge(ntn_po_w keep == 0)
 ntn_po_w_ang011 = geomGetAdjacentEdge(ntn_po_w ntn_po_w_ang01 )
 ntn_po_w_ang451 = geomGetAngledEdge(ntn_po_w keep == 45)
 errorLayer( geomAndNot(ntn_po_w_ang011 ntn_po_w_ang451) 
	"NT_N.I.4  A bent poly region is not allowed to put in an NT_N region ") 
 ntn_po_w_ang02 = geomGetAngledEdge(ntn_po_w keep == 0)
 ntn_po_w_ang021 = geomGetAdjacentEdge(ntn_po_w ntn_po_w_ang02 )
 ntn_po_w_ang901 = geomGetAngledEdge(ntn_po_w keep == 90)
 errorLayer( geomAndNot(ntn_po_w_ang021 ntn_po_w_ang901) 
	"NT_N.I.4 3  A bent poly region is not allowed to put in an NT_N region ") 
 drc( ntn   width < 0.74  withCornerTouch 
	"NT_N.W.1  For CL018G 1.8V/3.3V & CL018LV 1.5V/2.5V,minimum dimension of a NT_N region <0.74 ")  
if((CORE_VOLTAGE == 1.5) then
if((HIGH_VOLTAGE == 3.3) then
 drc( ntn   width < 0.86  withCornerTouch 
	"NT_N.W.1_1.5_3.3V  For CL018LV 1.5V/3.3V, minimum dimension of a NT_N region.<0.86 ")  
) ; 
) ; 
if((CORE_VOLTAGE == 1.8) then
if((C016 == 1) then
 drc( ntn_gate_w   width < 0.55  
	"NTN.W.2  Minimum poly gate dimension(channel length) of a 1.8V blocked NT_N device < 0.55 ")  
) ; 
if((C016 == 0) then
 drc( ntn_gate_w   width < 0.5  
	"NT_N.W.2_LV  Minimum Poly gate dimension of a 1.8V blocked NT_N device < 0.5 ")  
) ; 
) ; 
if((CORE_VOLTAGE == 1.5) then
 drc( ntn_gate_w   width < 0.37  
	"NT_N.W.2.LV  For CL018G,CL018LV 1.5/2.5V & 1.5/3.3V, minimum Poly gate dimension of a 1.5V blocked NT_N device < 0.37 ")  
 nt_nw2_hv_z = geomGetEdge(ntn_gate_w inside od2)   
 drc( nt_nw2_hv_z   width < 1.2  
	"NT_N.W.2_HV  For CL018G,CL018LV 1.5/2.5V & 1.5/3.3V, minimum Poly gate dimension of a {2.5V or 3.3V} blocked NT_N device < 1.2 ")  
) ; 
if((C016 == 0) then
if((HIGH_VOLTAGE == 3.3) then
 nt_nw2_33v_z = geomGetEdge(ntn_gate_w inside od2)   
 drc( nt_nw2_33v_z   width < 1.2  
	"NT_N.W.2_3.3V  For CL018G,CL018LV 1.5/2.5V & 1.5/3.3V, minimum Poly gate dimension of a {2.5V or 3.3V} blocked NT_N device < 1.2 ")  
) ; 
) ; 
if((C016 == 1) then
 ntnw2b_z = geomGetEdge(ntn_gate_w inside od2)   
 drc( ntnw2b_z   width < 1.32  
	"NTN.W.2B  Minimum poly gate dimension (channel length) of a 3.3V blocked NT_N device < 1.32 ")  
 ntnw3_a = geomButtOrOver( ntn_od ntn_po  )   
 drc( ntnw3_a   width < 0.245  
	"NTN.W.3  Minimum OD width of 1.8V/3.3V blocked NT_N device < 0.245 ")  
) ; 
 drc( ntn   sepNotch < 0.86  
	"NT_N.S.1  Minimum space between two NT_N regions < 0.86 ")  
 nt_ne1_a = geomButtOrOver( ntn npod  )   
 nt_ne11_b = geomButtOrOver( npod ntn  )   
 nt_ne12_c = geomSize( nt_ne11_b 0.26 noClipAcute )   
 nt_ne13_d = geomSize( nt_ne1_a -0.26 noClipAcute )   
 errorLayer( geomXor(nt_ne1_a nt_ne12_c) 
	"NT_N.E.1  Maximum and Minimum extension from NT_N region beyond an NP OD region 0.26 ") 
 errorLayer( geomXor(nt_ne11_b nt_ne13_d) 
	"NT_N.E.1 2  Maximum and Minimum extension from NT_N region beyond an NP OD region 0.26 ") 
if((CORE_VOLTAGE == 1.5) then
 drc( od2 ntn  enc < 0.86  shielded withIntersection withSingularPoint 
	"NT_N.E.2.LV  For CL018LV 1.5V/2.5V & 1.5V/3.3V, minimum extension from OD2 edge to geomAnd {2.5V or 3.3V}  NT_N region inside OD2 < 0.86um ")  
 errorLayer( geomStraddle( ntn od2  ) 
	"NT_N.E.2.LV 2  For CL018LV 1.5V/2.5V & 1.5V/3.3V, minimum extension from OD2 edge to geomAnd {2.5V or 3.3V}  NT_N region inside OD2 < 0.86um ")  
) ; 
 drc( od ntn  sep < 0.52  shielded withIntersection withSingularPoint 
	"NT_N.C.1  MInimum clearance from NT_N to OD < 0.52 ")  
 errorLayer( geomStraddle( od ntn  ) 
	"NT_N.C.1 2  MInimum clearance from NT_N to OD < 0.52 ")  
 drc( ntn nwel  sep < 1.66  shielded withIntersection withSingularPoint 
	"NT_N.C.2  Minimum clearance frome a NT_N region to NWEL edge < 1.66 ")  
 errorLayer( geomAnd(ntn nwel) 
	"NT_N.C.2 2  Minimum clearance frome a NT_N region to NWEL edge < 1.66 ") 
if((CORE_VOLTAGE == 1.5) then
 drc( ntn od2  sep < 0.86  shielded withIntersection withSingularPoint 
	"NT_N.C.3.LV  For CL018LV 1.5/2.5V & 1.5/3.3V, minimum clearance from 1.5V NT_N region to OD2 edge < 0.86um ")  
) ; 
 drc( poly ntn_od  enc < 0.35  shielded withIntersection withSingularPoint 
	"NT_N.PO.1  Minimum overlap of a PO region extended into field oxide(endcap) < 0.35 ")  
) ; /* #IFNDEF or IFDEF 5V */
/*  OD CHECKS */
/* ============== */
 drc( od   width < 0.22  withCornerTouch 
	"OD.W.1_OD.W.2  Min. OD width for MOS and interconnect < 0.22 ")  
 drc( od   sepNotch < 0.28  
	"OD.S.1  Min. OD space < 0.28 ")  
 drc( nonwr npod  enc < 0.12  shielded withIntersection withSingularPoint 
	"OD.C.1  Min. NWEL olap NPOD tie down < 0.12 ")  
 errorLayer( geomStraddle( npod nonwr  ) 
	"OD.C.1 2  Min. NWEL olap NPOD tie down < 0.12 ")  
 odc2_odc3_a = geomAndNot(npod geomInside(npod nwel ))   
 odc2_odc31_x = geomAndNot(odc2_odc3_a odwr)  
 drc( odc2_odc31_x nwel  sep < 0.43  shielded withIntersection withSingularPoint 
	"OD.C.2_OD.C.3  Min. NWEL to NPOD space < 0.43 ")  
 errorLayer( geomStraddle( odc2_odc31_x nwel  ) 
	"OD.C.2_OD.C.3 2  Min. NWEL to NPOD space < 0.43 ")  
 drc( nwel ppod  enc < 0.43  shielded withIntersection withSingularPoint 
	"OD.C.4  NWEL overlap PPOD < 0.43 ")  
 errorLayer( geomStraddle( ppod nwel  ) 
	"OD.C.4 2  NWEL overlap PPOD < 0.43 ")  
 drc( ptap nwel  sep < 0.12  shielded withIntersection withSingularPoint 
	"OD.C.5  NWEL space PPOD outside NW < 0.12 ")  
/*  OD.C.6 is checked by PP.C.5 and NP.C.5 */
/*  OD.S.2 is not necessary to check */
 dact_iact1 =  geomButtOrOver( dact all_gate  )   
 odw3_sd = geomAndNot(dact_iact1 all_gate)  
 odw31_np_pp_bte = geomGetEdge(npod butting ppod)   
 odw32_butted_edge = geomGetLength( odw31_np_pp_bte  keep < 0.42 )   
 odw32_butted_edge1 = geomSize(odw32_butted_edge 0.005 edges)
 odw33_check_sd = geomButtOrCoin( odw3_sd odw32_butted_edge1 )   
 check_sd_coin1 =  geomGetEdge(odw33_check_sd coincident od)   
 odw34_narrow_sd = drc( check_sd_coin1   width < 0.42  opposite )
 odw32_butted_edge2 = geomSize(odw32_butted_edge 0.005 edges)
 narrow_sd_with1 =  geomButtOrCoin( odw34_narrow_sd odw32_butted_edge2 )   
 gate_w_sz1 = geomSize(gate_w 0.005 edges)
 narrow_sd_with2 =  geomButtOrCoin( odw34_narrow_sd gate_w_sz1 )   
 odw35_check_od = geomOr(narrow_sd_with1 narrow_sd_with2)  
 od_coin1 =  geomGetEdge(od coincident odw35_check_od)   
 errorLayer( geomGetLength(od_coin1  keep > 0.8 contiguous ) 
	"OD.W.3  Length of active with width < 0.42, connected to butted strap > 0.8 ")  
 drc( od  area < 0.202 
	"OD.A.1  Min. area of stand-alone OD region < 0.202 ") 
if((HIGH_VOLTAGE == 5) then
/*  5V OD CHECKS */
/* ============== */
 npod_not1 =  geomAndNot(npod geomInside(npod nwel ))   
 odc21_odc31_x = geomAndNot(npod_not1 odwr)  
 odc21_odc311_y = geomButtOrOver( odc21_odc31_x od2  )   
 drc( odc21_odc311_y nwel  sep < 0.6  shielded withIntersection withSingularPoint 
	"OD.C.2.1_OD.C.3.1  Minimum clearance from NWEL edge to N+OD which interacts OD2 < 0.6 ")  
 odc41_x = geomButtOrOver( ppod od2  )   
 drc( nwel odc41_x  enc < 0.8  shielded withIntersection withSingularPoint 
	"OD.C.4.1  Minimum clearance from NWEL edge to P+OD which interacts OD2 < 0.8 ")  
) ; 
/*  OD2 CHECKS */
/* =============== */
 dactg = geomOr(dact all_gate)  
 od2e1_check_edge = drc( od2 dactg  enc < 0.32  shielded withIntersection withSingularPoint edgeb )
 errorLayer( geomAndNot(od2e1_check_edge geomGetEdge(od2e1_check_edge butting dstp)) 
	"OD2.E.1  Minimum extension of an OD2 region beyond an {active OD OR Gate} region>=0.32um ")  
 errorLayer( geomInside( od2 dactg  ) 
	"OD2.E.1 2  Minimum extension of an OD2 region beyond an {active OD OR Gate} region>=0.32um ") /*  OD2 totally inside OD */ 
if(!(HIGH_VOLTAGE == 5) then
if((CORE_VOLTAGE == 1.8) then
 drc( od2   sepNotch < 0.45  
	"OD2.S.1  For two well process (1.8V/3.3V C018G), minimum space between two OD2 regions. Merge if the space is less than 0.45um.>=0.45um ")  
) ; 
) ; 
if((CORE_VOLTAGE == 1.5) then
 drc( od2   sepNotch < 0.86  
	"OD2.S.1.LV  For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V C018LP, 1.8V/5.0V C018G/LP, minimum space between two OD2 regions. Merge if the space is less than 0.86um. ")  
) ; 
if((HIGH_VOLTAGE == 5) then
 drc( od2   sepNotch < 0.86  
	"OD2.S.1.5V  For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V C018LP, 1.8V/5.0V C018G/LP, minimum space between two OD2 regions. Merge if the space is less than 0.86um. ")  
) ; 
if((LP == 1) then
 drc( od2   sepNotch < 0.86  
	"OD2.S.1.LP  For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V C018LP, 1.8V/5.0V C018G/LP, minimum space between two OD2 regions. Merge if the space is less than 0.86um. ")  
) ; 
 drc( od2 nact  sep < 0.32  shielded withIntersection withSingularPoint 
	"OD2.C.1  Minimum clearance between OD region and an OD2 region>=0.32um ")  
 drc( od2 pact  sep < 0.32  shielded withIntersection withSingularPoint 
	"OD2.C.1 2  Minimum clearance between OD region and an OD2 region>=0.32um ")  
 od2c2_a = geomGetEdge(od2 inside dact)   
 drc( od2c2_a gate_w  sep < 0.40  shielded withIntersection 
	"OD2.C.2  Minimum clearance between OD2 region and {1.5V or 1.8V} transistor gate poly>= 0.4um ")  
 drc( od2_bedge gate_w  enc < 0.40  shielded withIntersection 
	"OD2.E.2  Minimum extension of OD2 region beyond {2.5V or 3.3V or 5V} transistor gate poly in the source/drain OD direction OD2 cut poly GATE is not allowed. >=0.4um ")  
 errorLayer( geomStraddle( all_gate od2  ) 
	"OD2.E.2 2  Minimum extension of OD2 region beyond {2.5V or 3.3V or 5V} transistor gate poly in the source/drain OD direction OD2 cut poly GATE is not allowed. >=0.4um ")  
if((CORE_VOLTAGE == 1.5) then
 drc( od2 nwel 0 < enc < 0.86  shielded withIntersection withSingularPoint 
	"OD2.E.4.LV  For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V C018LP, 1.8V/5.0V C018G/LP, minimum extension of an OD2 region beyond an NW region>=0.86um. Align if space is less than 0.86um ")  
 drc( nwel od2 0 < sep < 0.86  shielded withIntersection withSingularPoint 
	"OD2.C.4.LV  For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V C018LP, 1.8V/5.0V C018G/LP>=0.86um, minimum clearance between an OD2 region and an NW region. Align if space is less than 0.86um ")  
 drc( nwel od2 0 < enc < 0.86  shielded withIntersection withSingularPoint 
	"OD2.C.4.LV 2  For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V C018LP, 1.8V/5.0V C018G/LP>=0.86um, minimum clearance between an OD2 region and an NW region. Align if space is less than 0.86um ")  
 drc( nwel od2 0 < ovlp < 0.86  withIntersection withSingularPoint 
	"OD2.O.1.LV  For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V C018LP, 1.8V/5.0V C018G/LP>=0.86um minimum overlap between OD2 and NWEL >= 0.86um ")  
) ; 
if((HIGH_VOLTAGE == 5) then
 drc( od2 nwel 0 < enc < 0.86  shielded withIntersection withSingularPoint 
	"OD2.E.4.5V  For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V C018LP, 1.8V/5.0V C018G/LP, minimum extension of an OD2 region beyond an NW region>=0.86um. Align if space is less than 0.86um ")  
 drc( nwel od2 0 < sep < 0.86  shielded withIntersection withSingularPoint 
	"OD2.C.4.5V  For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V C018LP, 1.8V/5.0V C018G/LP>=0.86um, minimum clearance between an OD2 region and an NW region. Align if space is less than 0.86um ")  
 drc( nwel od2 0 < enc < 0.86  shielded withIntersection withSingularPoint 
	"OD2.C.4.5V 2  For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V C018LP, 1.8V/5.0V C018G/LP>=0.86um, minimum clearance between an OD2 region and an NW region. Align if space is less than 0.86um ")  
 drc( nwel od2 0 < ovlp < 0.86  withIntersection withSingularPoint 
	"OD2.O.1.5V  For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V C018LP, 1.8V/5.0V C018G/LP>=0.86um minimum overlap between OD2 and NWEL >= 0.86um ")  
) ; 
if((LP == 1) then
 drc( od2 nwel 0 < enc < 0.86  shielded withIntersection withSingularPoint 
	"OD2.E.4.LP  For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V C018LP, 1.8V/5.0V C018G/LP, minimum extension of an OD2 region beyond an NW region>=0.86um. Align if space is less than 0.86um ")  
 drc( nwel od2 0 < sep < 0.86  shielded withIntersection withSingularPoint 
	"OD2.C.4.LP  For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V C018LP, 1.8V/5.0V C018G/LP>=0.86um, minimum clearance between an OD2 region and an NW region. Align if space is less than 0.86um ")  
 drc( nwel od2 0 < enc < 0.86  shielded withIntersection withSingularPoint 
	"OD2.C.4.LP 2  For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V C018LP, 1.8V/5.0V C018G/LP>=0.86um, minimum clearance between an OD2 region and an NW region. Align if space is less than 0.86um ")  
 drc( nwel od2 0 < ovlp < 0.86  withIntersection withSingularPoint 
	"OD2.O.1.LP  For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V C018LP, 1.8V/5.0V C018G/LP>=0.86um minimum overlap between OD2 and NWEL >= 0.86um ")  
) ; 
/*  POLY checks */
/* ============= */
/* PO.W.1A is checked by PO.W.3 */
/* PO.W.2A is checked by PO.W.3 */
 drc( poly   width < 0.18  withCornerTouch 
	"PO.W.3  Min. POLY width for interconnect, 1.8V NMOS, 1.8V PMOS < 0.18 ")  
if((HIGH_VOLTAGE == 3.3) then
 drc( hv_pgate_w   width < 0.30  
	"PO.W.1_3.3V  Min. POLY gate length 3.3V pmos < 0.30 ")  
 drc( hv_ngate_w   width < 0.35  
	"PO.W.2_3.3V  Min. POLY gate length 3.3v nmos < 0.35 ")  
) ; 
if((HIGH_VOLTAGE == 2.5) then
 drc( hv_pgate_w   width < 0.26  
	"PO.W.1_2.5V  Min. POLY gate length 2.5V pmos < 0.26 ")  
 drc( hv_ngate_w   width < 0.26  
	"PO.W.2_2.5V  Min. POLY gate length 2.5v nmos < 0.26 ")  
) ; 
if((HIGH_VOLTAGE == 5) then
 drc( hv_pgate_w   width < 0.5  
	"PO.W.1_5V  Min. POLY gate length 5.0V pmos < 0.5 ")  
 drc( hv_ngate_w   width < 0.6  
	"PO.W.2_5V  Min. POLY gate length 5.0v nmos < 0.6 ")  
) ; 
 pos1_y = geomGetEdge(all_gate butting asd1)   
 drc( pos1_y  0 <  sepNotch < 0.375  
	"PO.S.1  Min. POLY space on OD with contact < 0.375 ")  
 drc( poly   sepNotch < 0.25  
	"PO.S.2_PO.S.3  Min. POLY space: on OD w/o contact and interconnect < 0.25 ")  
 drc( poly od  sep < 0.1  shielded withIntersection withSingularPoint 
	"PO.C.1  Min. POLY on field space to active < 0.1 ")  
 drc( od poly  enc < 0.32  shielded withIntersection withSingularPoint 
	"PO.C.2  Min. OD overhang gate < 0.32 ")  
 drc( poly od  enc < 0.22  shielded withIntersection withSingularPoint 
	"PO.O.1  Min. POLY overhang active < 0.22 ")  
if((MIX_MODE == 0) then
  por1a_gate_w1  = geomGetAngledEdge( gate_w keep == 0 mode1)
  por1a_gate_w10 = geomGetAngledEdge( gate_w keep == 90 mode1)
  por1a_gate_w1_sz  = geomSize( por1a_gate_w1  0.005 )
  por1a_gate_w10_sz = geomSize( por1a_gate_w10 0.005 )
  por1a_gate_w1_un  = geomSize( por1a_gate_w1  -0.005 )
  por1a_gate_w10_un = geomSize( por1a_gate_w10 -0.005 )
  por1a_1           = geomButtOrOver( por1a_gate_w1_sz por1a_gate_w10_sz )
  por1a_2           = geomButtOrOver( por1a_gate_w1_un por1a_gate_w10_un )
  por1a             = geomButtOrOver( poly geomOr( por1a_1 por1a_2 ) )
  errorLayer( por1a  "PO.R.1A 90 degree L shape and U shape bent gates are not allowed")
) ; 
 lvgt_ang1 = geomGetAngledEdge( lvgt keep == 45 )
 drc( lvgt_ang1   width < 0.21  opposite 
	"PO.R.1B  45 degree 1.8V gate min. length < 0.21 ")  
 por2_long_po = drc( ilp1  area > 0.18* 50 ) 
 por21_check_po = geomButtOrOver( por2_long_po co  )   
 por22_check_co = geomButtOrOver( co por21_check_po  )   
por23_co_a = geomSizeAnd( por22_check_co por21_check_po 0.25 50/2 )  
 por24_po_a = geomButtOrOver( por21_check_po por23_co_a keep == 1 )   
 por25_po_b = geomButtOrOver( por21_check_po por23_co_a keep > 1 )   
 por26_co_b = geomButtOrOver( por23_co_a por24_po_a  )   
por27_co_c = geomSizeAnd( por26_co_b por24_po_a 0.25 50/2 )  
 po_a_not1 =  geomAndNot(por24_po_a por27_co_c)  
 po_b_not1 =  geomAndNot(por25_po_b por23_co_a)  
 por28_bad = geomOr(po_a_not1 po_b_not1)  
 por29_bad_edge = geomGetEdge(por28_bad coincident poly)   
 por210_error = drc( por29_bad_edge   width <= 0.24  )
 errorLayer( geomButtOrOver( por21_check_po por210_error  ) 
	"PO.R.2  Max. POLY length between contacts when PO width less than 0.24um > 50.00 ")  
/*  Poly/OD Resistor CHECK */
/* ========== */
if((Recommend == 1) then
 res2_po_poresc = geomAndNot(pores geomButtOrOver(pores rlppdmy ))   
 drc( res2_po_poresc   width < 1.0  withCornerTouch 
	"RES.2_PO  For poly resistor, it is strongly recommended that the poly resistor width >= 1.0um, length >= 5.0um, and the resistor square number Nsq >= 5, DRC will check the width and length 1um and 5um for poly resistor & 2um and 10um for OD resistor,  respectively. Nsq is un-checkable    ")  
 res2_po1_res_l = geomGetEdge(res2_po_poresc coincident poly)   
 res2_po2_x = geomGetLength(res2_po1_res_l  keep < 5.0 contiguous )   
 res2_po2_x_sz1 = geomSize(res2_po2_x 0.005 edges)
 res2_po3_check_res = geomButtOrCoin( res2_po_poresc res2_po2_x_sz1 )   
 res2_po4_res_e = geomGetEdge(res2_po3_check_res coincident rpo)   
 res2_po5_a = geomSize(res2_po4_res_e -0.005 edges)   
res2_po6_b = geomSizeAnd( res2_po5_a res2_po_poresc 0.175 (5.0/2-0.005*2 ) )  
 res2_po7_c = geomAndNot(res2_po3_check_res res2_po6_b)  
 errorLayer( geomAndNot(res2_po3_check_res geomButtOrOver(res2_po3_check_res res2_po7_c )) 
	"RES.2_PO 2  For poly resistor, it is strongly recommended that the poly resistor width >= 1.0um, length >= 5.0um, and the resistor square number Nsq >= 5, DRC will check the width and length 1um and 5um for poly resistor & 2um and 10um for OD resistor,  respectively. Nsq is un-checkable    ")  
 res2_po8_d = drc( res2_po7_c   width < 0.005* 2  )
 errorLayer( geomButtOrOver( res2_po3_check_res res2_po8_d  ) 
	"RES.2_PO 3  For poly resistor, it is strongly recommended that the poly resistor width >= 1.0um, length >= 5.0um, and the resistor square number Nsq >= 5, DRC will check the width and length 1um and 5um for poly resistor & 2um and 10um for OD resistor,  respectively. Nsq is un-checkable    ")  
 res2_od_odresc = geomAndNot(odres geomButtOrOver(odres rlppdmy ))   
 drc( res2_od_odresc   width < 2.0  withCornerTouch 
	"RES.2_OD  For OD resistor, it is strongly recommended that the resistor width>=2.0 um and the resistor square number Nsq g 5. DRC will check the width and length 1um and 5um for poly resistor & 2um and 10um for OD resistor,  respectively. Nsq is un-checkable    ")  
 res2_od1_res_l = geomGetEdge(res2_od_odresc coincident od)   
 res2_od2_x = geomGetLength(res2_od1_res_l  keep < 10.0 contiguous )   
 res2_od2_x_sz1 = geomSize(res2_od2_x 0.005 edges)
 res2_od3_check_res = geomButtOrCoin( res2_od_odresc res2_od2_x_sz1 )   
 res2_od4_res_e = geomGetEdge(res2_od3_check_res coincident rpo)   
 res2_od5_a = geomSize(res2_od4_res_e -0.005 edges)   
res2_od6_b = geomSizeAnd( res2_od5_a res2_od_odresc 0.196 (10.0/2-0.005*2 ) )  
 res2_od7_c = geomAndNot(res2_od3_check_res res2_od6_b)  
 errorLayer( geomAndNot(res2_od3_check_res geomButtOrOver(res2_od3_check_res res2_od7_c )) 
	"RES.2_OD 2  For OD resistor, it is strongly recommended that the resistor width>=2.0 um and the resistor square number Nsq g 5. DRC will check the width and length 1um and 5um for poly resistor & 2um and 10um for OD resistor,  respectively. Nsq is un-checkable    ")  
 res2_od8_d = drc( res2_od7_c   width < 0.005* 2  )
 errorLayer( geomButtOrOver( res2_od3_check_res res2_od8_d  ) 
	"RES.2_OD 3  For OD resistor, it is strongly recommended that the resistor width>=2.0 um and the resistor square number Nsq g 5. DRC will check the width and length 1um and 5um for poly resistor & 2um and 10um for OD resistor,  respectively. Nsq is un-checkable    ")  
/*  For RES.2, "Nsq >= 5" can not be checked by DRC */
 dmpn2v = geomOr(dmp2v dmn2v)  
 pores_iact1 =  geomButtOrOver( pores pp  )   
 pores_iact1_not1 =  geomAndNot(pores_iact1 geomButtOrOver(pores_iact1 hrii ))   
 errorLayer( geomAndNot(pores_iact1_not1 dmp2v) 
	"RES.3_PO  The sheet resistance in SPICE model of non-salicided N+/P+ PO/OD resistors is resulted from N2V/NP and P2V/PP combinations, respectively. To obtain precise resistance, dummy layers (DMN2V & DMP2V) are required.N2V/P2V/N3V/P3V/N5V/P5V are derived from logical operation,  please ensure correct implants in caes the rsistor traverses NW/PW,1.8V/3.3V,1.8V/5V, 1.5V/3.3V or 1.5V/2.5V. Min. and Max. Extension of DMN2V/DMP2V to Poly resistor on field oxide should be == 0.22um.    ") 
 pores_iact2 =  geomButtOrOver( pores np  )   
 errorLayer( geomAndNot(pores_iact2 dmn2v) 
	"RES.3_PO 2  The sheet resistance in SPICE model of non-salicided N+/P+ PO/OD resistors is resulted from N2V/NP and P2V/PP combinations, respectively. To obtain precise resistance, dummy layers (DMN2V & DMP2V) are required.N2V/P2V/N3V/P3V/N5V/P5V are derived from logical operation,  please ensure correct implants in caes the rsistor traverses NW/PW,1.8V/3.3V,1.8V/5V, 1.5V/3.3V or 1.5V/2.5V. Min. and Max. Extension of DMN2V/DMP2V to Poly resistor on field oxide should be == 0.22um.    ") 
 dmp2v_and1 =  geomAnd(dmp2v dmn2v)  
 errorLayer( geomAnd(dmp2v_and1 pores) 
	"RES.3_PO 3  The sheet resistance in SPICE model of non-salicided N+/P+ PO/OD resistors is resulted from N2V/NP and P2V/PP combinations, respectively. To obtain precise resistance, dummy layers (DMN2V & DMP2V) are required.N2V/P2V/N3V/P3V/N5V/P5V are derived from logical operation,  please ensure correct implants in caes the rsistor traverses NW/PW,1.8V/3.3V,1.8V/5V, 1.5V/3.3V or 1.5V/2.5V. Min. and Max. Extension of DMN2V/DMP2V to Poly resistor on field oxide should be == 0.22um.    ") 
 res3_po_pores_po = geomButtOrOver( poly pores  )   
 drc( dmp2v res3_po_pores_po  enc < 0.22  shielded withIntersection withSingularPoint 
	"RES.3_PO 5  The sheet resistance in SPICE model of non-salicided N+/P+ PO/OD resistors is resulted from N2V/NP and P2V/PP combinations, respectively. To obtain precise resistance, dummy layers (DMN2V & DMP2V) are required.N2V/P2V/N3V/P3V/N5V/P5V are derived from logical operation,  please ensure correct implants in caes the rsistor traverses NW/PW,1.8V/3.3V,1.8V/5V, 1.5V/3.3V or 1.5V/2.5V. Min. and Max. Extension of DMN2V/DMP2V to Poly resistor on field oxide should be == 0.22um.    ")  
 drc( dmn2v res3_po_pores_po  enc < 0.22  shielded withIntersection withSingularPoint 
	"RES.3_PO 6  The sheet resistance in SPICE model of non-salicided N+/P+ PO/OD resistors is resulted from N2V/NP and P2V/PP combinations, respectively. To obtain precise resistance, dummy layers (DMN2V & DMP2V) are required.N2V/P2V/N3V/P3V/N5V/P5V are derived from logical operation,  please ensure correct implants in caes the rsistor traverses NW/PW,1.8V/3.3V,1.8V/5V, 1.5V/3.3V or 1.5V/2.5V. Min. and Max. Extension of DMN2V/DMP2V to Poly resistor on field oxide should be == 0.22um.    ")  
 dmpn2v_iact1 =  geomButtOrOver( dmpn2v pores  )   
 res3_po1_x = geomSize(geomStretch( dmpn2v_iact1 -0.005) -0.005 edges)   
 x_not1 =  geomAndNot(res3_po1_x geomButtOrOver(res3_po1_x res3_po_pores_po ))   
 dmpn2v_coin1 = geomGetEdge( dmpn2v coincident x_not1 wholeEdge )		
dmpn2v_but1 = geomGetEdge( dmpn2v butting x_not1 wholeEdge )
 dmpn2v_tch1 =  geomOr( dmpn2v_coin1 dmpn2v_but1 ) 
 res3_po2_y = geomSize(dmpn2v_tch1 -0.22 edges)   
 errorLayer(  geomAndNot(res3_po2_y geomButtOnly(geomOutside(res3_po2_y pores) pores )) 
	"RES.3_PO 8  The sheet resistance in SPICE model of non-salicided N+/P+ PO/OD resistors is resulted from N2V/NP and P2V/PP combinations, respectively. To obtain precise resistance, dummy layers (DMN2V & DMP2V) are required.N2V/P2V/N3V/P3V/N5V/P5V are derived from logical operation,  please ensure correct implants in caes the rsistor traverses NW/PW,1.8V/3.3V,1.8V/5V, 1.5V/3.3V or 1.5V/2.5V. Min. and Max. Extension of DMN2V/DMP2V to Poly resistor on field oxide should be == 0.22um.    ")  
 odres_iact1 =  geomButtOrOver( odres pp  )   
 errorLayer( geomAndNot(odres_iact1 dmp2v) 
	"RES.3_OD  The sheet resistance in SPICE model of non-salicided N+/P+ PO/OD resistors is resulted from N2V/NP and P2V/PP combinations, respectively. To obtain precise resistance, dummy layers (DMN2V & DMP2V) are required.N2V/P2V/N3V/P3V/N5V/P5V are derived from logical operation,  please ensure correct implants in caes the rsistor traverses NW/PW,1.8V/3.3V,1.8V/5V, 1.5V/3.3V or 1.5V/2.5V. Min. and Max. Extension of DMN2V/DMP2V to Poly resistor on field oxide should be == 0.22um.    ") 
 odres_iact2 =  geomButtOrOver( odres np  )   
 errorLayer( geomAndNot(odres_iact2 dmn2v) 
	"RES.3_OD 2  The sheet resistance in SPICE model of non-salicided N+/P+ PO/OD resistors is resulted from N2V/NP and P2V/PP combinations, respectively. To obtain precise resistance, dummy layers (DMN2V & DMP2V) are required.N2V/P2V/N3V/P3V/N5V/P5V are derived from logical operation,  please ensure correct implants in caes the rsistor traverses NW/PW,1.8V/3.3V,1.8V/5V, 1.5V/3.3V or 1.5V/2.5V. Min. and Max. Extension of DMN2V/DMP2V to Poly resistor on field oxide should be == 0.22um.    ") 
 dmp2v_and2 =  geomAnd(dmp2v dmn2v)  
 errorLayer( geomAnd(dmp2v_and2 odres) 
	"RES.3_OD 3  The sheet resistance in SPICE model of non-salicided N+/P+ PO/OD resistors is resulted from N2V/NP and P2V/PP combinations, respectively. To obtain precise resistance, dummy layers (DMN2V & DMP2V) are required.N2V/P2V/N3V/P3V/N5V/P5V are derived from logical operation,  please ensure correct implants in caes the rsistor traverses NW/PW,1.8V/3.3V,1.8V/5V, 1.5V/3.3V or 1.5V/2.5V. Min. and Max. Extension of DMN2V/DMP2V to Poly resistor on field oxide should be == 0.22um.    ") 
 res3_od_odres_od = geomButtOrOver( od odres  )   
 drc( dmp2v res3_od_odres_od  enc < 0.22  shielded withIntersection withSingularPoint 
	"RES.3_OD 5  The sheet resistance in SPICE model of non-salicided N+/P+ PO/OD resistors is resulted from N2V/NP and P2V/PP combinations, respectively. To obtain precise resistance, dummy layers (DMN2V & DMP2V) are required.N2V/P2V/N3V/P3V/N5V/P5V are derived from logical operation,  please ensure correct implants in caes the rsistor traverses NW/PW,1.8V/3.3V,1.8V/5V, 1.5V/3.3V or 1.5V/2.5V. Min. and Max. Extension of DMN2V/DMP2V to Poly resistor on field oxide should be == 0.22um.    ")  
 drc( dmn2v res3_od_odres_od  enc < 0.22  shielded withIntersection withSingularPoint 
	"RES.3_OD 6  The sheet resistance in SPICE model of non-salicided N+/P+ PO/OD resistors is resulted from N2V/NP and P2V/PP combinations, respectively. To obtain precise resistance, dummy layers (DMN2V & DMP2V) are required.N2V/P2V/N3V/P3V/N5V/P5V are derived from logical operation,  please ensure correct implants in caes the rsistor traverses NW/PW,1.8V/3.3V,1.8V/5V, 1.5V/3.3V or 1.5V/2.5V. Min. and Max. Extension of DMN2V/DMP2V to Poly resistor on field oxide should be == 0.22um.    ")  
 dmpn2v_iact2 =  geomButtOrOver( dmpn2v odres  )   
 res3_od1_x = geomSize(geomStretch( dmpn2v_iact2 -0.005) -0.005 edges)   
 x_not2 =  geomAndNot(res3_od1_x geomButtOrOver(res3_od1_x res3_od_odres_od ))   
 dmpn2v_coin2 = geomGetEdge( dmpn2v coincident x_not2 wholeEdge )		
dmpn2v_but2 = geomGetEdge( dmpn2v butting x_not2 wholeEdge )
 dmpn2v_tch2 =  geomOr( dmpn2v_coin2 dmpn2v_but2 ) 
 res3_od2_y = geomSize(dmpn2v_tch2 -0.22 edges)   
 errorLayer(  geomAndNot(res3_od2_y geomButtOnly(geomOutside(res3_od2_y odres) odres )) 
	"RES.3_OD 8  The sheet resistance in SPICE model of non-salicided N+/P+ PO/OD resistors is resulted from N2V/NP and P2V/PP combinations, respectively. To obtain precise resistance, dummy layers (DMN2V & DMP2V) are required.N2V/P2V/N3V/P3V/N5V/P5V are derived from logical operation,  please ensure correct implants in caes the rsistor traverses NW/PW,1.8V/3.3V,1.8V/5V, 1.5V/3.3V or 1.5V/2.5V. Min. and Max. Extension of DMN2V/DMP2V to Poly resistor on field oxide should be == 0.22um.    ")  
 res4_po_po_res = geomButtOrOver( poly pores  )   
 res4_po1_co_res = geomButtOrOver( co res4_po_po_res  )   
 res4_po2_rpo_e = geomGetEdge(rpo inside res4_po_po_res)   
 res4_po3_rpo_ex = geomSize(res4_po2_rpo_e 0.22 edges)   
 errorLayer( geomAnd(res4_po3_rpo_ex res4_po1_co_res) 
	"RES.4_PO  Min. and Max. clearance from RPO to a contact on the poly resistor and OD resistor = 0.22um ") 
 errorLayer( geomAndNot(res4_po3_rpo_ex geomButtOrOver(res4_po3_rpo_ex res4_po1_co_res )) 
	"RES.4_PO 2  Min. and Max. clearance from RPO to a contact on the poly resistor and OD resistor = 0.22um ")  
 errorLayer( geomAndNot(res4_po1_co_res geomButtOrOver(res4_po1_co_res res4_po3_rpo_ex )) 
	"RES.4_PO 3  Min. and Max. clearance from RPO to a contact on the poly resistor and OD resistor = 0.22um ")  
 res4_od_od_res = geomButtOrOver( od odres  )   
 res4_od1_co_res = geomButtOrOver( co res4_od_od_res  )   
 res4_od2_rpo_e = geomGetEdge(rpo inside res4_od_od_res)   
 res4_od3_rpo_ex = geomSize(res4_od2_rpo_e 0.22 edges)   
 errorLayer( geomAnd(res4_od3_rpo_ex res4_od1_co_res) 
	"RES.4_OD  Min. and Max. clearance from RPO to a contact on the poly resistor and OD resistor ==0.22um ") 
 errorLayer( geomAndNot(res4_od3_rpo_ex geomButtOrOver(res4_od3_rpo_ex res4_od1_co_res )) 
	"RES.4_OD 2  Min. and Max. clearance from RPO to a contact on the poly resistor and OD resistor ==0.22um ")  
 errorLayer( geomAndNot(res4_od1_co_res geomButtOrOver(res4_od1_co_res res4_od3_rpo_ex )) 
	"RES.4_OD 3  Min. and Max. clearance from RPO to a contact on the poly resistor and OD resistor ==0.22um ")  
 drc( pores imp  sep < 0.26  withIntersection withSingularPoint 
	"RES.5_PO  Min. clearance from poly resistor and OD resistor to un-related NP, PP regions >= 0.26um ")  
 drc( odres imp  sep < 0.26  withIntersection withSingularPoint 
	"RES.5_OD  Min. clearance from poly resistor and OD resistor to un-related NP, PP regions >= 0.26um ")  
 drc( pores rpo  sep < 0.3  withIntersection withSingularPoint 
	"RES.6_PO  Minimum clearance from an un-related RPO to the POLY and OD  resistor>= 0.3um ")  
 drc( odres rpo  sep < 0.3  withIntersection withSingularPoint 
	"RES.6_OD  Minimum clearance from an un-related RPO to the POLY and OD resistor>= 0.3um ")  
/*  RES.7 is checked by RES.4 */
/*  RES.8 is un-checkable by DRC */
) ; 
 errorLayer( geomAnd(dmp2v dmn2v) 
	"RES.9  DMN2V overlap DMP2V not allowed ") 
 drc( dmn2v all_gate  sep < 0.35  shielded withIntersection withSingularPoint 
	"RES.10  Minimum clearence from DMN2V to GATE(overlap is not allowed) >=0.35um ")  
 errorLayer( geomAnd(dmn2v all_gate) 
	"RES.10 2  Minimum clearence from DMN2V to GATE(overlap is not allowed) >=0.35um ") 
 drc( dmp2v all_gate  sep < 0.35  shielded withIntersection withSingularPoint 
	"RES.11  Minimum clearence from DMP2V to GATE(overlap is not allowed) >=0.35um ")  
 errorLayer( geomAnd(dmp2v all_gate) 
	"RES.11 2  Minimum clearence from DMP2V to GATE(overlap is not allowed) >=0.35um ") 
if((MIX_MODE == 1) then
if((Recommend == 1) then
 drc( hrep   width < 1.0  withCornerTouch 
	"RES.HRI.1  It is strongly recommended that the HRI poly resistor width e 1.0 um and resistor number of square Nsq e 2.  DRC will check the width and length 1um and 2um, respectively. Nsq is un-checkable ")  
 reshri1_res_l = geomGetEdge(hrep coincident poly)   
 reshri11_x = geomGetLength(reshri1_res_l  keep < 2.0 contiguous )   
 reshri11_x_sz1 = geomSize(reshri11_x 0.005 edges)
 reshri12_check_res = geomButtOrCoin( hrep reshri11_x_sz1 )   
 reshri13_res_e = geomGetEdge(reshri12_check_res coincident rlppdmy)   
 reshri14_a = geomSize(reshri13_res_e -0.005 edges)   
reshri15_b = geomSizeAnd( reshri14_a hrep 0.175 (2.0/2-0.005*2 ) )  
 reshri16_c = geomAndNot(reshri12_check_res reshri15_b)  
 errorLayer( geomAndNot(reshri12_check_res geomButtOrOver(reshri12_check_res reshri16_c )) 
	"RES.HRI.1 2  It is strongly recommended that the HRI poly resistor width e 1.0 um and resistor number of square Nsq e 2.  DRC will check the width and length 1um and 2um, respectively. Nsq is un-checkable ")  
 reshri17_d = drc( reshri16_c   width < 0.005* 2  )
 errorLayer( geomButtOrOver( reshri12_check_res reshri17_d  ) 
	"RES.HRI.1 3  It is strongly recommended that the HRI poly resistor width e 1.0 um and resistor number of square Nsq e 2.  DRC will check the width and length 1um and 2um, respectively. Nsq is un-checkable ")  
/* For RES.HRI.1, "Nsq >= 2" can not be checked by DRC */
/* RES.HRI.2 is checked by RES.4_PO */
/* RES.HRI.3 is checked by RES.5_PO */
/* RES.HRI.4 is checked by RES.6_PO  */
/* RES.HRI.5 is checked by RES.4_PO */
/* RES.HRI.6 un-checkable by DRC */
 reshri7_po_hrep = geomButtOrOver( poly hrep  )   
 drc( rlppdmy reshri7_po_hrep  enc < 0.26  shielded withIntersection withSingularPoint 
	"RES.HRI.7  Min. clearance from RLPPDMY to the HRI poly resistor >= 0.26um ")  
) ; 
) ; 
/*  PP CHECKS */
/* ============ */
 ppe4_nwelc = geomSize( nweli 0.43 noClipAcute )   
 ppe4_nwels = geomSize( ppe4_nwelc 0.18 noClipAcute )   
 ppe4_od = geomAnd(ptap ppe4_nwels)  
 ppe4_c1 = drc( pp ppe4_od 0 < enc < 0.18  opposite shielded withIntersection )
 ppe4_c2 = drc( pp ppe4_od 0 < enc < 0.18 corner shielded withIntersection )
 ppe4_c3 = drc( pp ppe4_od 0 < enc < 0.18  shielded  app == 0 parallel withIntersection )
 ppe4_c2_sz1 =  geomSize( ppe4_c2 0.005 noClipAcute )   
 ppe4_c4 = geomAndNot(ppe4_c2_sz1 ppe4_od)  
 ppe4_c1_or1 =  geomOr(ppe4_c1 ppe4_c3)  
 ppe4_all = geomOr(ppe4_c1_or1 ppe4_c4)  
 ppe4_checkod = geomGetEdge(ppe4_all butting ppe4_od)   
 npc3_c1 = drc( ppe4_od np 0 < sep < 0.18  opposite shielded withIntersection )
 npc3_c2 = drc( ppe4_od np 0 < sep < 0.18 corner shielded withIntersection )
 npc3_c3 = drc( ppe4_od np 0 < sep < 0.18  shielded  app == 0 parallel withIntersection )
 npc3_c2_sz1 =  geomSize( npc3_c2 0.005 noClipAcute )   
 npc3_c4 = geomAndNot(npc3_c2_sz1 ppe4_od)  
 npc3_c1_or1 =  geomOr(npc3_c1 npc3_c3)  
 npc3_all = geomOr(npc3_c1_or1 npc3_c4)  
 npc3_checkod = geomGetEdge(npc3_all butting ppe4_od)   
 npe4_nwelc = geomSize( nweli -0.43 noClipAcute )   
 npe4_nwels = geomSize( npe4_nwelc -0.18 noClipAcute )   
 npe4_od = geomAndNot(ntap npe4_nwels)  
 npe4_c1 = drc( np npe4_od 0 < enc < 0.18  opposite shielded withIntersection )
 npe4_c2 = drc( np npe4_od 0 < enc < 0.18 corner shielded withIntersection )
 npe4_c3 = drc( np npe4_od 0 < enc < 0.18  shielded  app == 0 parallel withIntersection )
 npe4_c2_sz1 =  geomSize( npe4_c2 0.005 noClipAcute )   
 npe4_c4 = geomAndNot(npe4_c2_sz1 npe4_od)  
 npe4_c1_or1 =  geomOr(npe4_c1 npe4_c3)  
 npe4_all = geomOr(npe4_c1_or1 npe4_c4)  
 npe4_checkod = geomGetEdge(npe4_all butting npe4_od)   
 ppc3_c1 = drc( npe4_od pp 0 < sep < 0.18  opposite shielded withIntersection )
 ppc3_c2 = drc( npe4_od pp 0 < sep < 0.18 corner shielded withIntersection )
 ppc3_c3 = drc( npe4_od pp 0 < sep < 0.18  shielded  app == 0 parallel withIntersection )
 ppc3_c2_sz1 =  geomSize( ppc3_c2 0.005 noClipAcute )   
 ppc3_c4 = geomAndNot(ppc3_c2_sz1 npe4_od)  
 ppc3_c1_or1 =  geomOr(ppc3_c1 ppc3_c3)  
 ppc3_all = geomOr(ppc3_c1_or1 ppc3_c4)  
 ppc3_checkod = geomGetEdge(ppc3_all butting npe4_od)   
 drc( pp   width < 0.440  withCornerTouch 
	"PP.W.1  PP width < 0.440 ")  
 drc( pp   sepNotch < 0.440  
	"PP.S.1  PP space < 0.440 ")  
/*  N active in pwell can be butting or non-butting.  */
/*  The non-butting N active is not allowed to touch PP. */
 drc( pp nact 0 < sep < 0.260  shielded withIntersection withSingularPoint 
	"PP.C.1 3  PP space to n active in pwell < 0.260 ")  
 ppc1_x = drc( pp nact  sep < 0.001  shielded withIntersection edgeb )
 ppc11_y = geomSize(ppc1_x 0.001 edges)   
 errorLayer( geomAndNot(ppc11_y geomButtOrOver(ppc11_y ppod )) 
	"PP.C.1 4  PP space to n active in pwell < 0.260 ")  
 drc( pp ntap 0 < sep < 0.1  shielded withIntersection withSingularPoint 
	"PP.C.2  PP space to non-butting NTAP < 0.1 with PWEL space >= 0.43 ")  
 errorLayer( geomGetEdge(ppc3_checkod outside npe4_nwelc) 
	"PP.C.3  PP space to non-butting NTAP < 0.18 with PWEL space < 0.43 ")  
/*  PP.C.4 is checked by NP.C.5 and PP.R.1 */
/*  This rule must extend out of gate in the direction of PO by 0.35um */
 errorLayer( geomAndNot(exgate_pp pp) 
	"PP.C.5 2  PP extension over (P gate) + (field poly within 0.35um) < 0.32um ") 
 drc( od pp_nsbd 0 < ovlp < 0.230  shielded withIntersection withSingularPoint 
	"PP.O.1  Minimum overlap from a PP edge to an OD region must >= 0.230um except SBD region  ")  
 drc( pp_nsbd pact 0 < enc < 0.180  shielded withIntersection withSingularPoint 
	"PP.E.1  Minimum extension of a PP region beyond a P+ active OD region must >=0.18um except SBD region ")  
 ppe1_y = drc( pp_nsbd pact  enc < 0.001  shielded withIntersection edgeb )
 ppe11_z = geomSize(ppe1_y 0.001 edges)   
 errorLayer( geomAndNot(ppe11_z geomButtOrOver(ppe11_z npod )) 
	"PP.E.1 2  Minimum extension of a PP region beyond a P+ active OD region must >=0.18um except SBD region ")  
 errorLayer( geomGetEdge(imp coincident od) 
	"PP.E.1_NP.E.1  Implant can not coincident OD edge except butted diffusion ")  
 drc( pp ptap 0 < enc < 0.02  shielded withIntersection withSingularPoint 
	"PP.E.3  Minimum enclosure of PTAP by PP < 0.02 with NWEL space >= 0.43 ")  
 ppe3_x = drc( pp ptap  enc < 0.001  shielded withIntersection edgeb )
 ppe31_y = geomSize(ppe3_x 0.001 edges)   
 errorLayer( geomAndNot(ppe31_y geomButtOrOver(ppe31_y npod )) 
	"PP.E.3 2  Minimum enclosure of PTAP by PP < 0.02 with NWEL space >= 0.43 ")  
 errorLayer( geomGetEdge(ppe4_checkod inside ppe4_nwelc) 
	"PP.E.4  Min. enc. of PTAP by PP < 0.18 with NWEL space < 0.43 ")  
/*  PP.C.6 is not necessary to check */
/*  PP.E.5 is not necessary to check */
 drc( pp  area < 0.3844 
	"PP.A.1  Minimum area of PP < 0.3844 ") 
if((MIX_MODE == 0) then
 drc( pp pores  enc < 0.18  shielded withIntersection withSingularPoint 
	"PP.E.6  Min enc of POLY resistor by PP < 0.18 ")  
 rpo_and1 =  geomAnd(rpo poly)  
 errorLayer( geomAndNot(rpo_and1 imp) 
	"PP.E.6 2  Min enc of POLY resistor by PP < 0.18 ") 
) ; 
 errorLayer( geomAnd(pp np) 
	"PP.R.1_NP.R.1  PP and NP not allowed to overlap ") 
/*  PP.R.2 is not necessary to check */
 od_iact1 =  geomButtOrOver( od polyi  )   
 od_iact1_not1 =  geomAndNot(od_iact1 odwr)  
 od_iact1_not11 =  geomAndNot(od_iact1_not1 sbddmy)  
 errorLayer( geomAndNot(od_iact1_not11 imp) 
	"PP.R.3_NP.R.3  OD must be fully covered by PP and NP ,except OD without interacting CO OR PO ") 
 od_iact2 =  geomButtOrOver( od coi  )   
 od_iact2_not1 =  geomAndNot(od_iact2 odwr)  
 od_iact2_not11 =  geomAndNot(od_iact2_not1 sbddmy)  
 errorLayer( geomAndNot(od_iact2_not11 imp) 
	"PP.R.3_NP.R.3 2  OD must be fully covered by PP and NP ,except OD without interacting CO OR PO ") 
/*  NP CHECKS */
/* ============ */
 drc( np   width < 0.440  withCornerTouch 
	"NP.W.1  NP width < 0.440 ")  
 drc( np   sepNotch < 0.440  
	"NP.S.1  NP space < 0.440 ")  
/*  P active in NWEL can be butting or non-butting. */
/*  The non-butting P active is not allowed to touch NP. */
 drc( np pact 0 < sep < 0.260  shielded withIntersection withSingularPoint 
	"NP.C.1 3  NP space to p active in NWEL < 0.260 ")  
 npc1_x = drc( np pact  sep < 0.001  shielded withIntersection edgeb )
 npc11_y = geomSize(npc1_x 0.001 edges)   
 errorLayer( geomAndNot(npc11_y geomButtOrOver(npc11_y npod )) 
	"NP.C.1 4  NP space to p active in NWEL < 0.260 ")  
 drc( np ptap 0 < sep < 0.1  shielded withIntersection withSingularPoint 
	"NP.C.2  NP space to non-butting ptap < 0.1 with NWEL space >= 0.43 ")  
 errorLayer( geomGetEdge(npc3_checkod inside ppe4_nwelc) 
	"NP.C.3  NP space to non-butting ptap < 0.18 with NWEL space < 0.43 ")  
/*  NP.C.4 is checked by PP.C.5 and NP.R.1 */
/*  This rule must extend out of gate in the direction of PO by 0.35um */
 errorLayer( geomAndNot(exgate_np np) 
	"NP.C.5 2  NP extension over (N gate) + (field poly within 0.35um) < 0.32um ") 
 drc( od np 0 < ovlp < 0.230  shielded withIntersection withSingularPoint 
	"NP.O.1  NP extends into n active < 0.230 ")  
 npe1_x = geomAndNot(nact odwr)  
 drc( np npe1_x 0 < enc < 0.180  shielded withIntersection withSingularPoint 
	"NP.E.1  NP olap OD < 0.180 ")  
 npe11_y = drc( np npe1_x  enc < 0.001  shielded withIntersection edgeb )
 npe12_z = geomSize(npe11_y 0.001 edges)   
 errorLayer( geomAndNot(npe12_z geomButtOrOver(npe12_z ppod )) 
	"NP.E.1 2  NP olap OD < 0.180 ")  
 drc( np ntap 0 < enc < 0.02  shielded withIntersection withSingularPoint 
	"NP.E.3  Minimum enclosure of NTAP by NP < 0.02 with PWEL space >= 0.43 ")  
 npe3_x = drc( np ntap  enc < 0.001  shielded withIntersection edgeb )
 npe31_y = geomSize(npe3_x 0.001 edges)   
 errorLayer( geomAndNot(npe31_y geomButtOrOver(npe31_y ppod )) 
	"NP.E.3 2  Minimum enclosure of NTAP by NP < 0.02 with PWEL space >= 0.43 ")  
 errorLayer( geomGetEdge(npe4_checkod outside npe4_nwelc) 
	"NP.E.4  Min. enc. of NTAP by NP < 0.18 with PWEL space < 0.43 ")  
/*  NP.C.6 is not checked by drc */
/*  NP.E.5 is not checked by drc */
 drc( np  area < 0.3844 
	"NP.A.1  Minimum area of NP < 0.3844 ") 
 drc( np pores  enc < 0.18  shielded withIntersection withSingularPoint 
	"NP.E.6  Min enc of POLY resistor by NP < 0.18 ")  
/*  NP.R.2 is not necessary to check */
/*  RPO checks */
/* =========== */
cb_out2 = geomHoles(cb  )
 cb_hole = cb_out2  
 cb_sr = geomButtOnly(geomOutside(cb cb_hole) cb_hole keep == 1)   
 rpo_not_sr = geomAndNot(rpo geomButtOrOver(rpo cb_sr ))   
 drc( rpo   width < 0.43  withCornerTouch 
	"RPO.W.1  Minimum RPO width < 0.43 ")  
 drc( rpo   sepNotch < 0.43  
	"RPO.S.1  Minimum RPO space < 0.43 ")  
 drc( rpo od  sep < 0.22  shielded withIntersection withSingularPoint 
	"RPO.C.1  Minimum RPO space to OD < 0.22 ")  
 drc( rpo co  sep < 0.22  shielded withIntersection withSingularPoint 
	"RPO.C.2  Minimum RPO space to CO < 0.22 ")  
 errorLayer( geomAnd(co rpo) 
	"RPO.C.2 2  Minimum RPO space to CO < 0.22 ") 
 all_gate_not1 =  geomAndNot(all_gate drcdmy)  
 all_gate_not11 =  geomAndNot(all_gate_not1 esd1dmy)  
 all_gate_not111 =  geomAndNot(all_gate_not11 esd2dmy)  
 all_gate_not1111 =  geomAndNot(all_gate_not111 esd3dmy)  
 rpoc3_a = geomAndNot(all_gate_not1111 sdi)  
 drc( rpo rpoc3_a  sep < 0.45  shielded withIntersection withSingularPoint 
	"RPO.C.3  Minimum RPO space to gate < 0.45 exclude ESD part ")  
 errorLayer( geomAnd(rpo rpoc3_a) 
	"RPO.C.3 2  Minimum RPO space to gate < 0.45 exclude ESD part ") 
 drc( rpo od  enc < 0.22  shielded withIntersection withSingularPoint 
	"RPO.C.4  Minimum RPO overhang OD < 0.22 ")  
 errorLayer( geomInside( rpo_not_sr od  ) 
	"RPO.C.4 2  Minimum RPO overhang OD < 0.22 ")  
 drc( od rpo  enc < 0.22  shielded withIntersection withSingularPoint 
	"RPO.E.1  Minimum OD overhang RPO < 0.22 ")  
 drc( rpo poly  enc < 0.22  shielded withIntersection withSingularPoint 
	"RPO.C.5  Minimum RPO overhang POLY < 0.22 ")  
 errorLayer( geomInside( rpo_not_sr poly  ) 
	"RPO.C.5 2  Minimum RPO overhang POLY < 0.22 ")  
 drc( rpo poly_iso  sep < 0.30  shielded withIntersection withSingularPoint 
	"RPO.C.6  Minimum clearance RPO to unrelated poly < 0.3um ")  
 drc( rpo  area < 2 
	"RPO.A.1  RPO min. area < 2 um*um ") 
/*  CO checks */
/* =============== */
 cow1_x = geomAndNot(co sr_co)  
 errorLayer( geomAndNot( cow1_x geomGetRectangle( cow1_x length == 0.22 width == 0.22 swap ) )
	"CO.W.1  contact width != 0.22 ")  
 drc( co   sepNotch < 0.25  
	"CO.S.1  contact spacing < 0.25 ")  
 cos2_a = geomSize( geomSize( co  0.30 *1.0/2 ) -0.30 *1.0/2)  /*  space < 0.3um treat as array */ 
 cos21_b = geomWidth(  cos2_a keep > 1.4   )  /*  (0.22*3+0.3*2) = 1.26  (3 COs Mix.) */ 
 cos22_c = geomButtOrOver( cos21_b co keep >= 16 )  /*  1.63-0.22 = 1.41       (Max. CO shift space)  */ 
 cos23_d = geomButtOrOver( co cos22_c  )  /*  so 1.26 < CONTY width < 1.41 */ 
 drc( cos23_d  0 <  sepNotch < 0.28  
	"CO.S.2  Min space between two contacts in larger than 4x4 array. ") /*  & we use CONTY width = 1.4 */ 
 drc( co_diff all_gate  sep < 0.16  shielded withIntersection withSingularPoint 
	"CO.C.1_CO.R.1  diff contact to gate space < 0.16, or contact on gate ")  
 errorLayer( geomAnd(co_diff all_gate) 
	"CO.C.1_CO.R.1 2  diff contact to gate space < 0.16, or contact on gate ") 
 drc( co_poly od  sep < 0.20  shielded withIntersection withSingularPoint 
	"CO.C.2  poly contact space to OD < 0.20 ")  
 drc( od co_diff  enc < 0.10  shielded withIntersection withSingularPoint 
	"CO.E.1  active olap contact < 0.10, also floating contacts ")  
 errorLayer( geomGetEdge(co_diff outside od) 
	"CO.E.1 2  active olap contact < 0.10, also floating contacts ")  
 drc( poly_iso co_poly  enc < 0.10  shielded withIntersection withSingularPoint 
	"CO.E.2  poly olap contact < 0.10 ")  
 errorLayer( geomStraddle( co_poly poly_iso  ) 
	"CO.E.2 2  poly olap contact < 0.10 ")  
 drc( pp_nsbd co_diff  enc < 0.12  shielded withIntersection withSingularPoint 
	"CO.E.3  Minimum extension of a PP region beyond a OD CO region must >=0.18um except SBD region ")  
 errorLayer( geomGetEdge(pp_nsbd inside co_diff) 
	"CO.E.3 2  Minimum extension of a PP region beyond a OD CO region must >=0.18um except SBD region ")  
 drc( np co_diff  enc < 0.12  shielded withIntersection withSingularPoint 
	"CO.E.4  implant olap contact < 0.12 ")  
 errorLayer( geomGetEdge(np inside co_diff) 
	"CO.E.4 2  implant olap contact < 0.12 ")  
/*  CO.R.2 is checked by CO.E.3/CO.E.4 */
/*  CO.R.3 is checked by RPO.C.2 */
/*  M1 checks */
/* ============= */

 M1_W_1 = 0.23
 M1W1 = MxW1( m1 M1_W_1 )
 errorLayer( M1W1 "M1.W.1  Min. M1 width < 0.23 ") 

 drc( m1   sepNotch < 0.23  
	"M1.S.1  Min. M1 space < 0.23 ")  

M1_WIDE = 10
M1S2    = 0.6 
M1_INCR = 0.161
M1_DIST = 1 
M1_S_2  = MxS2( m1 m1xd M1_WIDE GRID M1S2 M1_INCR M1_DIST 0 89.5 )
errorLayer( M1_S_2 "M1.S.2  Min. space to wide M1 (>10um) < 0.6 ")


 drc( m1 co  enc < 0.005  shielded withIntersection withSingularPoint 
	"M1.E.1  Min. extension of a M1 region beyond a CO region < 0.005 ")  
 errorLayer( geomAndNot(co m1) 
	"M1.E.1 2  Min. extension of a M1 region beyond a CO region < 0.005 ") 
 m1e2_x = drc( m1 co  enc < 0.06  oppositeB shielded withIntersection parallel edgeb )/*  a narrow side */
 m1e2_x_ang01 = geomGetAngledEdge(m1e2_x keep == 0)
 m1e2_x_ang011 = geomGetAdjacentEdge(m1e2_x m1e2_x_ang01 )
 m1e2_x_ang451 = geomGetAngledEdge(m1e2_x keep == 45)
 errorLayer( geomAndNot(m1e2_x_ang011 m1e2_x_ang451) 
	"M1.E.2  Min. extension of M1 end-of-line region beyond CO region < 0.06 ") /*  adjacent narrow sides */
 drc( m1_a  area < 0.202 
	"M1.A.1  Min. M1 area < 0.202 ") 
/*  Density check M1.R.1 included at the end of this file */
/*  VIA1 checks */
/* ============= */
 via1_core = geomAndNot(via1 sr_via1)  
 via1w1_a = geomAndNot( via1_core geomGetRectangle( via1_core length == 0.26 width == 0.26 swap ) )  
 errorLayer( geomOutside( via1w1_a rngx  ) 
	"VIA1.W.1  VIA1 must be 0.26 x 0.26 ") /*  exclude from metal fuse protection ring area */ 
 drc( via1   sepNotch < 0.26  
	"VIA1.S.1  Min. VIA1 space < 0.26 ")  
 drc( m1 via1  enc < 0.01  shielded withIntersection withSingularPoint 
	"VIA1.E.1  Min. extension of a M1 region beyond a VIA1 region < 0.01 ")  
 errorLayer( geomAndNot(via1 m1) 
	"VIA1.E.1 2  Min. extension of a M1 region beyond a VIA1 region < 0.01 ") 
 via1e2_x = drc( m1 via1  enc < 0.06  oppositeB shielded withIntersection edgeb )/*  a narrow side */
 via1e2_x_ang01 = geomGetAngledEdge(via1e2_x keep == 0)
 via1e2_x_ang011 = geomGetAdjacentEdge(via1e2_x via1e2_x_ang01 )
 via1e2_x_ang451 = geomGetAngledEdge(via1e2_x keep == 45)
 errorLayer( geomAndNot(via1e2_x_ang011 via1e2_x_ang451) 
	"VIA1.E.2  Min. extension of M1 end-of-line region beyond VIA1 region < 0.06 ") /*  adjacent narrow sides */
/*  M2 checks */
/* ============= */

 Mx_W_1 = 0.28
 M2W1 = MxW1( m2 Mx_W_1 )
 errorLayer( M2W1 "M2.W.1  Min. M2 width < 0.28 ") 

 drc( m2   sepNotch < 0.28  
	"M2.S.1  Min. M2 space < 0.28 ")  

M2_WIDE = 10
M2S2    = 0.6 
M2_INCR = 0.196
M2_DIST = 1 
M2_S_2  = MxS2( m2 m2xd M2_WIDE GRID M2S2 M2_INCR M2_DIST 0 89.5 )
errorLayer( M2_S_2 "M2.S.2  Min. space to wide M2 (>10um) < 0.6 ")


 drc( m2 via1  enc < 0.01  shielded withIntersection withSingularPoint 
	"M2.E.1  Min. extension of a M2 region beyond a VIA1 region < 0.01 ")  
 errorLayer( geomAndNot(via1 m2) 
	"M2.E.1 2  Min. extension of a M2 region beyond a VIA1 region < 0.01 ") 
 m2e2_x = drc( m2 via1  enc < 0.06  oppositeB shielded withIntersection parallel edgeb )/*  a narrow side */
 m2e2_x_ang01 = geomGetAngledEdge(m2e2_x keep == 0)
 m2e2_x_ang011 = geomGetAdjacentEdge(m2e2_x m2e2_x_ang01 )
 m2e2_x_ang451 = geomGetAngledEdge(m2e2_x keep == 45)
 errorLayer( geomAndNot(m2e2_x_ang011 m2e2_x_ang451) 
	"M2.E.2  Min. extension of M2 end-of-line region beyond VIA1 region < 0.06 ") /*  adjacent narrow sides */
 drc( m2  area < 0.202 
	"M2.A.1  Min M2 area region < 0.202 ") 
/*  Density check M2.R.1 included at the end of this file */
/*  VIA2 checks */
/* ============= */
 via2_core = geomAndNot(via2 sr_via2)  
 via2w1_a = geomAndNot( via2_core geomGetRectangle( via2_core length == 0.26 width == 0.26 swap ) )  
 errorLayer( geomOutside( via2w1_a rngx  ) 
	"VIA2.W.1  VIA2 must be 0.26 x 0.26 ") /*  exclude from metal fuse protection ring area */ 
 drc( via2   sepNotch < 0.26  
	"VIA2.S.1  Min. VIA2 space < 0.26 ")  
 drc( m2 via2  enc < 0.01  shielded withIntersection withSingularPoint 
	"VIA2.E.1  Min. extension of a M2 region beyond a VIA2 region < 0.01 ")  
 errorLayer( geomAndNot(via2 m2) 
	"VIA2.E.1 2  Min. extension of a M2 region beyond a VIA2 region < 0.01 ") 
 via2e2_x = drc( m2 via2  enc < 0.06  oppositeB shielded withIntersection edgeb )/*  a narrow side */
 via2e2_x_ang01 = geomGetAngledEdge(via2e2_x keep == 0)
 via2e2_x_ang011 = geomGetAdjacentEdge(via2e2_x via2e2_x_ang01 )
 via2e2_x_ang451 = geomGetAngledEdge(via2e2_x keep == 45)
 errorLayer( geomAndNot(via2e2_x_ang011 via2e2_x_ang451) 
	"VIA2.E.2  Min. extension of M2 end-of-line region beyond VIA2 region < 0.06 ") /*  adjacent narrow sides */
/*  M3 checks */
/* ============= */

 Mx_W_1 = 0.28
 M3W1 = MxW1( m3 Mx_W_1 )
 errorLayer( M3W1 "M3.W.1  Min. M3 width < 0.28 ") 

 drc( m3   sepNotch < 0.28  
	"M3.S.1  Min. M3 space < 0.28 ")  

M3_WIDE = 10
M3S2    = 0.6 
M3_INCR = 0.196
M3_DIST = 1 
M3_S_2  = MxS2( m3 m3xd M3_WIDE GRID M3S2 M3_INCR M3_DIST 0 89.5 )
errorLayer( M3_S_2 "M3.S.2  Min. space to wide M3 (>10um) < 0.6 ")

 drc( m3 via2  enc < 0.01  shielded withIntersection withSingularPoint 
	"M3.E.1  Min. extension of a M3 region beyond a VIA2 region < 0.01 ")  
 errorLayer( geomAndNot(via2 m3) 
	"M3.E.1 2  Min. extension of a M3 region beyond a VIA2 region < 0.01 ") 
 m3e2_x = drc( m3 via2  enc < 0.06  oppositeB shielded withIntersection parallel edgeb )/*  a narrow side */
 m3e2_x_ang01 = geomGetAngledEdge(m3e2_x keep == 0)
 m3e2_x_ang011 = geomGetAdjacentEdge(m3e2_x m3e2_x_ang01 )
 m3e2_x_ang451 = geomGetAngledEdge(m3e2_x keep == 45)
 errorLayer( geomAndNot(m3e2_x_ang011 m3e2_x_ang451) 
	"M3.E.2  Min. extension of M3 end-of-line region beyond VIA2 region < 0.06 ") /*  adjacent narrow sides */
 drc( m3  area < 0.202 
	"M3.A.1  Min M3 area region < 0.202 ") 
/*  Density check M3.R.1 included at the end of this file */
/*  VIA3 checks */
/* ============= */
 via3_core = geomAndNot(via3 sr_via3)  
 via3w1_a = geomAndNot( via3_core geomGetRectangle( via3_core length == 0.26 width == 0.26 swap ) )  
 errorLayer( geomOutside( via3w1_a rngx  ) 
	"VIA3.W.1  VIA3 must be 0.26 x 0.26 ") /*  exclude from metal fuse protection ring area */ 
 drc( via3   sepNotch < 0.26  
	"VIA3.S.1  Min. VIA3 space < 0.26 ")  
 drc( m3 via3  enc < 0.01  shielded withIntersection withSingularPoint 
	"VIA3.E.1  Min. extension of a M3 region beyond a VIA3 region < 0.01 ")  
 errorLayer( geomAndNot(via3 m3) 
	"VIA3.E.1 2  Min. extension of a M3 region beyond a VIA3 region < 0.01 ") 
 via3e2_x = drc( m3 via3  enc < 0.06  oppositeB shielded withIntersection edgeb )/*  a narrow side */
 via3e2_x_ang01 = geomGetAngledEdge(via3e2_x keep == 0)
 via3e2_x_ang011 = geomGetAdjacentEdge(via3e2_x via3e2_x_ang01 )
 via3e2_x_ang451 = geomGetAngledEdge(via3e2_x keep == 45)
 errorLayer( geomAndNot(via3e2_x_ang011 via3e2_x_ang451) 
	"VIA3.E.2  Min. extension of M3 end-of-line region beyond VIA3 region < 0.06 ") /*  adjacent narrow sides */
/*  M4 checks */
/* ============= */

 Mx_W_1 = 0.28
 M4W1 = MxW1( m4 Mx_W_1 )
 errorLayer( M4W1 "M4.W.1  Min. M4 width < 0.28 ") 

 drc( m4   sepNotch < 0.28  
	"M4.S.1  Min. M4 space < 0.28 ")  

M4_WIDE = 10
M4S2    = 0.6 
M4_INCR = 0.196
M4_DIST = 1 
M4_S_2  = MxS2( m4 m4xd M4_WIDE GRID M4S2 M4_INCR M4_DIST 0 89.5 )
errorLayer( M4_S_2 "M4.S.2  Min. space to wide M4 (>10um) < 0.6 ")

 drc( m4 via3  enc < 0.01  shielded withIntersection withSingularPoint 
	"M4.E.1  Min. extension of a M4 region beyond a VIA3 region < 0.01 ")  
 errorLayer( geomAndNot(via3 m4) 
	"M4.E.1 2  Min. extension of a M4 region beyond a VIA3 region < 0.01 ") 
 m4e2_x = drc( m4 via3  enc < 0.06  oppositeB shielded withIntersection parallel edgeb )/*  a narrow side */
 m4e2_x_ang01 = geomGetAngledEdge(m4e2_x keep == 0)
 m4e2_x_ang011 = geomGetAdjacentEdge(m4e2_x m4e2_x_ang01 )
 m4e2_x_ang451 = geomGetAngledEdge(m4e2_x keep == 45)
 errorLayer( geomAndNot(m4e2_x_ang011 m4e2_x_ang451) 
	"M4.E.2  Min. extension of M4 end-of-line region beyond VIA3 region < 0.06 ") /*  adjacent narrow sides */
 drc( m4  area < 0.202 
	"M4.A.1  Min M4 area region < 0.202 ") 
/*  Density check M4.R.1 included at the end of this file */
/*  VIA4 checks */
/* ============= */
 via4_core = geomAndNot(via4 sr_via4)  
 via4w1_a = geomAndNot( via4_core geomGetRectangle( via4_core length == 0.26 width == 0.26 swap ) )  
 errorLayer( geomOutside( via4w1_a rngx  ) 
	"VIA4.W.1  VIA4 must be 0.26 x 0.26 ") /*  exclude from metal fuse protection ring area */ 
 drc( via4   sepNotch < 0.26  
	"VIA4.S.1  Min. VIA4 space < 0.26 ")  
 drc( m4 via4  enc < 0.01  shielded withIntersection withSingularPoint 
	"VIA4.E.1  Min. extension of a M4 region beyond a VIA4 region < 0.01 ")  
 errorLayer( geomAndNot(via4 m4) 
	"VIA4.E.1 2  Min. extension of a M4 region beyond a VIA4 region < 0.01 ") 
 via4e2_x = drc( m4 via4  enc < 0.06  oppositeB shielded withIntersection edgeb )/*  a narrow side */
 via4e2_x_ang01 = geomGetAngledEdge(via4e2_x keep == 0)
 via4e2_x_ang011 = geomGetAdjacentEdge(via4e2_x via4e2_x_ang01 )
 via4e2_x_ang451 = geomGetAngledEdge(via4e2_x keep == 45)
 errorLayer( geomAndNot(via4e2_x_ang011 via4e2_x_ang451) 
	"VIA4.E.2  Min. extension of M4 end-of-line region beyond VIA4 region < 0.06 ") /*  adjacent narrow sides */
/*  M5 checks */
/* ============= */

 Mx_W_1 = 0.28
 M5W1 = MxW1( m5 Mx_W_1 )
 errorLayer( M5W1 "M5.W.1  Min. M5 width < 0.28 ") 

 drc( m5   sepNotch < 0.28  
	"M5.S.1  Min. M5 space < 0.28 ")  

M5_WIDE = 10
M5S2    = 0.6 
M5_INCR = 0.196
M5_DIST = 1 
M5_S_2  = MxS2( m5 m5xd M5_WIDE GRID M5S2 M5_INCR M5_DIST 0 89.5 )
errorLayer( M5_S_2 "M5.S.2  Min. space to wide M5 (>10um) < 0.6 ")


 drc( m5 via4  enc < 0.01  shielded withIntersection withSingularPoint 
	"M5.E.1  Min. extension of a M5 region beyond a VIA4 region < 0.01 ")  
 errorLayer( geomAndNot(via4 m5) 
	"M5.E.1 2  Min. extension of a M5 region beyond a VIA4 region < 0.01 ") 
 m5e2_x = drc( m5 via4  enc < 0.06  oppositeB shielded withIntersection parallel edgeb )/*  a narrow side */
 m5e2_x_ang01 = geomGetAngledEdge(m5e2_x keep == 0)
 m5e2_x_ang011 = geomGetAdjacentEdge(m5e2_x m5e2_x_ang01 )
 m5e2_x_ang451 = geomGetAngledEdge(m5e2_x keep == 45)
 errorLayer( geomAndNot(m5e2_x_ang011 m5e2_x_ang451) 
	"M5.E.2  Min. extension of M5 end-of-line region beyond VIA4 region < 0.06 ") /*  adjacent narrow sides */
 drc( m5  area < 0.202 
	"M5.A.1  Min M5 area region < 0.202 ") 
/*  Density check M5.R.1 included at the end of this file */
/*****  Variables for IMD crack check *****/
if((C016 == 0) then
VIA_W_1 = 8.0
VIA_S_1 = 3.2
VIA_S_2 = 2.8
VIA_S_2L = 15.0
VIA_A_5 = 300.0
VIA_A_4 = 725.0
VIA_A_3 = 960.0
VIA_A_2 = 6000.0
VIA_Merge = 1.605
) ; 
if((C016 == 1) then
VIA_W_1 = 8.9
VIA_S_1 = 3.56
VIA_S_2 = 3.12
VIA_S_2L = 16.7
VIA_A_5 = 333.0
VIA_A_4 = 806.0
VIA_A_3 = 1067.0
VIA_A_2 = 6667.0
VIA_Merge = 1.785
) ; 
VIA_D_1 = 0.10
VIA_S_3 = 0.49
VIA_Filter = 3.0
/* ******************************************** */
/***** Pre-processing for IMD crack check ****/
/* ******************************************** */
/*  */
/*  Processing for SAME Array Merged  */
/* ********************************* */
 via1_m = geomButtOrOver( via1 m1  )   
via1merge1 = geomSizeAnd( via1_m m1 0.46 VIA_S_1/2 )  
 via1merge2 = geomSize( geomSize( via1_m  VIA_S_1 *1.0/2 ) -VIA_S_1 *1.0/2)  /*  Any space <= VIA1_S_1 um treated as "array" */ 
 via1mergepre1 = geomAnd(via1merge1 via1merge2)  /*  Find merged via array(s) */
 via1mergepre11 = geomEncloseRect( via1mergepre1 VIA_W_1 VIA_S_2L )  /*  Find at least one width >= VIA_W_1 */ 
 via1mergepre12 = geomButtOrOver( via1_m via1mergepre11  )  /*  find VIA1 in the effective via arrary */ 
 via1mergepre13 = geomSize( geomSize( via1mergepre12  VIA_S_1 *1.0/2 ) -VIA_S_1 *1.0/2)  /*  Any space <= VIA1_S_1 um treated as "array" */ 
 via1mergepre2 = geomAnd(via1merge1 via1mergepre13)  /*  Find merged via array(s) */
 via1_same_array = geomWidth(  via1mergepre2 keep > VIA_Filter   )  /*  For broken small metal connection */ 
 via2_m = geomButtOrOver( via2 m2  )   
via2merge1 = geomSizeAnd( via2_m m2 0.46 VIA_S_1/2 )  
 via2merge2 = geomSize( geomSize( via2_m  VIA_S_1 *1.0/2 ) -VIA_S_1 *1.0/2)  /*  Any space <= VIA1_S_1 um treated as "array" */ 
 via2mergepre1 = geomAnd(via2merge1 via2merge2)  /*  Find merged via array(s) */
 via2mergepre11 = geomEncloseRect( via2mergepre1 VIA_W_1 VIA_S_2L )  /*  Find at least one width >= VIA_W_1 */ 
 via2mergepre12 = geomButtOrOver( via2_m via2mergepre11  )  /*  find VIA2 in the effective via arrary */ 
 via2mergepre13 = geomSize( geomSize( via2mergepre12  VIA_S_1 *1.0/2 ) -VIA_S_1 *1.0/2)  /*  Any space <= VIA1_S_1 um treated as "array" */ 
 via2mergepre2 = geomAnd(via2merge1 via2mergepre13)  /*  Find merged via array(s) */
 via2_same_array = geomWidth(  via2mergepre2 keep > VIA_Filter   )  /*  For broken small metal connection */ 
 via3_m = geomButtOrOver( via3 m3  )   
via3merge1 = geomSizeAnd( via3_m m3 0.46 VIA_S_1/2 )  
 via3merge2 = geomSize( geomSize( via3_m  VIA_S_1 *1.0/2 ) -VIA_S_1 *1.0/2)  /*  Any space <= VIA1_S_1 um treated as "array" */ 
 via3mergepre1 = geomAnd(via3merge1 via3merge2)  /*  Find merged via array(s) */
 via3mergepre11 = geomEncloseRect( via3mergepre1 VIA_W_1 VIA_S_2L )  /*  Find at least one width >= VIA_W_1 */ 
 via3mergepre12 = geomButtOrOver( via3_m via3mergepre11  )  /*  find VIA3 in the effective via arrary */ 
 via3mergepre13 = geomSize( geomSize( via3mergepre12  VIA_S_1 *1.0/2 ) -VIA_S_1 *1.0/2)  /*  Any space <= VIA1_S_1 um treated as "array" */ 
 via3mergepre2 = geomAnd(via3merge1 via3mergepre13)  /*  Find merged via array(s) */
 via3_same_array = geomWidth(  via3mergepre2 keep > VIA_Filter   )  /*  For broken small metal connection */ 
 via4_m = geomButtOrOver( via4 m4  )   
via4merge1 = geomSizeAnd( via4_m m4 0.46 VIA_S_1/2 )  
 via4merge2 = geomSize( geomSize( via4_m  VIA_S_1 *1.0/2 ) -VIA_S_1 *1.0/2)  /*  Any space <= VIA1_S_1 um treated as "array" */ 
 via4mergepre1 = geomAnd(via4merge1 via4merge2)  /*  Find merged via array(s) */
 via4mergepre11 = geomEncloseRect( via4mergepre1 VIA_W_1 VIA_S_2L )  /*  Find at least one width >= VIA_W_1 */ 
 via4mergepre12 = geomButtOrOver( via4_m via4mergepre11  )  /*  find VIA4 in the effective via arrary */ 
 via4mergepre13 = geomSize( geomSize( via4mergepre12  VIA_S_1 *1.0/2 ) -VIA_S_1 *1.0/2)  /*  Any space <= VIA1_S_1 um treated as "array" */ 
 via4mergepre2 = geomAnd(via4merge1 via4mergepre13)  /*  Find merged via array(s) */
 via4_same_array = geomWidth(  via4mergepre2 keep > VIA_Filter   )  /*  For broken small metal connection */ 
 via5_m = geomButtOrOver( via5 m5  )   
via5merge1 = geomSizeAnd( via5_m m5 0.46 VIA_S_1/2 )  
 via5merge2 = geomSize( geomSize( via5_m  VIA_S_1 *1.0/2 ) -VIA_S_1 *1.0/2)  /*  Any space <= VIA1_S_1 um treated as "array" */ 
 via5mergepre1 = geomAnd(via5merge1 via5merge2)  /*  Find merged via array(s) */
 via5mergepre11 = geomEncloseRect( via5mergepre1 VIA_W_1 VIA_S_2L )  /*  Find at least one width >= VIA_W_1 */ 
 via5mergepre12 = geomButtOrOver( via5_m via5mergepre11  )  /*  find VIA5 in the effective via arrary */ 
 via5mergepre13 = geomSize( geomSize( via5mergepre12  VIA_S_1 *1.0/2 ) -VIA_S_1 *1.0/2)  /*  Any space <= VIA1_S_1 um treated as "array" */ 
 via5mergepre2 = geomAnd(via5merge1 via5mergepre13)  /*  Find merged via array(s) */
 via5_same_array = geomWidth(  via5mergepre2 keep > VIA_Filter   )  /*  For broken small metal connection */ 
/*  Processing for 5 ~ 2 Stack Array   */
/* ********************************** */
 via1_same_array1 =  drc( via1_same_array  area >= VIA_A_5 ) 
 via2_same_array1 =  drc( via2_same_array  area >= VIA_A_5 ) 
 via1_same_array11 =  geomAnd(via1_same_array1 via2_same_array1)  
 via3_same_array1 =  drc( via3_same_array  area >= VIA_A_5 ) 
 via1_same_array111 =  geomAnd(via1_same_array11 via3_same_array1)  
 via4_same_array1 =  drc( via4_same_array  area >= VIA_A_5 ) 
 via1_same_array1111 =  geomAnd(via1_same_array111 via4_same_array1)  
 via5_same_array1 =  drc( via5_same_array  area >= VIA_A_5 ) 
 via1_same_array_5stackpre1 = geomAnd(via1_same_array1111 via5_same_array1)  
 via1_same_array_5stackpre2 = drc( via1_same_array_5stackpre1  area >= VIA_A_5 ) 
 via1_same_array2 =  drc( via1_same_array  area >= VIA_A_4 ) 
 via2_same_array2 =  drc( via2_same_array  area >= VIA_A_4 ) 
 via1_same_array21 =  geomAnd(via1_same_array2 via2_same_array2)  
 via3_same_array2 =  drc( via3_same_array  area >= VIA_A_4 ) 
 via1_same_array211 =  geomAnd(via1_same_array21 via3_same_array2)  
 via4_same_array2 =  drc( via4_same_array  area >= VIA_A_4 ) 
 via1_same_array_4stackpre1 = geomAnd(via1_same_array211 via4_same_array2)  
 via1_same_array_4stackpre2 = drc( via1_same_array_4stackpre1  area >= VIA_A_4 ) 
 via2_same_array3 =  drc( via2_same_array  area >= VIA_A_4 ) 
 via3_same_array3 =  drc( via3_same_array  area >= VIA_A_4 ) 
 via2_same_array31 =  geomAnd(via2_same_array3 via3_same_array3)  
 via4_same_array3 =  drc( via4_same_array  area >= VIA_A_4 ) 
 via2_same_array311 =  geomAnd(via2_same_array31 via4_same_array3)  
 via5_same_array2 =  drc( via5_same_array  area >= VIA_A_4 ) 
 via2_same_array_4stackpre1 = geomAnd(via2_same_array311 via5_same_array2)  
 via2_same_array_4stackpre2 = drc( via2_same_array_4stackpre1  area >= VIA_A_4 ) 
 via1_same_array3 =  drc( via1_same_array  area >= VIA_A_3 ) 
 via2_same_array4 =  drc( via2_same_array  area >= VIA_A_3 ) 
 via1_same_array31 =  geomAnd(via1_same_array3 via2_same_array4)  
 via3_same_array4 =  drc( via3_same_array  area >= VIA_A_3 ) 
 via1_same_array_3stackpre1 = geomAnd(via1_same_array31 via3_same_array4)  
 via1_same_array_3stackpre2 = drc( via1_same_array_3stackpre1  area >= VIA_A_3 ) 
 via2_same_array5 =  drc( via2_same_array  area >= VIA_A_3 ) 
 via3_same_array5 =  drc( via3_same_array  area >= VIA_A_3 ) 
 via2_same_array51 =  geomAnd(via2_same_array5 via3_same_array5)  
 via4_same_array4 =  drc( via4_same_array  area >= VIA_A_3 ) 
 via2_same_array_3stackpre1 = geomAnd(via2_same_array51 via4_same_array4)  
 via2_same_array_3stackpre2 = drc( via2_same_array_3stackpre1  area >= VIA_A_3 ) 
 via3_same_array6 =  drc( via3_same_array  area >= VIA_A_3 ) 
 via4_same_array5 =  drc( via4_same_array  area >= VIA_A_3 ) 
 via3_same_array61 =  geomAnd(via3_same_array6 via4_same_array5)  
 via5_same_array3 =  drc( via5_same_array  area >= VIA_A_3 ) 
 via3_same_array_3stackpre1 = geomAnd(via3_same_array61 via5_same_array3)  
 via3_same_array_3stackpre2 = drc( via3_same_array_3stackpre1  area >= VIA_A_3 ) 
 via1_same_array4 =  drc( via1_same_array  area >= VIA_A_2 ) 
 via2_same_array6 =  drc( via2_same_array  area >= VIA_A_2 ) 
 via1_same_array_2stackpre1 = geomAnd(via1_same_array4 via2_same_array6)  
 via1_same_array_2stackpre2 = drc( via1_same_array_2stackpre1  area >= VIA_A_2 ) 
 via2_same_array7 =  drc( via2_same_array  area >= VIA_A_2 ) 
 via3_same_array7 =  drc( via3_same_array  area >= VIA_A_2 ) 
 via2_same_array_2stackpre1 = geomAnd(via2_same_array7 via3_same_array7)  
 via2_same_array_2stackpre2 = drc( via2_same_array_2stackpre1  area >= VIA_A_2 ) 
 via3_same_array8 =  drc( via3_same_array  area >= VIA_A_2 ) 
 via4_same_array6 =  drc( via4_same_array  area >= VIA_A_2 ) 
 via3_same_array_2stackpre1 = geomAnd(via3_same_array8 via4_same_array6)  
 via3_same_array_2stackpre2 = drc( via3_same_array_2stackpre1  area >= VIA_A_2 ) 
 via4_same_array7 =  drc( via4_same_array  area >= VIA_A_2 ) 
 via5_same_array4 =  drc( via5_same_array  area >= VIA_A_2 ) 
 via4_same_array_2stackpre1 = geomAnd(via4_same_array7 via5_same_array4)  
 via4_same_array_2stackpre2 = drc( via4_same_array_2stackpre1  area >= VIA_A_2 ) 
/* **********************   */
/*  Small 5 stack array */
/* ********************** */
/*  Processing for SAME Array Size Check     */
/* ************************************** */
 via1_5stackpre3 = geomEncloseRect( via1_same_array_5stackpre2 VIA_W_1 VIA_S_2L )  /*  Find at least one width >= VIA_W_1 */ 
 via1_reg_3_s_5 = drc( via1_5stackpre3   sepNotch <= VIA_S_2  opposite )
 via1_reg_3_s_5_1 = geomEncloseRect( via1_reg_3_s_5 VIA_S_2L 0.005 )  /*  Find parallel run length >= VIA_S_2L */ 
 via1_5stackpre4 = geomButtOrOver( via1_5stackpre3 via1_reg_3_s_5_1  )  /*  Find parallel run length >= VIA_S_2L   */ 
 via1arrays1_s_5 = drc( via1_5stackpre4   sepNotch <= VIA_S_2  opposite )/*  Space of different "smae array" smaller than VIA_S_2 */
 via1arrays1_s_51 =  geomAndNot(via1arrays1_s_5 geomInside(via1arrays1_s_5 m1 ))   
 via1arrays1_s_511 =  geomAndNot(via1arrays1_s_51 geomInside(via1arrays1_s_51 m2 ))   
 via1arrays1_s_5111 =  geomAndNot(via1arrays1_s_511 geomInside(via1arrays1_s_511 m3 ))   
 via1arrays1_s_51111 =  geomAndNot(via1arrays1_s_5111 geomInside(via1arrays1_s_5111 m4 ))   
 via1arrays2_s_5 = geomAndNot(via1arrays1_s_51111 geomInside(via1arrays1_s_51111 m5 ))   
 via1_5stackfinal = geomButtOrOver( via1_5stackpre4 via1arrays2_s_5  )   
 via1_s_5_a1 = geomButtOrOver( via1 via1_5stackfinal  )   
 via1_reg_4_s_5_a1 = drc( via1_s_5_a1   sepNotch < VIA_S_3  )/*  VIA1s space smaller than 0.49 (inside small array)   */
 via1_violate_s_5_a1 = geomButtOrOver( via1_s_5_a1 via1_reg_4_s_5_a1  )   
 via2_s_5_a1 = geomButtOrOver( via2 via1_5stackfinal  )   
 via2_reg_4_s_5_a1 = drc( via2_s_5_a1   sepNotch < VIA_S_3  )/*  VIA2s space smaller than 0.49 (inside small array)   */
 via2_violate_s_5_a1 = geomButtOrOver( via2_s_5_a1 via2_reg_4_s_5_a1  )   
 via3_s_5_a1 = geomButtOrOver( via3 via1_5stackfinal  )   
 via3_reg_4_s_5_a1 = drc( via3_s_5_a1   sepNotch < VIA_S_3  )/*  VIA3s space smaller than 0.49 (inside small array)   */
 via3_violate_s_5_a1 = geomButtOrOver( via3_s_5_a1 via3_reg_4_s_5_a1  )   
 via4_s_5_a1 = geomButtOrOver( via4 via1_5stackfinal  )   
 via4_reg_4_s_5_a1 = drc( via4_s_5_a1   sepNotch < VIA_S_3  )/*  VIA4s space smaller than 0.49 (inside small array)   */
 via4_violate_s_5_a1 = geomButtOrOver( via4_s_5_a1 via4_reg_4_s_5_a1  )   
 via5_s_5_a1 = geomButtOrOver( via5 via1_5stackfinal  )   
 via5_reg_4_s_5_a1 = drc( via5_s_5_a1   sepNotch < VIA_S_3  )/*  VIA5s space smaller than 0.49 (inside small array)   */
 via5_violate_s_5_a1 = geomButtOrOver( via5_s_5_a1 via5_reg_4_s_5_a1  )   
/*  Rule Check     */
/* ************************************** */
geomConnect( incremental
	buttOrOver(via1_5stackfinal via1_violate_s_5_a1)
	buttOrOver(via1_5stackfinal via2_violate_s_5_a1)
	buttOrOver(via1_5stackfinal via3_violate_s_5_a1)
	buttOrOver(via1_5stackfinal via4_violate_s_5_a1)
	buttOrOver(via1_5stackfinal via5_violate_s_5_a1)
)
processAntenna(
	gate((via1_5stackfinal via1_violate_s_5_a1))
        antenna( via1_violate_s_5_a1 )
        ratio = via1_violate_s_5_a1.area/via1_5stackfinal.area
via1s2_array1_2_3_4_5_m_a1 = drcAntenna( via1_violate_s_5_a1 via1_5stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via1s2_array1_2_3_4_5_m_a1 = geomButtOrOver( via1_violate_s_5_a1 via1s2_array1_2_3_4_5_m_a1_via1_5stackfinal)
processAntenna(
	gate((via1_5stackfinal via2_violate_s_5_a1))
        antenna( via2_violate_s_5_a1 )
        ratio = via2_violate_s_5_a1.area/via1_5stackfinal.area
via1s2_array1_2_3_4_5_m1_a2 = drcAntenna( via2_violate_s_5_a1 via1_5stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via1s2_array1_2_3_4_5_m1_a2 = geomButtOrOver( via2_violate_s_5_a1 via1s2_array1_2_3_4_5_m1_a2_via1_5stackfinal)
processAntenna(
	gate((via1_5stackfinal via3_violate_s_5_a1))
        antenna( via3_violate_s_5_a1 )
        ratio = via3_violate_s_5_a1.area/via1_5stackfinal.area
via1s2_array1_2_3_4_5_m2_a3 = drcAntenna( via3_violate_s_5_a1 via1_5stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via1s2_array1_2_3_4_5_m2_a3 = geomButtOrOver( via3_violate_s_5_a1 via1s2_array1_2_3_4_5_m2_a3_via1_5stackfinal)
processAntenna(
	gate((via1_5stackfinal via4_violate_s_5_a1))
        antenna( via4_violate_s_5_a1 )
        ratio = via4_violate_s_5_a1.area/via1_5stackfinal.area
via1s2_array1_2_3_4_5_m3_a4 = drcAntenna( via4_violate_s_5_a1 via1_5stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via1s2_array1_2_3_4_5_m3_a4 = geomButtOrOver( via4_violate_s_5_a1 via1s2_array1_2_3_4_5_m3_a4_via1_5stackfinal)
 a1_or1 =  geomOr(via1s2_array1_2_3_4_5_m_a1 via1s2_array1_2_3_4_5_m1_a2)  
 a1_or1_or1 =  geomOr(a1_or1 via1s2_array1_2_3_4_5_m2_a3)  
 via1s2_array1_2_3_4_5_m4_b1 = geomOr(a1_or1_or1 via1s2_array1_2_3_4_5_m3_a4)  
 errorLayer( geomSize( geomSize( via1s2_array1_2_3_4_5_m4_b1  VIA_Merge ) -VIA_Merge) 
	"VIA1.S.2_Array1_2_3_4_5_M Minimum space between two VIAs in 5-level continuous stacking VIA arrays with below condition. >=0.49um Via1 violate VIA_S_3 spacing in Via1/Via2/Via3/Via4/Via5 array & density large or equal VIA_D_1  ")  
/* **********************   */
/*  Small 4 stack array */
/* ********************** */
/*  Processing for SAME Array Size Check     */
/* ************************************** */
 via1_4stackpre3 = geomEncloseRect( via1_same_array_4stackpre2 VIA_W_1 VIA_S_2L )  /*  Find at least one width >= VIA_W_1 */ 
 via1_reg_3_s_4 = drc( via1_4stackpre3   sepNotch <= VIA_S_2  opposite )
 via1_reg_3_s_4_1 = geomEncloseRect( via1_reg_3_s_4 VIA_S_2L 0.005 )  /*  Find parallel run length >= VIA_S_2L */ 
 via1_4stackpre4 = geomButtOrOver( via1_4stackpre3 via1_reg_3_s_4_1  )   
 via1arrays1_s_4 = drc( via1_4stackpre4   sepNotch <= VIA_S_2  opposite )/*  Space of different "smae array" smaller than VIA_S_2 */
 via1arrays1_s_41 =  geomAndNot(via1arrays1_s_4 geomInside(via1arrays1_s_4 m1 ))   
 via1arrays1_s_411 =  geomAndNot(via1arrays1_s_41 geomInside(via1arrays1_s_41 m2 ))   
 via1arrays1_s_4111 =  geomAndNot(via1arrays1_s_411 geomInside(via1arrays1_s_411 m3 ))   
 via1arrays2_s_4 = geomAndNot(via1arrays1_s_4111 geomInside(via1arrays1_s_4111 m4 ))   
 via1_4stackfinal = geomButtOrOver( via1_4stackpre4 via1arrays2_s_4  )   
 via1_s_4_a1 = geomButtOrOver( via1 via1_4stackfinal  )   
 via1_reg_4_s_4_a1 = drc( via1_s_4_a1   sepNotch < VIA_S_3  )/*  VIA1s space smaller than 0.49 (inside small array)   */
 via1_violate_s_4_a1 = geomButtOrOver( via1_s_4_a1 via1_reg_4_s_4_a1  )   
 via2_s_4_a1 = geomButtOrOver( via2 via1_4stackfinal  )   
 via2_reg_4_s_4_a1 = drc( via2_s_4_a1   sepNotch < VIA_S_3  )/*  VIA2s space smaller than 0.49 (inside small array)   */
 via2_violate_s_4_a1 = geomButtOrOver( via2_s_4_a1 via2_reg_4_s_4_a1  )   
 via3_s_4_a1 = geomButtOrOver( via3 via1_4stackfinal  )   
 via3_reg_4_s_4_a1 = drc( via3_s_4_a1   sepNotch < VIA_S_3  )/*  VIA3s space smaller than 0.49 (inside small array)   */
 via3_violate_s_4_a1 = geomButtOrOver( via3_s_4_a1 via3_reg_4_s_4_a1  )   
 via4_s_4_a1 = geomButtOrOver( via4 via1_4stackfinal  )   
 via4_reg_4_s_4_a1 = drc( via4_s_4_a1   sepNotch < VIA_S_3  )/*  VIA4s space smaller than 0.49 (inside small array)   */
 via4_violate_s_4_a1 = geomButtOrOver( via4_s_4_a1 via4_reg_4_s_4_a1  )   
 via2_4stackpre3 = geomEncloseRect( via2_same_array_4stackpre2 VIA_W_1 VIA_S_2L )  /*  Find at least one width >= VIA_W_1 */ 
 via2_reg_3_s_4 = drc( via2_4stackpre3   sepNotch <= VIA_S_2  opposite )
 via2_reg_3_s_4_1 = geomEncloseRect( via2_reg_3_s_4 VIA_S_2L 0.005 )  /*  Find parallel run length >= VIA_S_2L */ 
 via2_4stackpre4 = geomButtOrOver( via2_4stackpre3 via2_reg_3_s_4_1  )   
 via2arrays1_s_4 = drc( via2_4stackpre4   sepNotch <= VIA_S_2  opposite )/*  Space of different "smae array" smaller than VIA_S_2 */
 via2arrays1_s_41 =  geomAndNot(via2arrays1_s_4 geomInside(via2arrays1_s_4 m2 ))   
 via2arrays1_s_411 =  geomAndNot(via2arrays1_s_41 geomInside(via2arrays1_s_41 m3 ))   
 via2arrays1_s_4111 =  geomAndNot(via2arrays1_s_411 geomInside(via2arrays1_s_411 m4 ))   
 via2arrays2_s_4 = geomAndNot(via2arrays1_s_4111 geomInside(via2arrays1_s_4111 m5 ))   
 via2_4stackfinal = geomButtOrOver( via2_4stackpre4 via2arrays2_s_4  )   
 via2_s_4_a2 = geomButtOrOver( via2 via2_4stackfinal  )   
 via2_reg_4_s_4_a2 = drc( via2_s_4_a2   sepNotch < VIA_S_3  )/*  VIA2s space smaller than 0.49 (inside small array)   */
 via2_violate_s_4_a2 = geomButtOrOver( via2_s_4_a2 via2_reg_4_s_4_a2  )   
 via3_s_4_a2 = geomButtOrOver( via3 via2_4stackfinal  )   
 via3_reg_4_s_4_a2 = drc( via3_s_4_a2   sepNotch < VIA_S_3  )/*  VIA3s space smaller than 0.49 (inside small array)   */
 via3_violate_s_4_a2 = geomButtOrOver( via3_s_4_a2 via3_reg_4_s_4_a2  )   
 via4_s_4_a2 = geomButtOrOver( via4 via2_4stackfinal  )   
 via4_reg_4_s_4_a2 = drc( via4_s_4_a2   sepNotch < VIA_S_3  )/*  VIA4s space smaller than 0.49 (inside small array)   */
 via4_violate_s_4_a2 = geomButtOrOver( via4_s_4_a2 via4_reg_4_s_4_a2  )   
 via5_s_4_a2 = geomButtOrOver( via5 via2_4stackfinal  )   
 via5_reg_4_s_4_a2 = drc( via5_s_4_a2   sepNotch < VIA_S_3  )/*  VIA5s space smaller than 0.49 (inside small array)   */
 via5_violate_s_4_a2 = geomButtOrOver( via5_s_4_a2 via5_reg_4_s_4_a2  )   
/*  Rule Check     */
/* ************************************** */
geomConnect( incremental
	buttOrOver(via1_4stackfinal via1_violate_s_4_a1)
	buttOrOver(via1_4stackfinal via2_violate_s_4_a1)
	buttOrOver(via1_4stackfinal via3_violate_s_4_a1)
	buttOrOver(via1_4stackfinal via4_violate_s_4_a1)
	buttOrOver(via2_4stackfinal via2_violate_s_4_a2)
	buttOrOver(via2_4stackfinal via3_violate_s_4_a2)
	buttOrOver(via2_4stackfinal via4_violate_s_4_a2)
	buttOrOver(via2_4stackfinal via5_violate_s_4_a2)
)
processAntenna(
	gate((via1_4stackfinal via1_violate_s_4_a1))
        antenna( via1_violate_s_4_a1 )
        ratio = via1_violate_s_4_a1.area/via1_4stackfinal.area
via1s3_array1_2_3_4_m_a1 = drcAntenna( via1_violate_s_4_a1 via1_4stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via1s3_array1_2_3_4_m_a1 = geomButtOrOver( via1_violate_s_4_a1 via1s3_array1_2_3_4_m_a1_via1_4stackfinal)
processAntenna(
	gate((via1_4stackfinal via2_violate_s_4_a1))
        antenna( via2_violate_s_4_a1 )
        ratio = via2_violate_s_4_a1.area/via1_4stackfinal.area
via1s3_array1_2_3_4_m1_a2 = drcAntenna( via2_violate_s_4_a1 via1_4stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via1s3_array1_2_3_4_m1_a2 = geomButtOrOver( via2_violate_s_4_a1 via1s3_array1_2_3_4_m1_a2_via1_4stackfinal)
processAntenna(
	gate((via1_4stackfinal via3_violate_s_4_a1))
        antenna( via3_violate_s_4_a1 )
        ratio = via3_violate_s_4_a1.area/via1_4stackfinal.area
via1s3_array1_2_3_4_m2_a3 = drcAntenna( via3_violate_s_4_a1 via1_4stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via1s3_array1_2_3_4_m2_a3 = geomButtOrOver( via3_violate_s_4_a1 via1s3_array1_2_3_4_m2_a3_via1_4stackfinal)
processAntenna(
	gate((via1_4stackfinal via4_violate_s_4_a1))
        antenna( via4_violate_s_4_a1 )
        ratio = via4_violate_s_4_a1.area/via1_4stackfinal.area
via1s3_array1_2_3_4_m3_a4 = drcAntenna( via4_violate_s_4_a1 via1_4stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via1s3_array1_2_3_4_m3_a4 = geomButtOrOver( via4_violate_s_4_a1 via1s3_array1_2_3_4_m3_a4_via1_4stackfinal)
 a1_or2 =  geomOr(via1s3_array1_2_3_4_m_a1 via1s3_array1_2_3_4_m1_a2)  
 a1_or2_or1 =  geomOr(a1_or2 via1s3_array1_2_3_4_m2_a3)  
 via1s3_array1_2_3_4_m4_b1 = geomOr(a1_or2_or1 via1s3_array1_2_3_4_m3_a4)  
 errorLayer( geomSize( geomSize( via1s3_array1_2_3_4_m4_b1  VIA_Merge ) -VIA_Merge) 
	"VIA1.S.3_Array1_2_3_4_M  Minimum space between two VIAs in 4-level continuous stacking VIA arrays with below condition >=0.49um Via1 violate VIA_S_3 spacing in Via1/Via2/Via3/Via4 array & density large or equal VIA_D_1  ")  
processAntenna(
	gate((via2_4stackfinal via2_violate_s_4_a2))
        antenna( via2_violate_s_4_a2 )
        ratio = via2_violate_s_4_a2.area/via2_4stackfinal.area
via2s3_array2_3_4_5_m_a2 = drcAntenna( via2_violate_s_4_a2 via2_4stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via2s3_array2_3_4_5_m_a2 = geomButtOrOver( via2_violate_s_4_a2 via2s3_array2_3_4_5_m_a2_via2_4stackfinal)
processAntenna(
	gate((via2_4stackfinal via3_violate_s_4_a2))
        antenna( via3_violate_s_4_a2 )
        ratio = via3_violate_s_4_a2.area/via2_4stackfinal.area
via2s3_array2_3_4_5_m1_a3 = drcAntenna( via3_violate_s_4_a2 via2_4stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via2s3_array2_3_4_5_m1_a3 = geomButtOrOver( via3_violate_s_4_a2 via2s3_array2_3_4_5_m1_a3_via2_4stackfinal)
processAntenna(
	gate((via2_4stackfinal via4_violate_s_4_a2))
        antenna( via4_violate_s_4_a2 )
        ratio = via4_violate_s_4_a2.area/via2_4stackfinal.area
via2s3_array2_3_4_5_m2_a4 = drcAntenna( via4_violate_s_4_a2 via2_4stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via2s3_array2_3_4_5_m2_a4 = geomButtOrOver( via4_violate_s_4_a2 via2s3_array2_3_4_5_m2_a4_via2_4stackfinal)
 a2_or1 =  geomOr(via2s3_array2_3_4_5_m_a2 via2s3_array2_3_4_5_m1_a3)  
 via2s3_array2_3_4_5_m3_b2 = geomOr(a2_or1 via2s3_array2_3_4_5_m2_a4)  
 errorLayer( geomSize( geomSize( via2s3_array2_3_4_5_m3_b2  VIA_Merge ) -VIA_Merge) 
	"VIA2.S.3_Array2_3_4_5_M  Minimum space between two VIAs in 4-level continuous stacking VIA arrays with below condition >=0.49um Via2 violate VIA_S_3 spacing in Via2/Via3/Via4/Via5 array & density large or equal VIA_D_1  ")  
/* **********************   */
/*  Small 3 stack array */
/* ********************** */
/*  Processing for SAME Array Size Check     */
/* ************************************** */
 via1_3stackpre3 = geomEncloseRect( via1_same_array_3stackpre2 VIA_W_1 VIA_S_2L )  /*  Find at least one width >=VIA_W_1 */ 
 via1_reg_3_s_3 = drc( via1_3stackpre3   sepNotch <= VIA_S_2  opposite )
 via1_reg_3_s_3_1 = geomEncloseRect( via1_reg_3_s_3 VIA_S_2L 0.005 )  /*  Find parallel run length >= VIA_S_2L */ 
 via1_3stackpre4 = geomButtOrOver( via1_3stackpre3 via1_reg_3_s_3_1  )  /*  Find parallel run length >= VIA_S_2L */ 
 via1arrays1_s_3 = drc( via1_3stackpre4   sepNotch <= VIA_S_2  opposite )/*  Space of different "smae array" smaller than VIA_S_2 */
 via1arrays1_s_31 =  geomAndNot(via1arrays1_s_3 geomInside(via1arrays1_s_3 m1 ))   
 via1arrays1_s_311 =  geomAndNot(via1arrays1_s_31 geomInside(via1arrays1_s_31 m2 ))   
 via1arrays2_s_3 = geomAndNot(via1arrays1_s_311 geomInside(via1arrays1_s_311 m3 ))   
 via1_3stackfinal = geomButtOrOver( via1_3stackpre4 via1arrays2_s_3  )   
 via1_s_3_a1 = geomButtOrOver( via1 via1_3stackfinal  )   
 via1_reg_4_s_3_a1 = drc( via1_s_3_a1   sepNotch < VIA_S_3  )/*  VIA1s space smaller than 0.49 (inside small array)   */
 via1_violate_s_3_a1 = geomButtOrOver( via1_s_3_a1 via1_reg_4_s_3_a1  )   
 via2_s_3_a1 = geomButtOrOver( via2 via1_3stackfinal  )   
 via2_reg_4_s_3_a1 = drc( via2_s_3_a1   sepNotch < VIA_S_3  )/*  VIA2s space smaller than 0.49 (inside small array)   */
 via2_violate_s_3_a1 = geomButtOrOver( via2_s_3_a1 via2_reg_4_s_3_a1  )   
 via3_s_3_a1 = geomButtOrOver( via3 via1_3stackfinal  )   
 via3_reg_4_s_3_a1 = drc( via3_s_3_a1   sepNotch < VIA_S_3  )/*  VIA3s space smaller than 0.49 (inside small array)   */
 via3_violate_s_3_a1 = geomButtOrOver( via3_s_3_a1 via3_reg_4_s_3_a1  )   
 via2_3stackpre3 = geomEncloseRect( via2_same_array_3stackpre2 VIA_W_1 VIA_S_2L )  /*  Find at least one width >=VIA_W_1 */ 
 via2_reg_3_s_3 = drc( via2_3stackpre3   sepNotch <= VIA_S_2  opposite )
 via2_reg_3_s_3_1 = geomEncloseRect( via2_reg_3_s_3 VIA_S_2L 0.005 )  /*  Find parallel run length >= VIA_S_2L */ 
 via2_3stackpre4 = geomButtOrOver( via2_3stackpre3 via2_reg_3_s_3_1  )  /*  Find parallel run length >= VIA_S_2L */ 
 via2arrays1_s_3 = drc( via2_3stackpre4   sepNotch <= VIA_S_2  opposite )/*  Space of different "smae array" smaller than VIA_S_2 */
 via2arrays1_s_31 =  geomAndNot(via2arrays1_s_3 geomInside(via2arrays1_s_3 m2 ))   
 via2arrays1_s_311 =  geomAndNot(via2arrays1_s_31 geomInside(via2arrays1_s_31 m3 ))   
 via2arrays2_s_3 = geomAndNot(via2arrays1_s_311 geomInside(via2arrays1_s_311 m4 ))   
 via2_3stackfinal = geomButtOrOver( via2_3stackpre4 via2arrays2_s_3  )   
 via2_s_3_a2 = geomButtOrOver( via2 via2_3stackfinal  )   
 via2_reg_4_s_3_a2 = drc( via2_s_3_a2   sepNotch < VIA_S_3  )/*  VIA2s space smaller than 0.49 (inside small array)   */
 via2_violate_s_3_a2 = geomButtOrOver( via2_s_3_a2 via2_reg_4_s_3_a2  )   
 via3_s_3_a2 = geomButtOrOver( via3 via2_3stackfinal  )   
 via3_reg_4_s_3_a2 = drc( via3_s_3_a2   sepNotch < VIA_S_3  )/*  VIA3s space smaller than 0.49 (inside small array)   */
 via3_violate_s_3_a2 = geomButtOrOver( via3_s_3_a2 via3_reg_4_s_3_a2  )   
 via4_s_3_a2 = geomButtOrOver( via4 via2_3stackfinal  )   
 via4_reg_4_s_3_a2 = drc( via4_s_3_a2   sepNotch < VIA_S_3  )/*  VIA4s space smaller than 0.49 (inside small array)   */
 via4_violate_s_3_a2 = geomButtOrOver( via4_s_3_a2 via4_reg_4_s_3_a2  )   
 via3_3stackpre3 = geomEncloseRect( via3_same_array_3stackpre2 VIA_W_1 VIA_S_2L )  /*  Find at least one width >=VIA_W_1 */ 
 via3_reg_3_s_3 = drc( via3_3stackpre3   sepNotch <= VIA_S_2  opposite )
 via3_reg_3_s_3_1 = geomEncloseRect( via3_reg_3_s_3 VIA_S_2L 0.005 )  /*  Find parallel run length >= VIA_S_2L */ 
 via3_3stackpre4 = geomButtOrOver( via3_3stackpre3 via3_reg_3_s_3_1  )  /*  Find parallel run length >= VIA_S_2L */ 
 via3arrays1_s_3 = drc( via3_3stackpre4   sepNotch <= VIA_S_2  opposite )/*  Space of different "smae array" smaller than VIA_S_2 */
 via3arrays1_s_31 =  geomAndNot(via3arrays1_s_3 geomInside(via3arrays1_s_3 m3 ))   
 via3arrays1_s_311 =  geomAndNot(via3arrays1_s_31 geomInside(via3arrays1_s_31 m4 ))   
 via3arrays2_s_3 = geomAndNot(via3arrays1_s_311 geomInside(via3arrays1_s_311 m5 ))   
 via3_3stackfinal = geomButtOrOver( via3_3stackpre4 via3arrays2_s_3  )   
 via3_s_3_a3 = geomButtOrOver( via3 via3_3stackfinal  )   
 via3_reg_4_s_3_a3 = drc( via3_s_3_a3   sepNotch < VIA_S_3  )/*  VIA3s space smaller than 0.49 (inside small array)   */
 via3_violate_s_3_a3 = geomButtOrOver( via3_s_3_a3 via3_reg_4_s_3_a3  )   
 via4_s_3_a3 = geomButtOrOver( via4 via3_3stackfinal  )   
 via4_reg_4_s_3_a3 = drc( via4_s_3_a3   sepNotch < VIA_S_3  )/*  VIA4s space smaller than 0.49 (inside small array)   */
 via4_violate_s_3_a3 = geomButtOrOver( via4_s_3_a3 via4_reg_4_s_3_a3  )   
 via5_s_3_a3 = geomButtOrOver( via5 via3_3stackfinal  )   
 via5_reg_4_s_3_a3 = drc( via5_s_3_a3   sepNotch < VIA_S_3  )/*  VIA5s space smaller than 0.49 (inside small array)   */
 via5_violate_s_3_a3 = geomButtOrOver( via5_s_3_a3 via5_reg_4_s_3_a3  )   
/*  Rule Check     */
/* ************************************** */
geomConnect( incremental
	buttOrOver(via1_3stackfinal via1_violate_s_3_a1)
	buttOrOver(via1_3stackfinal via2_violate_s_3_a1)
	buttOrOver(via1_3stackfinal via3_violate_s_3_a1)
	buttOrOver(via2_3stackfinal via2_violate_s_3_a2)
	buttOrOver(via2_3stackfinal via3_violate_s_3_a2)
	buttOrOver(via2_3stackfinal via4_violate_s_3_a2)
	buttOrOver(via3_3stackfinal via3_violate_s_3_a3)
	buttOrOver(via3_3stackfinal via4_violate_s_3_a3)
	buttOrOver(via3_3stackfinal via5_violate_s_3_a3)
)
processAntenna(
	gate((via1_3stackfinal via1_violate_s_3_a1))
        antenna( via1_violate_s_3_a1 )
        ratio = via1_violate_s_3_a1.area/via1_3stackfinal.area
via1s4_array1_2_3_m_a1 = drcAntenna( via1_violate_s_3_a1 via1_3stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via1s4_array1_2_3_m_a1 = geomButtOrOver( via1_violate_s_3_a1 via1s4_array1_2_3_m_a1_via1_3stackfinal)
processAntenna(
	gate((via1_3stackfinal via2_violate_s_3_a1))
        antenna( via2_violate_s_3_a1 )
        ratio = via2_violate_s_3_a1.area/via1_3stackfinal.area
via1s4_array1_2_3_m1_a2 = drcAntenna( via2_violate_s_3_a1 via1_3stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via1s4_array1_2_3_m1_a2 = geomButtOrOver( via2_violate_s_3_a1 via1s4_array1_2_3_m1_a2_via1_3stackfinal)
processAntenna(
	gate((via1_3stackfinal via3_violate_s_3_a1))
        antenna( via3_violate_s_3_a1 )
        ratio = via3_violate_s_3_a1.area/via1_3stackfinal.area
via1s4_array1_2_3_m2_a3 = drcAntenna( via3_violate_s_3_a1 via1_3stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via1s4_array1_2_3_m2_a3 = geomButtOrOver( via3_violate_s_3_a1 via1s4_array1_2_3_m2_a3_via1_3stackfinal)
 a1_or3 =  geomOr(via1s4_array1_2_3_m_a1 via1s4_array1_2_3_m1_a2)  
 via1s4_array1_2_3_m3_b1 = geomOr(a1_or3 via1s4_array1_2_3_m2_a3)  
 errorLayer( geomSize( geomSize( via1s4_array1_2_3_m3_b1  VIA_Merge ) -VIA_Merge) 
	"VIA1.S.4_Array1_2_3_M  Minimum space between two VIAs in 3-level continuous stacking VIA arrays with below condition >=0.49um Via1 violate VIA_S_3 spacing in Via1/Via2/Via3 array & density large or equal VIA_D_1  ")  
processAntenna(
	gate((via2_3stackfinal via2_violate_s_3_a2))
        antenna( via2_violate_s_3_a2 )
        ratio = via2_violate_s_3_a2.area/via2_3stackfinal.area
via2s4_array2_3_4_m_a2 = drcAntenna( via2_violate_s_3_a2 via2_3stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via2s4_array2_3_4_m_a2 = geomButtOrOver( via2_violate_s_3_a2 via2s4_array2_3_4_m_a2_via2_3stackfinal)
processAntenna(
	gate((via2_3stackfinal via3_violate_s_3_a2))
        antenna( via3_violate_s_3_a2 )
        ratio = via3_violate_s_3_a2.area/via2_3stackfinal.area
via2s4_array2_3_4_m1_a3 = drcAntenna( via3_violate_s_3_a2 via2_3stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via2s4_array2_3_4_m1_a3 = geomButtOrOver( via3_violate_s_3_a2 via2s4_array2_3_4_m1_a3_via2_3stackfinal)
processAntenna(
	gate((via2_3stackfinal via4_violate_s_3_a2))
        antenna( via4_violate_s_3_a2 )
        ratio = via4_violate_s_3_a2.area/via2_3stackfinal.area
via2s4_array2_3_4_m2_a4 = drcAntenna( via4_violate_s_3_a2 via2_3stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via2s4_array2_3_4_m2_a4 = geomButtOrOver( via4_violate_s_3_a2 via2s4_array2_3_4_m2_a4_via2_3stackfinal)
 a2_or2 =  geomOr(via2s4_array2_3_4_m_a2 via2s4_array2_3_4_m1_a3)  
 via2s4_array2_3_4_m3_b2 = geomOr(a2_or2 via2s4_array2_3_4_m2_a4)  
 errorLayer( geomSize( geomSize( via2s4_array2_3_4_m3_b2  VIA_Merge ) -VIA_Merge) 
	"VIA2.S.4_Array2_3_4_M  Minimum space between two VIAs in 3-level continuous stacking VIA arrays with below condition >=0.49um Via2 violate VIA_S_3 spacing in Via2/Via3/Via4 array & density large or equal VIA_D_1  ")  
processAntenna(
	gate((via3_3stackfinal via3_violate_s_3_a3))
        antenna( via3_violate_s_3_a3 )
        ratio = via3_violate_s_3_a3.area/via3_3stackfinal.area
via3s4_array3_4_5_m_a3 = drcAntenna( via3_violate_s_3_a3 via3_3stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via3s4_array3_4_5_m_a3 = geomButtOrOver( via3_violate_s_3_a3 via3s4_array3_4_5_m_a3_via3_3stackfinal)
processAntenna(
	gate((via3_3stackfinal via4_violate_s_3_a3))
        antenna( via4_violate_s_3_a3 )
        ratio = via4_violate_s_3_a3.area/via3_3stackfinal.area
via3s4_array3_4_5_m1_a4 = drcAntenna( via4_violate_s_3_a3 via3_3stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via3s4_array3_4_5_m1_a4 = geomButtOrOver( via4_violate_s_3_a3 via3s4_array3_4_5_m1_a4_via3_3stackfinal)
 via3s4_array3_4_5_m2_b3 = geomOr(via3s4_array3_4_5_m_a3 via3s4_array3_4_5_m1_a4)  
 errorLayer( geomSize( geomSize( via3s4_array3_4_5_m2_b3  VIA_Merge ) -VIA_Merge) 
	"VIA3.S.4_Array3_4_5_M  Minimum space between two VIAs in 3-level continuous stacking VIA arrays with below condition >=0.49um Via3 violate VIA_S_3 spacing in Via3/Via4/Via5 array & density large or equal VIA_D_1  ")  
/* **********************   */
/*  Small 2 stack array */
/* ********************** */
/*  Processing for SAME Array Size Check     */
/* ************************************** */
 via1_2stackpre3 = geomEncloseRect( via1_same_array_2stackpre2 VIA_W_1 VIA_S_2L )  /*  Find at least one width >= VIA_W_1 */ 
 via1_reg_3_s_2 = drc( via1_2stackpre3   sepNotch <= VIA_S_2  opposite )
 via1_reg_3_s_2_1 = geomEncloseRect( via1_reg_3_s_2 VIA_S_2L 0.005 )  /*  Find parallel run length >= VIA_S_2L  */ 
 via1_2stackpre4 = geomButtOrOver( via1_2stackpre3 via1_reg_3_s_2_1  )  /*  Find parallel run length >= VIA_S_2L */ 
 via1arrays1_s_2 = drc( via1_2stackpre4   sepNotch <= VIA_S_2  opposite )/*  Space of different "smae array" smaller than >= VIA_S_2 */
 via1arrays1_s_21 =  geomAndNot(via1arrays1_s_2 geomInside(via1arrays1_s_2 m1 ))   
 via1arrays2_s_2 = geomAndNot(via1arrays1_s_21 geomInside(via1arrays1_s_21 m2 ))   
 via1_2stackfinal = geomButtOrOver( via1_2stackpre4 via1arrays2_s_2  )   
 via1_s_2_a1 = geomButtOrOver( via1 via1_2stackfinal  )   
 via1_reg_4_s_2_a1 = drc( via1_s_2_a1   sepNotch < VIA_S_3  )/*  VIA1s space smaller than 0.49 (inside small array)   */
 via1_violate_s_2_a1 = geomButtOrOver( via1_s_2_a1 via1_reg_4_s_2_a1  )   
 via2_s_2_a1 = geomButtOrOver( via2 via1_2stackfinal  )   
 via2_reg_4_s_2_a1 = drc( via2_s_2_a1   sepNotch < VIA_S_3  )/*  VIA2s space smaller than 0.49 (inside small array)   */
 via2_violate_s_2_a1 = geomButtOrOver( via2_s_2_a1 via2_reg_4_s_2_a1  )   
 via2_2stackpre3 = geomEncloseRect( via2_same_array_2stackpre2 VIA_W_1 VIA_S_2L )  /*  Find at least one width >= VIA_W_1 */ 
 via2_reg_3_s_2 = drc( via2_2stackpre3   sepNotch <= VIA_S_2  opposite )
 via2_reg_3_s_2_1 = geomEncloseRect( via2_reg_3_s_2 VIA_S_2L 0.005 )  /*  Find parallel run length >= VIA_S_2L  */ 
 via2_2stackpre4 = geomButtOrOver( via2_2stackpre3 via2_reg_3_s_2_1  )  /*  Find parallel run length >= VIA_S_2L */ 
 via2arrays1_s_2 = drc( via2_2stackpre4   sepNotch <= VIA_S_2  opposite )/*  Space of different "smae array" smaller than >= VIA_S_2 */
 via2arrays1_s_21 =  geomAndNot(via2arrays1_s_2 geomInside(via2arrays1_s_2 m2 ))   
 via2arrays2_s_2 = geomAndNot(via2arrays1_s_21 geomInside(via2arrays1_s_21 m3 ))   
 via2_2stackfinal = geomButtOrOver( via2_2stackpre4 via2arrays2_s_2  )   
 via2_s_2_a2 = geomButtOrOver( via2 via2_2stackfinal  )   
 via2_reg_4_s_2_a2 = drc( via2_s_2_a2   sepNotch < VIA_S_3  )/*  VIA2s space smaller than 0.49 (inside small array)   */
 via2_violate_s_2_a2 = geomButtOrOver( via2_s_2_a2 via2_reg_4_s_2_a2  )   
 via3_s_2_a2 = geomButtOrOver( via3 via2_2stackfinal  )   
 via3_reg_4_s_2_a2 = drc( via3_s_2_a2   sepNotch < VIA_S_3  )/*  VIA3s space smaller than 0.49 (inside small array)   */
 via3_violate_s_2_a2 = geomButtOrOver( via3_s_2_a2 via3_reg_4_s_2_a2  )   
 via3_2stackpre3 = geomEncloseRect( via3_same_array_2stackpre2 VIA_W_1 VIA_S_2L )  /*  Find at least one width >= VIA_W_1 */ 
 via3_reg_3_s_2 = drc( via3_2stackpre3   sepNotch <= VIA_S_2  opposite )
 via3_reg_3_s_2_1 = geomEncloseRect( via3_reg_3_s_2 VIA_S_2L 0.005 )  /*  Find parallel run length >= VIA_S_2L  */ 
 via3_2stackpre4 = geomButtOrOver( via3_2stackpre3 via3_reg_3_s_2_1  )  /*  Find parallel run length >= VIA_S_2L */ 
 via3arrays1_s_2 = drc( via3_2stackpre4   sepNotch <= VIA_S_2  opposite )/*  Space of different "smae array" smaller than >= VIA_S_2 */
 via3arrays1_s_21 =  geomAndNot(via3arrays1_s_2 geomInside(via3arrays1_s_2 m3 ))   
 via3arrays2_s_2 = geomAndNot(via3arrays1_s_21 geomInside(via3arrays1_s_21 m4 ))   
 via3_2stackfinal = geomButtOrOver( via3_2stackpre4 via3arrays2_s_2  )   
 via3_s_2_a3 = geomButtOrOver( via3 via3_2stackfinal  )   
 via3_reg_4_s_2_a3 = drc( via3_s_2_a3   sepNotch < VIA_S_3  )/*  VIA3s space smaller than 0.49 (inside small array)   */
 via3_violate_s_2_a3 = geomButtOrOver( via3_s_2_a3 via3_reg_4_s_2_a3  )   
 via4_s_2_a3 = geomButtOrOver( via4 via3_2stackfinal  )   
 via4_reg_4_s_2_a3 = drc( via4_s_2_a3   sepNotch < VIA_S_3  )/*  VIA4s space smaller than 0.49 (inside small array)   */
 via4_violate_s_2_a3 = geomButtOrOver( via4_s_2_a3 via4_reg_4_s_2_a3  )   
 via4_2stackpre3 = geomEncloseRect( via4_same_array_2stackpre2 VIA_W_1 VIA_S_2L )  /*  Find at least one width >= VIA_W_1 */ 
 via4_reg_3_s_2 = drc( via4_2stackpre3   sepNotch <= VIA_S_2  opposite )
 via4_reg_3_s_2_1 = geomEncloseRect( via4_reg_3_s_2 VIA_S_2L 0.005 )  /*  Find parallel run length >= VIA_S_2L  */ 
 via4_2stackpre4 = geomButtOrOver( via4_2stackpre3 via4_reg_3_s_2_1  )  /*  Find parallel run length >= VIA_S_2L */ 
 via4arrays1_s_2 = drc( via4_2stackpre4   sepNotch <= VIA_S_2  opposite )/*  Space of different "smae array" smaller than >= VIA_S_2 */
 via4arrays1_s_21 =  geomAndNot(via4arrays1_s_2 geomInside(via4arrays1_s_2 m4 ))   
 via4arrays2_s_2 = geomAndNot(via4arrays1_s_21 geomInside(via4arrays1_s_21 m5 ))   
 via4_2stackfinal = geomButtOrOver( via4_2stackpre4 via4arrays2_s_2  )   
 via4_s_2_a4 = geomButtOrOver( via4 via4_2stackfinal  )   
 via4_reg_4_s_2_a4 = drc( via4_s_2_a4   sepNotch < VIA_S_3  )/*  VIA4s space smaller than 0.49 (inside small array)   */
 via4_violate_s_2_a4 = geomButtOrOver( via4_s_2_a4 via4_reg_4_s_2_a4  )   
 via5_s_2_a4 = geomButtOrOver( via5 via4_2stackfinal  )   
 via5_reg_4_s_2_a4 = drc( via5_s_2_a4   sepNotch < VIA_S_3  )/*  VIA5s space smaller than 0.49 (inside small array)   */
 via5_violate_s_2_a4 = geomButtOrOver( via5_s_2_a4 via5_reg_4_s_2_a4  )   
/*  Rule Check     */
/* ************************************** */
geomConnect( incremental
	buttOrOver(via1_2stackfinal via1_violate_s_2_a1)
	buttOrOver(via1_2stackfinal via2_violate_s_2_a1)
	buttOrOver(via2_2stackfinal via2_violate_s_2_a2)
	buttOrOver(via2_2stackfinal via3_violate_s_2_a2)
	buttOrOver(via3_2stackfinal via3_violate_s_2_a3)
	buttOrOver(via3_2stackfinal via4_violate_s_2_a3)
	buttOrOver(via4_2stackfinal via4_violate_s_2_a4)
	buttOrOver(via4_2stackfinal via5_violate_s_2_a4)
)
processAntenna(
	gate((via1_2stackfinal via1_violate_s_2_a1))
        antenna( via1_violate_s_2_a1 )
        ratio = via1_violate_s_2_a1.area/via1_2stackfinal.area
via1s5_array1_2_m_a1 = drcAntenna( via1_violate_s_2_a1 via1_2stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via1s5_array1_2_m_a1 = geomButtOrOver( via1_violate_s_2_a1 via1s5_array1_2_m_a1_via1_2stackfinal)
processAntenna(
	gate((via1_2stackfinal via2_violate_s_2_a1))
        antenna( via2_violate_s_2_a1 )
        ratio = via2_violate_s_2_a1.area/via1_2stackfinal.area
via1s5_array1_2_m1_a2 = drcAntenna( via2_violate_s_2_a1 via1_2stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via1s5_array1_2_m1_a2 = geomButtOrOver( via2_violate_s_2_a1 via1s5_array1_2_m1_a2_via1_2stackfinal)
 via1s5_array1_2_m2_b1 = geomOr(via1s5_array1_2_m_a1 via1s5_array1_2_m1_a2)  
 errorLayer( geomSize( geomSize( via1s5_array1_2_m2_b1  VIA_Merge ) -VIA_Merge) 
	"VIA1.S.5_Array1_2_M  Minimum space between two VIAs in 2-level continuous stacking VIA arrays with below condition >=0.49um Via1 violate VIA_S_3 spacing in Via1/Via2 array & density large or equal VIA_D_1  ")  
processAntenna(
	gate((via2_2stackfinal via2_violate_s_2_a2))
        antenna( via2_violate_s_2_a2 )
        ratio = via2_violate_s_2_a2.area/via2_2stackfinal.area
via2s5_array2_3_m_a2 = drcAntenna( via2_violate_s_2_a2 via2_2stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via2s5_array2_3_m_a2 = geomButtOrOver( via2_violate_s_2_a2 via2s5_array2_3_m_a2_via2_2stackfinal)
processAntenna(
	gate((via2_2stackfinal via3_violate_s_2_a2))
        antenna( via3_violate_s_2_a2 )
        ratio = via3_violate_s_2_a2.area/via2_2stackfinal.area
via2s5_array2_3_m1_a3 = drcAntenna( via3_violate_s_2_a2 via2_2stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via2s5_array2_3_m1_a3 = geomButtOrOver( via3_violate_s_2_a2 via2s5_array2_3_m1_a3_via2_2stackfinal)
 via2s5_array2_3_m2_b2 = geomOr(via2s5_array2_3_m_a2 via2s5_array2_3_m1_a3)  
 errorLayer( geomSize( geomSize( via2s5_array2_3_m2_b2  VIA_Merge ) -VIA_Merge) 
	"VIA2.S.5_Array2_3_M  Minimum space between two VIAs in 2-level continuous stacking VIA arrays with below condition >=0.49um Via2 violate VIA_S_3 spacing in Via2/Via3 array & density large or equal VIA_D_1  ")  
processAntenna(
	gate((via3_2stackfinal via3_violate_s_2_a3))
        antenna( via3_violate_s_2_a3 )
        ratio = via3_violate_s_2_a3.area/via3_2stackfinal.area
via3s5_array3_4_m_a3 = drcAntenna( via3_violate_s_2_a3 via3_2stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via3s5_array3_4_m_a3 = geomButtOrOver( via3_violate_s_2_a3 via3s5_array3_4_m_a3_via3_2stackfinal)
processAntenna(
	gate((via3_2stackfinal via4_violate_s_2_a3))
        antenna( via4_violate_s_2_a3 )
        ratio = via4_violate_s_2_a3.area/via3_2stackfinal.area
via3s5_array3_4_m1_a4 = drcAntenna( via4_violate_s_2_a3 via3_2stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via3s5_array3_4_m1_a4 = geomButtOrOver( via4_violate_s_2_a3 via3s5_array3_4_m1_a4_via3_2stackfinal)
 via3s5_array3_4_m2_b3 = geomOr(via3s5_array3_4_m_a3 via3s5_array3_4_m1_a4)  
 errorLayer( geomSize( geomSize( via3s5_array3_4_m2_b3  VIA_Merge ) -VIA_Merge) 
	"VIA3.S.5_Array3_4_M  Minimum space between two VIAs in 2-level continuous stacking VIA arrays with below condition >=0.49um Via3 violate VIA_S_3 spacing in Via3/Via4 array & density large or equal VIA_D_1  ")  
processAntenna(
	gate((via4_2stackfinal via4_violate_s_2_a4))
        antenna( via4_violate_s_2_a4 )
        ratio = via4_violate_s_2_a4.area/via4_2stackfinal.area
via4s5_array4_5_m_a4 = drcAntenna( via4_violate_s_2_a4 via4_2stackfinal ratio keep >= VIA_D_1  suppressErrorMessage  )
)
via4s5_array4_5_m_a4 = geomButtOrOver( via4_violate_s_2_a4 via4s5_array4_5_m_a4_via4_2stackfinal)
 errorLayer( geomSize( geomSize( via4s5_array4_5_m_a4  VIA_Merge ) -VIA_Merge) 
	"VIA4.S.5_Array4_5_M  Minimum space between two VIAs in 2-level continuous stacking VIA arrays with below condition >=0.49um Via4 violate VIA_S_3 spacing in Via4/Via5 array & density large or equal VIA_D_1  ")  
 cb_cup = geomButtOrOver( cb wbdmy  )   
/*  VIA5 checks */
/* ============= */
 via5r = geomOutside( via5 cb_cup  )   
 via5r_core = geomAndNot(via5r sr_via5)  
 via5w1_a = geomAndNot( via5r_core geomGetRectangle( via5r_core length == 0.36 width == 0.36 swap ) )  
 errorLayer( geomOutside( via5w1_a rngx  ) 
	"VIA5.W.1  VIA5 must be 0.36 x 0.36 ") /*  exclude from metal fuse protection ring area */ 
 drc( via5r   sepNotch < 0.35  
	"VIA5.S.1  Min. VIA5 spacing < 0.35 ")  
 drc( m5 via5r  enc < 0.01  shielded withIntersection withSingularPoint 
	"VIA5.E.1  Min. extension of a M5 region beyond a VIA5 region < 0.01 ")  
 errorLayer( geomAndNot(via5r m5) 
	"VIA5.E.1 2  Min. extension of a M5 region beyond a VIA5 region < 0.01 ") 
 via5e2_x = drc( m5 via5r  enc < 0.06  oppositeB shielded withIntersection edgeb )/*  a narrow side */
 via5e2_x_ang01 = geomGetAngledEdge(via5e2_x keep == 0)
 via5e2_x_ang011 = geomGetAdjacentEdge(via5e2_x via5e2_x_ang01 )
 via5e2_x_ang451 = geomGetAngledEdge(via5e2_x keep == 45)
 errorLayer( geomAndNot(via5e2_x_ang011 via5e2_x_ang451) 
	"VIA5.E.2  Min. extension of a M5 end-of-line region beyond VIA5 region < 0.06 ") /*  adjacent narrow sides */
if((CHECK_ALRDL == 1) then
if((THICK_20K == 0) then
if((THICK_40K == 0) then
/*  VIAD checks */
/* ============= */
 viadr = geomOutside( viad cb_cup  )   
 viadr_core = geomAndNot(viadr sr_viad)  
 viadw1_a = geomAndNot( viadr_core geomGetRectangle( viadr_core length == 0.36 width == 0.36 swap ) )  
 errorLayer( geomOutside( viadw1_a rngx  ) 
	"VIAD.W.1  VIAD must be 0.36 x 0.36 ") /*  exclude from metal fuse protection ring area */ 
 drc( viadr   sepNotch < 0.35  
	"VIAD.S.1  Min. VIAD spacing < 0.35 ")  
 drc( m6 viadr  enc < 0.01  shielded withIntersection withSingularPoint 
	"VIAD.E.1  Min. extension of a M6 region beyond a VIAD region < 0.01 ")  
 errorLayer( geomAndNot(viadr m6) 
	"VIAD.E.1 2  Min. extension of a M6 region beyond a VIAD region < 0.01 ") 
 viade2_x = drc( m6 viadr  enc < 0.06  oppositeB shielded withIntersection edgeb )/*  a narrow side */
 viade2_x_ang01 = geomGetAngledEdge(viade2_x keep == 0)
 viade2_x_ang011 = geomGetAdjacentEdge(viade2_x viade2_x_ang01 )
 viade2_x_ang451 = geomGetAngledEdge(viade2_x keep == 45)
 errorLayer( geomAndNot(viade2_x_ang011 viade2_x_ang451) 
	"VIAD.E.2  Min. extension of a M6 end-of-line region beyond VIAD region < 0.06 ") /*  adjacent narrow sides */
) ; 
) ; 
) ; 
if((THICK_20K == 0) then
if((THICK_40K == 0) then
/*  M6 checks */
/* ============= */

 M6_W_1 = 0.44
 M6W1 = MxW1( m6 M6_W_1 )
 errorLayer( M6W1 "M6.W.1  Min. M6 width < 0.44 ") 

 drc( m6   sepNotch < 0.46  
	"M6.S.1  Min. M6 space < 0.46 ")  

M6_WIDE = 10
M6S2    = 0.6 
M6_INCR = 0.322
M6_DIST = 1 
M6_S_2  = MxS2( m6 m6xd M6_WIDE GRID M6S2 M6_INCR M6_DIST 0 89.5 )
errorLayer( M6_S_2 "M6.S.2  Min. space to wide M6 (>10um) < 0.6 ")


 drc( m6 via5  enc < 0.09  shielded withIntersection withSingularPoint 
	"M6.E.1  Min. extension of a M6 region beyond a VIA5 region < 0.09 ")  
 errorLayer( geomAndNot(via5 m6) 
	"M6.E.1 2  Min. extension of a M6 region beyond a VIA5 region < 0.09 ") 
 drc( m6  area < 0.562 
	"M6.A.1  Min. M6 area region < 0.562 ") 
if((CHECK_ALRDL == 1) then
/*  MD checks */
/* ============= */

 MD_W_1 = 0.44
 MDW1 = MxW1( md MD_W_1 )
 errorLayer( MDW1 "MD.W.1  Min. MD width < 0.44 ") 

 drc( md   sepNotch < 0.46  
	"MD.S.1  Min. MD space < 0.46 ")  

MD_WIDE = 10
MDS2    = 0.6 
MD_INCR = 0.322
MD_DIST = 1 
MD_S_2  = MxS2( md mdxd MD_WIDE GRID MDS2 MD_INCR MD_DIST 0 89.5 )
errorLayer( MD_S_2 "MD.S.2  Min. space to wide MD (>10um) < 0.6 ")

 drc( md viad  enc < 0.09  shielded withIntersection withSingularPoint 
	"MD.E.1  Min. extension of a MD region beyond a VIAD region < 0.09 ")  
 errorLayer( geomAndNot(viad md) 
	"MD.E.1 2  Min. extension of a MD region beyond a VIAD region < 0.09 ") 
 drc( md  area < 0.562 
	"MD.A.1  Min. MD area region < 0.562 ") 
) ; 
) ; 
) ; 
/*  METAL RATIO CHECKS */
/* ====================== */
 por3_all_poly = geomOr(polyi dpo)  

processCoverage(
	precision = 6
         
	measure( 
             por3_all_poly_den_pc = layerList( por3_all_poly )
             por3_all_poly_den2 = output(por3_all_poly_den_pc  0 <=  keep < 0.14)
        ); end measure
  );end processCovearage
  errorLayer( por3_all_poly_den2 
	"PO.R.3  Min poly area coverage < 14% ") 

processCoverage(
	precision = 6
         
	measure( 
             m1xd_den_pc = layerList( m1xd )
             m1xd_den2 = output(m1xd_den_pc  0 <=  keep < 0.3)
        ); end measure
  );end processCovearage
  errorLayer( m1xd_den2 
	"M1.R.1  Min M1 area coverage < 30% ") 

processCoverage(
	precision = 6
         
	measure( 
             m2xd_den_pc = layerList( m2xd )
             m2xd_den2 = output(m2xd_den_pc  0 <=  keep < 0.3)
        ); end measure
  );end processCovearage
  errorLayer( m2xd_den2 
	"M2.R.1  Min M2 area coverage < 30% ") 

processCoverage(
	precision = 6
         
	measure( 
             m3xd_den_pc = layerList( m3xd )
             m3xd_den2 = output(m3xd_den_pc  0 <=  keep < 0.3)
        ); end measure
  );end processCovearage
  errorLayer( m3xd_den2 
	"M3.R.1  Min M3 area coverage < 30% ") 

processCoverage(
	precision = 6
         
	measure( 
             m4xd_den_pc = layerList( m4xd )
             m4xd_den2 = output(m4xd_den_pc  0 <=  keep < 0.3)
        ); end measure
  );end processCovearage
  errorLayer( m4xd_den2 
	"M4.R.1  Min M4 area coverage < 30% ") 

processCoverage(
	precision = 6
         
	measure( 
             m5xd_den_pc = layerList( m5xd )
             m5xd_den2 = output(m5xd_den_pc  0 <=  keep < 0.3)
        ); end measure
  );end processCovearage
  errorLayer( m5xd_den2 
	"M5.R.1  Min M5 area coverage < 30% ") 
if((THICK_20K == 0) then
if((THICK_40K == 0) then

processCoverage(
	precision = 6
         
	measure( 
             m6xd_den_pc = layerList( m6xd )
             m6xd_den2 = output(m6xd_den_pc  0 <=  keep < 0.3)
        ); end measure
  );end processCovearage
  errorLayer( m6xd_den2 
	"M6.R.1  Min M6 area coverage < 30% ") 

processCoverage(
	precision = 6
         
	measure( 
             mdxd_den_pc = layerList( mdxd )
             mdxd_den2 = output(mdxd_den_pc  0 < keep < 0.3)
        ); end measure
  );end processCovearage
  errorLayer( mdxd_den2 
	"MD.R.1  Min MD area coverage < 30% ") 
) ; 
) ; 
/*  Dummy Pad */
/* ========== */
 dp_v1 = geomAnd(dpdmy via1)  
 dp_v2 = geomAnd(dpdmy via2)  
 dp_v3 = geomAnd(dpdmy via3)  
 dp_v4 = geomAnd(dpdmy via4)  
 dp_v5 = geomAnd(dpdmy via5)  
 dp_vd = geomAnd(dpdmy viad)  
 errorLayer( geomAndNot(dpdmy m1) 
	"ADP.R.0A  chip corner dummy pad structure should be M1/M2.../M6 ") 
 errorLayer( geomAndNot(dpdmy m2) 
	"ADP.R.0A 2  chip corner dummy pad structure should be M1/M2.../M6 ") 
 errorLayer( geomAndNot(dpdmy m3) 
	"ADP.R.0A 3  chip corner dummy pad structure should be M1/M2.../M6 ") 
 errorLayer( geomAndNot(dpdmy m4) 
	"ADP.R.0A 4  chip corner dummy pad structure should be M1/M2.../M6 ") 
 errorLayer( geomAndNot(dpdmy m5) 
	"ADP.R.0A 5  chip corner dummy pad structure should be M1/M2.../M6 ") 
 errorLayer( geomAndNot(dpdmy m6) 
	"ADP.R.0A 6  chip corner dummy pad structure should be M1/M2.../M6 ") 
 errorLayer( geomAndNot(dpdmy geomEnclose(dpdmy via1 )) 
	"ADP.R.0B  chip corner dummy pad structure should be VIA1/VIA2.../VIA6 ")  
 errorLayer( geomAndNot(dpdmy geomEnclose(dpdmy via2 )) 
	"ADP.R.0B 2  chip corner dummy pad structure should be VIA1/VIA2.../VIA6 ")  
 errorLayer( geomAndNot(dpdmy geomEnclose(dpdmy via3 )) 
	"ADP.R.0B 3  chip corner dummy pad structure should be VIA1/VIA2.../VIA6 ")  
 errorLayer( geomAndNot(dpdmy geomEnclose(dpdmy via4 )) 
	"ADP.R.0B 4  chip corner dummy pad structure should be VIA1/VIA2.../VIA6 ")  
 errorLayer( geomAndNot(dpdmy geomEnclose(dpdmy via5 )) 
	"ADP.R.0B 5  chip corner dummy pad structure should be VIA1/VIA2.../VIA6 ")  
 dp_v2_or1 =  geomOr(dp_v2 dp_v4)  
 adpr0c_grp1 = geomOr(dp_v2_or1 dp_vd)  
 dp_v1_or1 =  geomOr(dp_v1 dp_v3)  
 adpr0c1_grp2 = geomOr(dp_v1_or1 dp_v5)  
 errorLayer( geomAnd(adpr0c_grp1 adpr0c1_grp2) 
	"ADP.R.0C  Via structure in Dummy Pad ") 
 drc( dp_v1   sepNotch < 0.58  
	"ADP.S.1_VIA1  Via1 spacing (the same level) < 0.58um. ")  
 drc( dp_v2   sepNotch < 0.58  
	"ADP.S.1_VIA2  Via2 spacing (the same level) < 0.58um. ")  
 drc( dp_v3   sepNotch < 0.58  
	"ADP.S.1_VIA3  Via3 spacing (the same level) < 0.58um. ")  
 drc( dp_v4   sepNotch < 0.58  
	"ADP.S.1_VIA4  Via4 spacing (the same level) < 0.58um. ")  
 drc( dp_v5   sepNotch < 0.58  
	"ADP.S.1_VIA5  Via5 spacing (the same level) < 0.58um. ")  
 drc( dp_vd   sepNotch < 0.58  
	"ADP.S.1_VIAD  ViaD spacing (the same level) < 0.58um. ")  
 drc( dp_v1 dp_v2  sep < 0.23  shielded withIntersection withSingularPoint 
	"ADP.C.1_V1_V2  Vias spacing (different level) < 0.23um. ")  
 drc( dp_v2 dp_v3  sep < 0.23  shielded withIntersection withSingularPoint 
	"ADP.C.1_V2_V3  Vias spacing (different level) < 0.23um. ")  
 drc( dp_v3 dp_v4  sep < 0.23  shielded withIntersection withSingularPoint 
	"ADP.C.1_V3_V4  Vias spacing (different level) < 0.23um. ")  
 drc( dp_v4 dp_v5  sep < 0.16  shielded withIntersection withSingularPoint 
	"ADP.C.2_V4_V5  Via4 and Via5 spacing < 0.16um. ")  
 drc( dp_v5 dp_vd  sep < 0.16  shielded withIntersection withSingularPoint 
	"ADP.C.2_V5_VD  Via5 and ViaD spacing < 0.16um. ")  
 drc( m1 dp_v1  enc < 3  shielded withIntersection withSingularPoint 
	"ADP.E.1_V1_M1  Metal1 enclose Via1 in dummy pad < 3um. ")  
 drc( m2 dp_v1  enc < 3  shielded withIntersection withSingularPoint 
	"ADP.E.1_V1_M2  Metal2 enclose Via1 in dummy pad < 3um. ")  
 drc( m2 dp_v2  enc < 3  shielded withIntersection withSingularPoint 
	"ADP.E.1_V2_M2  Metal2 enclose Via2 in dummy pad < 3um. ")  
 drc( m3 dp_v2  enc < 3  shielded withIntersection withSingularPoint 
	"ADP.E.1_V2_M3  Metal3 enclose Via2 in dummy pad < 3um. ")  
 drc( m3 dp_v3  enc < 3  shielded withIntersection withSingularPoint 
	"ADP.E.1_V3_M3  Metal3 enclose Via3 in dummy pad < 3um. ")  
 drc( m4 dp_v3  enc < 3  shielded withIntersection withSingularPoint 
	"ADP.E.1_V3_M4  Metal4 enclose Via3 in dummy pad < 3um. ")  
 drc( m4 dp_v4  enc < 3  shielded withIntersection withSingularPoint 
	"ADP.E.1_V4_M4  Metal4 enclose Via4 in dummy pad < 3um. ")  
 drc( m5 dp_v4  enc < 3  shielded withIntersection withSingularPoint 
	"ADP.E.1_V4_M5  Metal5 enclose Via4 in dummy pad < 3um. ")  
 drc( m5 dp_v5  enc < 3  shielded withIntersection withSingularPoint 
	"ADP.E.1_V5_M5  Metal5 enclose Via5 in dummy pad < 3um. ")  
 drc( m6 dp_v5  enc < 3  shielded withIntersection withSingularPoint 
	"ADP.E.1_V5_M6  Metal6 enclose Via5 in dummy pad < 3um. ")  
 drc( m6 dp_vd  enc < 3  shielded withIntersection withSingularPoint 
	"ADP.E.1_VD_M6  Meta6l enclose ViaD in dummy pad < 3um. ")  
 drc( md dp_vd  enc < 3  shielded withIntersection withSingularPoint 
	"ADP.E.1_VD_MD  MD enclose ViaD in dummy pad < 3um. ")  
/*  ADP.W.1 is checked by VIAx.W.1 ( x= 1..4) */
/*  ADP.W.2 is checked by VIA5.W.1 */
/*  Guideline */
 drc( dpdmy   sepNotch < 2  
	"ADP.S.2g  dummy pad spacing < 2um. ")  
 adpw3g_dpadg = drc( dpdmy  0 < width <= 80  opposite )
 errorLayer( geomAndNot(dpdmy adpw3g_dpadg) 
	"ADP.W.3g  dummy pad width > 80um ") 

ADPW4a = drc( dpdmy  width < 40  withCornerTouch ) 
ADPW4b = geomStretchCorner(geomGetCorner( dpdmy  keep < 90 ) 40 angleAll)
ADPW4  = geomOr( ADPW4a ADPW4b )
errorLayer( ADPW4 "ADP.W.4g  dummy pad width < 40um ") 

/*  Power Line */
/* =========== */
 pl_v1 = geomAnd(pldmy via1)  
 pl_v2 = geomAnd(pldmy via2)  
 pl_v3 = geomAnd(pldmy via3)  
 pl_v4 = geomAnd(pldmy via4)  
 pl_v5 = geomAnd(pldmy via5)  
 pl_vd = geomAnd(pldmy viad)  
 pl_v2_or1 =  geomOr(pl_v2 pl_v4)  
 adpr0d_grp1 = geomOr(pl_v2_or1 pl_vd)  
 pl_v1_or1 =  geomOr(pl_v1 pl_v3)  
 adpr0d1_grp2 = geomOr(pl_v1_or1 pl_v5)  
 errorLayer( geomAnd(adpr0d_grp1 adpr0d1_grp2) 
	"ADP.R.0D  Via structure in Power Line ") 
 drc( pl_v1   sepNotch < 0.58  
	"ADP.S.1_PL_V1  Via1 spacing (the same level) < 0.58um. ")  
 drc( pl_v2   sepNotch < 0.58  
	"ADP.S.1_PL_V2  Via2 spacing (the same level) < 0.58um. ")  
 drc( pl_v3   sepNotch < 0.58  
	"ADP.S.1_PL_V3  Via3 spacing (the same level) < 0.58um. ")  
 drc( pl_v4   sepNotch < 0.58  
	"ADP.S.1_PL_V4  Via4 spacing (the same level) < 0.58um. ")  
 drc( pl_v5   sepNotch < 0.58  
	"ADP.S.1_PL_V5  Via5 spacing (the same level) < 0.58um. ")  
 drc( pl_vd   sepNotch < 0.58  
	"ADP.S.1_PL_VD  ViaD spacing (the same level) < 0.58um. ")  
 drc( pl_v1 pl_v2  sep < 0.23  shielded withIntersection withSingularPoint 
	"ADP.C.1_PL_V1_V2  Vias spacing (different level) < 0.23um. ")  
 drc( pl_v2 pl_v3  sep < 0.23  shielded withIntersection withSingularPoint 
	"ADP.C.1_PL_V2_V3  Vias spacing (different level) < 0.23um. ")  
 drc( pl_v3 pl_v4  sep < 0.23  shielded withIntersection withSingularPoint 
	"ADP.C.1_PL_V3_V4  Vias spacing (different level) < 0.23um. ")  
 drc( pl_v4 pl_v5  sep < 0.16  shielded withIntersection withSingularPoint 
	"ADP.C.2_PL_V4_V5  Via4 and Via5 spacing < 0.16um. ")  
 drc( pl_v5 pl_vd  sep < 0.16  shielded withIntersection withSingularPoint 
	"ADP.C.2_PL_V5_VD  Via5 and ViaD spacing < 0.16um. ")  
 drc( m1 pl_v1  enc < 0.2  shielded withIntersection withSingularPoint 
	"ADP.E.2_V1_M1  Metal1 enclose Via1 in chip corner power line < 0.2um. ")  
 drc( m2 pl_v1  enc < 0.2  shielded withIntersection withSingularPoint 
	"ADP.E.2_V1_M2  Metal2 enclose Via1 in chip corner power line < 0.2um. ")  
 drc( m2 pl_v2  enc < 0.2  shielded withIntersection withSingularPoint 
	"ADP.E.2_V2_M2  Metal2 enclose Via2 in chip corner power line < 0.2um. ")  
 drc( m3 pl_v2  enc < 0.2  shielded withIntersection withSingularPoint 
	"ADP.E.2_V2_M3  Metal3 enclose Via2 in chip corner power line < 0.2um. ")  
 drc( m3 pl_v3  enc < 0.2  shielded withIntersection withSingularPoint 
	"ADP.E.2_V3_M3  Metal3 enclose Via3 in chip corner power line < 0.2um. ")  
 drc( m4 pl_v3  enc < 0.2  shielded withIntersection withSingularPoint 
	"ADP.E.2_V3_M4  Metal4 enclose Via3 in chip corner power line < 0.2um. ")  
 drc( m4 pl_v4  enc < 0.2  shielded withIntersection withSingularPoint 
	"ADP.E.2_V4_M4  Metal4 enclose Via4 in chip corner power line < 0.2um. ")  
 drc( m5 pl_v4  enc < 0.2  shielded withIntersection withSingularPoint 
	"ADP.E.2_V4_M5  Metal5 enclose Via4 in chip corner power line < 0.2um. ")  
 drc( m5 pl_v5  enc < 0.2  shielded withIntersection withSingularPoint 
	"ADP.E.2_V5_M5  Metal5 enclose Via5 in chip corner power line < 0.2um. ")  
 drc( m6 pl_v5  enc < 0.2  shielded withIntersection withSingularPoint 
	"ADP.E.2_V5_M6  Metal6 enclose Via5 in chip corner power line < 0.2um. ")  
 drc( m6 pl_vd  enc < 0.2  shielded withIntersection withSingularPoint 
	"ADP.E.2_VD_M6  Metal6 enclose ViaD in chip corner power line < 0.2um. ")  
 drc( md pl_vd  enc < 0.2  shielded withIntersection withSingularPoint 
	"ADP.E.2_VD_MD  MD enclose ViaD in chip corner power line < 0.2um. ")  
/* METAL SLOT CHECKS */
/* ================ */
/* Bonding pad ,chip corner dummy pad ,and inductor need not put slot */
 cb_non_cup = geomAndNot(cbi geomButtOrOver(cbi wbdmy ))   
 slt_exd = geomOr(cb_non_cup dpdmy)  
 slt_exdt = geomOr(cbi dpdmy)  
 pad_exd = geomAndNot(ubmi geomButtOrOver(ubmi mdxd ))   
 m1exd = geomAndNot(m1xd slt_exd)  
/* M1 SLOT CHECKS */
/* ============== */
m1exd_out1 = geomHoles(m1exd innermost )
 m1innerhole = m1exd_out1  
 m1bighole = geomSize( m1innerhole -5 noClipAcute )   
 m1hole = geomOutside( m1innerhole m1bighole  )   
 m1holespace = geomAndNot(m1hole m1exd)  
 fim1c = geomOr(m1exd m1holespace)  
 fim1c_sz1 =  geomWidth(  fim1c keep > 2   )   
 fim1c_sz1_sz1 =  geomWidth(  fim1c_sz1 keep > 35   )   
 lm1xa = geomAnd(fim1c_sz1_sz1 fim1c)  
 lm1x = geomEncloseRect( lm1xa 35.005 35.005 )   
 m1holed = geomAnd(m1holespace lm1x)  
 m1exd_sz1 =  geomWidth(  m1exd keep > 2   )   
 m1exd_sz1_sz1 =  geomWidth(  m1exd_sz1 keep > 35   )   
 ams1m1_a = geomAnd(m1exd_sz1_sz1 m1exd)  
 errorLayer( geomEncloseRect( ams1m1_a 35.005 35.005 ) 
	"AMS.1.M1  Wide Metal (>35um) must have slot. ")  
geomConnect( incremental
	buttOrOver(m1holed lm1x)
)
AMS_DN_1_2 = geomAndNot( lm1x geomButtOrOver( lm1x m1holed ) )
processAntenna(
	gate((lm1x m1holed))
        antenna( m1holed )
        ratio = m1holed.area/lm1x.area
      AMS_DN_1_1 = drcAntenna( m1holed lm1x ratio keep < 0.015 suppressErrorMessage )
)
AMS_DN_1_1_or = geomOr( AMS_DN_1_1_lm1x AMS_DN_1_2 )
errorLayer( AMS_DN_1_1_or "AMS.DN.M1  Min. Hole density for metal lines that need to apply slot  1.5% ")
 m2exd = geomAndNot(m2xd slt_exd)  
/* M2 SLOT CHECKS */
/* ============== */
m2exd_out1 = geomHoles(m2exd innermost )
 m2innerhole = m2exd_out1  
 m2bighole = geomSize( m2innerhole -5 noClipAcute )   
 m2hole = geomOutside( m2innerhole m2bighole  )   
 m2holespace = geomAndNot(m2hole m2exd)  
 fim2c = geomOr(m2exd m2holespace)  
 fim2c_sz1 =  geomWidth(  fim2c keep > 2   )   
 fim2c_sz1_sz1 =  geomWidth(  fim2c_sz1 keep > 35   )   
 lm2xa = geomAnd(fim2c_sz1_sz1 fim2c)  
 lm2x = geomEncloseRect( lm2xa 35.005 35.005 )   
 m2holed = geomAnd(m2holespace lm2x)  
 m2exd_sz1 =  geomWidth(  m2exd keep > 2   )   
 m2exd_sz1_sz1 =  geomWidth(  m2exd_sz1 keep > 35   )   
 ams1m2_a = geomAnd(m2exd_sz1_sz1 m2exd)  
 errorLayer( geomEncloseRect( ams1m2_a 35.005 35.005 ) 
	"AMS.1.M2  Wide Metal (>35um) must have slot. ")  
geomConnect( incremental
	buttOrOver(m2holed lm2x)
)
AMS_DN_2_2 = geomAndNot( lm2x geomButtOrOver( lm2x m2holed ) )
processAntenna(
	gate((lm2x m2holed))
        antenna( m2holed )
        ratio = m2holed.area/lm2x.area
      AMS_DN_2_1 = drcAntenna( m2holed lm2x ratio keep < 0.015 suppressErrorMessage )
)
AMS_DN_2_1_or = geomOr( AMS_DN_2_1_lm2x AMS_DN_2_2 )
errorLayer( AMS_DN_2_1_or "AMS.DN.M2  Min. Hole density for metal lines that need to apply slot  1.5% ")
 m3exd = geomAndNot(m3xd slt_exd)  
/* M3 SLOT CHECKS */
/* ============== */
m3exd_out1 = geomHoles(m3exd innermost )
 m3innerhole = m3exd_out1  
 m3bighole = geomSize( m3innerhole -5 noClipAcute )   
 m3hole = geomOutside( m3innerhole m3bighole  )   
 m3holespace = geomAndNot(m3hole m3exd)  
 fim3c = geomOr(m3exd m3holespace)  
 fim3c_sz1 =  geomWidth(  fim3c keep > 2   )   
 fim3c_sz1_sz1 =  geomWidth(  fim3c_sz1 keep > 35   )   
 lm3xa = geomAnd(fim3c_sz1_sz1 fim3c)  
 lm3x = geomEncloseRect( lm3xa 35.005 35.005 )   
 m3holed = geomAnd(m3holespace lm3x)  
 m3exd_sz1 =  geomWidth(  m3exd keep > 2   )   
 m3exd_sz1_sz1 =  geomWidth(  m3exd_sz1 keep > 35   )   
 ams1m3_a = geomAnd(m3exd_sz1_sz1 m3exd)  
 errorLayer( geomEncloseRect( ams1m3_a 35.005 35.005 ) 
	"AMS.1.M3  Wide Metal (>35um) must have slot. ")  
geomConnect( incremental
	buttOrOver(m3holed lm3x)
)
AMS_DN_3_2 = geomAndNot( lm3x geomButtOrOver( lm3x m3holed ) )
processAntenna(
	gate((lm3x m3holed))
        antenna( m3holed )
        ratio = m3holed.area/lm3x.area
      AMS_DN_3_1 = drcAntenna( m3holed lm3x ratio keep < 0.015 suppressErrorMessage )
)
AMS_DN_3_1_or = geomOr( AMS_DN_3_1_lm3x AMS_DN_3_2 )
errorLayer( AMS_DN_3_1_or "AMS.DN.M3  Min. Hole density for metal lines that need to apply slot  1.5% ")
 m4exd = geomAndNot(m4xd slt_exd)  
/* M4 SLOT CHECKS */
/* ============== */
m4exd_out1 = geomHoles(m4exd innermost )
 m4innerhole = m4exd_out1  
 m4bighole = geomSize( m4innerhole -5 noClipAcute )   
 m4hole = geomOutside( m4innerhole m4bighole  )   
 m4holespace = geomAndNot(m4hole m4exd)  
 fim4c = geomOr(m4exd m4holespace)  
 fim4c_sz1 =  geomWidth(  fim4c keep > 2   )   
 fim4c_sz1_sz1 =  geomWidth(  fim4c_sz1 keep > 35   )   
 lm4xa = geomAnd(fim4c_sz1_sz1 fim4c)  
 lm4x = geomEncloseRect( lm4xa 35.005 35.005 )   
 m4holed = geomAnd(m4holespace lm4x)  
 m4exd_sz1 =  geomWidth(  m4exd keep > 2   )   
 m4exd_sz1_sz1 =  geomWidth(  m4exd_sz1 keep > 35   )   
 ams1m4_a = geomAnd(m4exd_sz1_sz1 m4exd)  
 errorLayer( geomEncloseRect( ams1m4_a 35.005 35.005 ) 
	"AMS.1.M4  Wide Metal (>35um) must have slot. ")  
geomConnect( incremental
	buttOrOver(m4holed lm4x)
)
AMS_DN_4_2 = geomAndNot( lm4x geomButtOrOver( lm4x m4holed ) )
processAntenna(
	gate((lm4x m4holed))
        antenna( m4holed )
        ratio = m4holed.area/lm4x.area
      AMS_DN_4_1 = drcAntenna( m4holed lm4x ratio keep < 0.015 suppressErrorMessage )
)
AMS_DN_4_1_or = geomOr( AMS_DN_4_1_lm4x AMS_DN_4_2 )
errorLayer( AMS_DN_4_1_or "AMS.DN.M4  Min. Hole density for metal lines that need to apply slot  1.5% ")
 m5exd = geomAndNot(m5xd slt_exdt)  
/* M5 SLOT CHECKS */
/* ============== */
m5exd_out1 = geomHoles(m5exd innermost )
 m5innerhole = m5exd_out1  
 m5bighole = geomSize( m5innerhole -5 noClipAcute )   
 m5hole = geomOutside( m5innerhole m5bighole  )   
 m5holespace = geomAndNot(m5hole m5exd)  
 fim5c = geomOr(m5exd m5holespace)  
 fim5c_sz1 =  geomWidth(  fim5c keep > 2   )   
 fim5c_sz1_sz1 =  geomWidth(  fim5c_sz1 keep > 35   )   
 lm5xa = geomAnd(fim5c_sz1_sz1 fim5c)  
 lm5x = geomEncloseRect( lm5xa 35.005 35.005 )   
 m5holed = geomAnd(m5holespace lm5x)  
 m5exd_sz1 =  geomWidth(  m5exd keep > 2   )   
 m5exd_sz1_sz1 =  geomWidth(  m5exd_sz1 keep > 35   )   
 ams1m5_a = geomAnd(m5exd_sz1_sz1 m5exd)  
 errorLayer( geomEncloseRect( ams1m5_a 35.005 35.005 ) 
	"AMS.1.M5  Wide Metal (>35um) must have slot. ")  
geomConnect( incremental
	buttOrOver(m5holed lm5x)
)
AMS_DN_5_2 = geomAndNot( lm5x geomButtOrOver( lm5x m5holed ) )
processAntenna(
	gate((lm5x m5holed))
        antenna( m5holed )
        ratio = m5holed.area/lm5x.area
      AMS_DN_5_1 = drcAntenna( m5holed lm5x ratio keep < 0.015 suppressErrorMessage )
)
AMS_DN_5_1_or = geomOr( AMS_DN_5_1_lm5x AMS_DN_5_2 )
errorLayer( AMS_DN_5_1_or "AMS.DN.M5  Min. Hole density for metal lines that need to apply slot  1.5% ")
pad_exd6 = geomSizeAnd( pad_exd m6xd 0.32 2 )  
 slt_exdt_or1 =  geomOr(slt_exdt pad_exd6)  
 m6exd = geomAndNot(m6xd slt_exdt_or1)  
/* M6 SLOT CHECKS */
/* ============== */
m6exd_out1 = geomHoles(m6exd innermost )
 m6innerhole = m6exd_out1  
 m6bighole = geomSize( m6innerhole -5 noClipAcute )   
 m6hole = geomOutside( m6innerhole m6bighole  )   
 m6holespace = geomAndNot(m6hole m6exd)  
 fim6c = geomOr(m6exd m6holespace)  
 fim6c_sz1 =  geomWidth(  fim6c keep > 2   )   
 fim6c_sz1_sz1 =  geomWidth(  fim6c_sz1 keep > 35   )   
 lm6xa = geomAnd(fim6c_sz1_sz1 fim6c)  
 lm6x = geomEncloseRect( lm6xa 35.005 35.005 )   
 m6holed = geomAnd(m6holespace lm6x)  
 m6exd_sz1 =  geomWidth(  m6exd keep > 2   )   
 m6exd_sz1_sz1 =  geomWidth(  m6exd_sz1 keep > 35   )   
 ams1m6_a = geomAnd(m6exd_sz1_sz1 m6exd)  
 errorLayer( geomEncloseRect( ams1m6_a 35.005 35.005 ) 
	"AMS.1.M6  Wide Metal (>35um) must have slot. ")  
geomConnect( incremental
	buttOrOver(m6holed lm6x)
)
AMS_DN_6_2 = geomAndNot( lm6x geomButtOrOver( lm6x m6holed ) )
processAntenna(
	gate((lm6x m6holed))
        antenna( m6holed )
        ratio = m6holed.area/lm6x.area
      AMS_DN_6_1 = drcAntenna( m6holed lm6x ratio keep < 0.015 suppressErrorMessage )
)
AMS_DN_6_1_or = geomOr( AMS_DN_6_1_lm6x AMS_DN_6_2 )
errorLayer( AMS_DN_6_1_or "AMS.DN.M6  Min. Hole density for metal lines that need to apply slot  1.5% ")
/* MD SLOT CHECKS */
/* ============== */
/*  Bonding pad, chip corner dummy pad, and inductor need not put slot */
ubm_exdd = geomSizeAnd( ubmi mdxd 0.32 2 )  /*  For RDL */
 dpdmy_or1 =  geomOr(dpdmy ubm_exdd)  
 mdexd = geomAndNot(mdxd dpdmy_or1)  
mdexd_out1 = geomHoles(mdexd innermost )
 mdinnerhole = mdexd_out1  
 mdbighole = geomSize( mdinnerhole -5 noClipAcute )  /*  Holes with width less than 10um will be filled back */ 
 mdhole = geomOutside( mdinnerhole mdbighole  )   
 mdholespace = geomAndNot(mdhole mdexd)  
 fimdc = geomOr(mdexd mdholespace)  
 fimdc_sz1 =  geomWidth(  fimdc keep > 2   )   
 fimdc_sz1_sz1 =  geomWidth(  fimdc_sz1 keep > 35   )   
 lmdxa = geomAnd(fimdc_sz1_sz1 fimdc)  
 lmdx = geomEncloseRect( lmdxa 35.005 35.005 )   
 mdholed = geomAnd(mdholespace lmdx)  
 mdexd_sz1 =  geomWidth(  mdexd keep > 2   )   
 mdexd_sz1_sz1 =  geomWidth(  mdexd_sz1 keep > 35   )   
 ams1md_a = geomAnd(mdexd_sz1_sz1 mdexd)  
 errorLayer( geomEncloseRect( ams1md_a 35.005 35.005 ) 
	"AMS.1.MD  Wide Metal (>35um) must have slot ")  
geomConnect( incremental
	buttOrOver(mdholed lmdx)
)
AMS_DN_D_2 = geomAndNot( lmdx geomButtOrOver( lmdx mdholed ) )
processAntenna(
	gate((lmdx mdholed))
        antenna( mdholed )
        ratio = mdholed.area/lmdx.area
      AMS_DN_D_1 = drcAntenna( mdholed lmdx ratio keep < 0.015 suppressErrorMessage )
)
AMS_DN_D_1_or = geomOr( AMS_DN_D_1_lmdx AMS_DN_D_2 )
errorLayer( AMS_DN_D_1_or "AMS.DN.MD  Min. Hole density for metal lines that need to apply slot  1.5% ")
/* I/O ESD Guidance  */
/* ================ */
 epact = geomAnd(pact sdi)  
 enact = geomAnd(nact sdi)  
 co_and1 =  geomAnd(co sdi)  
 eco = geomAnd(co_and1 od)  
 epmos = geomEnclose( epact all_gate  )   
 enmos = geomEnclose( enact all_gate  )   
 egte = geomAnd(all_gate sdi)  
 egte_w = geomGetEdge(egte inside od)   
 epsd = geomAndNot(epmos egte)  
 ensd = geomAndNot(enmos egte)  
 ensd_not1 =  geomAndNot(ensd geomButtOrOver(ensd eco ))   
 ensd_nco = geomAndNot(ensd_not1 geomButtOrOver(ensd_not1 ptap ))   
 epsd_not1 =  geomAndNot(epsd geomButtOrOver(epsd eco ))   
 epsd_nco = geomAndNot(epsd_not1 geomButtOrOver(epsd_not1 ntap ))   
 ensd_wco = geomAndNot(ensd ensd_nco)  
 epsd_wco = geomAndNot(epsd epsd_nco)  
 ensd_src = geomOutside( ensd_wco rpo  )   
 esd1_gate = geomAnd(egte esd1dmy)  
 esd1_ncs_gate = geomAndNot(esd1_gate geomButtOrOver(esd1_gate ensd_nco ))   
 enmos_and1 =  geomAnd(enmos esd1dmy)  
 esd1_tol = geomButtOrOver( enmos_and1 ensd_nco  )   
 enmos_and2 =  geomAnd(enmos esd1dmy)  
 esd1_ncs = geomAndNot(enmos_and2 geomButtOrOver(enmos_and2 ensd_nco ))   
 ensd_nco_esd1dmy = geomButtOrOver( ensd_nco esd1dmy  )   
 esd1_tol_gate = geomButtOrOver( egte ensd_nco_esd1dmy  )   
 esd1_tol_gate1 = geomAndNot(esd1_tol_gate geomButtOrOver(esd1_tol_gate ensd_src ))   
 esd1_tol_gate2 = geomButtOrOver( esd1_tol_gate ensd_src  )   
 esd1_ncs_gate_w = geomGetEdge(esd1_ncs_gate inside od)   
 esd1_tol_gate1_w = geomGetEdge(esd1_tol_gate1 inside od)   
 esd1_tol_gate2_w = geomGetEdge(esd1_tol_gate2 inside od)   
 esd2_gate = geomAnd(egte esd2dmy)  
 esd2_reg_gate = geomAndNot(esd2_gate geomButtOrOver(esd2_gate ensd_nco ))   
 esd2_tol_gate = geomButtOrOver( esd2_gate ensd_nco  )   
 esd2_tol_gate1 = geomAndNot(esd2_tol_gate geomButtOrOver(esd2_tol_gate ensd_src ))   
 esd2_tol_gate2 = geomButtOrOver( esd2_tol_gate ensd_src  )   
 enmos_and3 =  geomAnd(enmos esd2dmy)  
 esd2_tol = geomButtOrOver( enmos_and3 ensd_nco  )   
 enmos_and4 =  geomAnd(enmos esd2dmy)  
 esd2_reg = geomAndNot(enmos_and4 geomButtOrOver(enmos_and4 ensd_nco ))   
 esd2_reg_gate_w = geomGetEdge(esd2_reg_gate inside od)   
 esd2_tol_gate1_w = geomGetEdge(esd2_tol_gate1 inside od)   
 esd2_tol_gate2_w = geomGetEdge(esd2_tol_gate2 inside od)   
 rpo_and2 =  geomAnd(rpo sdi)  
 rpo_and2_out1 =  geomOutside( rpo_and2 esd1dmy  )   
 rpo1 = geomOutside( rpo_and2_out1 esd2dmy  )   
 egte_out1 =  geomOutside( egte esd1dmy  )   
 egte_out1_out1 =  geomOutside( egte_out1 esd2dmy  )   
 egte1 = geomAndNot(egte_out1_out1 geomButtOrOver(egte_out1_out1 ensd_nco ))   
 egte1_w = geomGetEdge(egte1 inside od)   
 erpo = geomAnd(rpo sdi)  
erpo_out1 = geomHoles(erpo  )
 erpoh = erpo_out1  
 erpoa = geomOr(erpoh erpo)  
 ecos = geomOutside( eco erpoa  )   
 hegt = geomAnd(egte od2)  
 legt = geomAndNot(egte od2)  
 hegn = geomAnd(hegt np)  
 hegp = geomAnd(hegt pp)  
if((GUIDELINE_ESD == 1) then
 errorLayer( geomGetLength(egte_w 0 < keep < 15 contiguous ) 
	"ESD.6g  Unit finger width of NMOS and PMOS for I/O buffer and power clamp device 15um <= width <= 60um. ")  
 errorLayer( geomGetLength(egte_w 60 < keep < 999 contiguous ) 
	"ESD.6g 2  Unit finger width of NMOS and PMOS for I/O buffer and power clamp device 15um <= width <= 60um. ")  
/*  begin of ESD.8, butted or inserted pickup is not allowed */
 esd8g_eact = geomOr(epact enact)  
 esd8g1_dtap = geomOr(ntap ptap)  
esd8g2_eactup3 = geomSizeAndNot( esd8g_eact esd8g1_dtap 0.22* 0.7 3 )  
 esd8g3_d1 = geomButtOrOver( esd8g1_dtap esd8g2_eactup3  )   
esd8g4_d1r1 = geomGrow( esd8g3_d1 -0.001 0 0 0 ) 
 esd8g5_d1r2 = geomAndNot(esd8g3_d1 esd8g4_d1r1)  
 esd8g6_d1r3 = geomGetEdge(esd8g3_d1 coincident esd8g5_d1r2)   
 esd8g7_d1r4 = geomGetLength( esd8g6_d1r3  keep > 0.001 )   
 esd8g8_d1r5 = drc( esd8g7_d1r4 esd8g_eact  sep < 3  opposite shielded withIntersection edgea )
 esd8g8_d1r5_sz1 = geomSize(esd8g8_d1r5 0.005 edges)
 esd8g9_d1l = geomButtOrCoin( esd8g3_d1 esd8g8_d1r5_sz1 )   
esd8g10_d1l1 = geomGrow( esd8g9_d1l 0 0 -0.001 0 ) 
 esd8g11_d1l2 = geomAndNot(esd8g9_d1l esd8g10_d1l1)  
 esd8g12_d1l3 = geomGetEdge(esd8g9_d1l coincident esd8g11_d1l2)   
 esd8g13_d1l4 = geomGetLength( esd8g12_d1l3  keep > 0.001 )   
 esd8g14_d1l5 = drc( esd8g13_d1l4 esd8g_eact  sep < 3  opposite shielded withIntersection edgea )
 esd8g14_d1l5_sz1 = geomSize(esd8g14_d1l5 0.005 edges)
 esd8g15_d1x = geomButtOrCoin( esd8g9_d1l esd8g14_d1l5_sz1 )   
esd8g16_d1t1 = geomGrow( esd8g3_d1 0 -0.001 0 0 ) 
 esd8g17_d1t2 = geomAndNot(esd8g3_d1 esd8g16_d1t1)  
 esd8g18_d1t3 = geomGetEdge(esd8g3_d1 coincident esd8g17_d1t2)   
 esd8g19_d1t4 = geomGetLength( esd8g18_d1t3  keep > 0.001 )   
 esd8g20_d1t5 = drc( esd8g19_d1t4 esd8g_eact  sep < 3  opposite shielded withIntersection edgea )
 esd8g20_d1t5_sz1 = geomSize(esd8g20_d1t5 0.005 edges)
 esd8g21_d1b = geomButtOrCoin( esd8g3_d1 esd8g20_d1t5_sz1 )   
esd8g22_d1b1 = geomGrow( esd8g21_d1b 0 0 0 -0.001 ) 
 esd8g23_d1b2 = geomAndNot(esd8g21_d1b esd8g22_d1b1)  
 esd8g24_d1b3 = geomGetEdge(esd8g21_d1b coincident esd8g23_d1b2)   
 esd8g25_d1b4 = geomGetLength( esd8g24_d1b3  keep > 0.001 )   
 esd8g26_d1b5 = drc( esd8g25_d1b4 esd8g_eact  sep < 3  opposite shielded withIntersection edgea )
 esd8g26_d1b5_sz1 = geomSize(esd8g26_d1b5 0.005 edges)
 esd8g27_d1y = geomButtOrCoin( esd8g21_d1b esd8g26_d1b5_sz1 )   
 esd8g28_dtap2check = geomOr(esd8g15_d1x esd8g27_d1y)  
esd8g28_dtap2check5 = geomHoles(esd8g28_dtap2check innermost )
 esd8g29_dtaphole = esd8g28_dtap2check5  
 esd8g30_dtapsuspect =  geomAndNot(esd8g28_dtap2check geomButtOnly(geomOutside(esd8g28_dtap2check esd8g29_dtaphole) esd8g29_dtaphole ))   
 errorLayer( geomEncloseRect( esd8g30_dtapsuspect 20 0.22 ) 
	"ESD.8g 4  It is strictly prohitibied to butting or inserted substrat/well pickups for ESD N/PMOS. ")  
if((CORE_VOLTAGE == 1.5) then
 drc( legt   width < 0.2  withCornerTouch 
	"ESD.18g_1.5V  Minimum 1.5V IO ESD NMOS/PMOS gate length >=0.2um ")  
) ; 
if((CORE_VOLTAGE == 1.8) then
 drc( legt   width < 0.25  withCornerTouch 
	"ESD.18g_1.8V  Minimum 1.8V IO ESD NMOS/PMOS gate length >=0.25um ")  
) ; 
if((HIGH_VOLTAGE == 2.5) then
 drc( hegn   width < 0.3  withCornerTouch 
	"ESD.18g_2.5V_N  Minimum 2.5V IO ESD NMOS gate length < 0.3um ")  
 drc( hegp   width < 0.25  withCornerTouch 
	"ESD.18g_2.5V_P  Minimum 2.5V IO ESD PMOS gate length < 0.25um ")  
) ; 
if((HIGH_VOLTAGE == 3.3) then
 drc( hegn   width < 0.4  withCornerTouch 
	"ESD.18g_3.3V_N  Minimum 3.3V IO ESD NMOS gate length < 0.4um ")  
 drc( hegp   width < 0.3  withCornerTouch 
	"ESD.18g_3.3V_P  Minimum 3.3V IO ESD PMOS gate length < 0.3um ")  
) ; 
if((HIGH_VOLTAGE == 5) then
 hegn1 = geomButtOrOver( hegn esd  )   
 hegn2 = geomAndNot(hegn hegn1)  
 drc( hegn2   width < 0.6  withCornerTouch 
	"ESD.18g_5V_NESD  Minimum 5.0V IO ESD NMOS(without ESD implant)/PMOS gate length >= 0.6um ")  
 drc( hegp   width < 0.6  withCornerTouch 
	"ESD.18g_5V_P  Minimum 5.0V IO ESD NMOS(without ESD implant)/PMOS gate length >= 0.6um ")  
 drc( hegn1   width < 0.9  withCornerTouch 
	"ESD.18g_5V_WESD  Minimum 5.0V IO ESD NMOS (with ESD implant) gate length >=0.9um ")  
) ; 
 egte_ins1 =  geomInside( egte epmos  )   
 epsd_iact1 =  geomButtOrOver( epsd rpo  )   
 errorLayer( geomAndNot(egte_ins1 geomButtOrOver(egte_ins1 epsd_iact1 )) 
	"ESD.19g  NMOS and PMOS of I/O buffer should have a nonsalicide area on drain side, that is, RPO mask should block drain side of device (except contact region should keep silicided). ")  
 enmos_iact1 =  geomButtOrOver( enmos rpo  )   
 egte_ins2 =  geomInside( egte enmos_iact1  )   
 ensd_iact1 =  geomButtOrOver( ensd rpo  )   
 errorLayer( geomAndNot(egte_ins2 geomButtOrOver(egte_ins2 ensd_iact1 )) 
	"ESD.19g 2  NMOS and PMOS of I/O buffer should have a nonsalicide area on drain side, that is, RPO mask should block drain side of device (except contact region should keep silicided). ")  
 esd20g_x = geomAndNot(esd2_tol_gate rpo)  
 errorLayer( geomAndNot(esd2_tol geomButtOrOver(esd2_tol esd20g_x )) 
	"ESD.20g  For high voltage tolerant I/O designed by 3.3V/2.5V/1.8V/1.5V NMOS (see N1 and N2 in Fig.5b) RPO should cover all inactive poly gates and extend to active region (Poly spacing>=0.25um).  Minimum and maximum overlap from RPO to the active poly gate 0.05um or 0.06um ")  
 errorLayer( geomOutside( esd2_tol_gate2 rpo  ) 
	"ESD.20g 2  For high voltage tolerant I/O designed by 3.3V/2.5V/1.8V/1.5V NMOS (see N1 and N2 in Fig.5b) RPO should cover all inactive poly gates and extend to active region (Poly spacing>=0.25um).  Minimum and maximum overlap from RPO to the active poly gate 0.05um or 0.06um ")  
 errorLayer( geomAndNot(esd2_tol_gate1 rpo) 
	"ESD.20g 3  For high voltage tolerant I/O designed by 3.3V/2.5V/1.8V/1.5V NMOS (see N1 and N2 in Fig.5b) RPO should cover all inactive poly gates and extend to active region (Poly spacing>=0.25um).  Minimum and maximum overlap from RPO to the active poly gate 0.05um or 0.06um ") 
 drc( esd2_tol_gate2 rpo  ovlp < 0.05  opposite shielded withIntersection 
	"ESD.20g 4  For high voltage tolerant I/O designed by 3.3V/2.5V/1.8V/1.5V NMOS (see N1 and N2 in Fig.5b) RPO should cover all inactive poly gates and extend to active region (Poly spacing>=0.25um).  Minimum and maximum overlap from RPO to the active poly gate 0.05um or 0.06um ")  
 esd20g1_esd2_tol_gate_rpo = geomStraddle( esd2_tol_gate rpo  )   
 esd20g2_esd2_tol_gate_rpo_ch = geomAnd(esd20g1_esd2_tol_gate_rpo rpo)  
 esd20g3_a = geomWidth(  esd20g2_esd2_tol_gate_rpo_ch keep > 0.05   )   
 drc( esd20g3_a   width < 0.06  opposite 
	"ESD.20g 5  For high voltage tolerant I/O designed by 3.3V/2.5V/1.8V/1.5V NMOS (see N1 and N2 in Fig.5b) RPO should cover all inactive poly gates and extend to active region (Poly spacing>=0.25um).  Minimum and maximum overlap from RPO to the active poly gate 0.05um or 0.06um ")  
 errorLayer( geomWidth(  esd20g3_a keep > 0.06   ) 
	"ESD.20g 6  For high voltage tolerant I/O designed by 3.3V/2.5V/1.8V/1.5V NMOS (see N1 and N2 in Fig.5b) RPO should cover all inactive poly gates and extend to active region (Poly spacing>=0.25um).  Minimum and maximum overlap from RPO to the active poly gate 0.05um or 0.06um ")  
 esd20g_a_x = geomButtOrOver( ensd_nco esd2dmy  )   
 drc( esd20g_a_x   width < 0.25  
	"ESD.20g_A  For high voltage tolerant I/O designed by 3.3V/2.5V/1.8V/1.5V NMOS (see N1 and N2 in Fig.5b) RPO should cover all inactive poly gates and extend to active region (Poly spacing>=0.25um).  Minimum and maximum overlap from RPO to the active poly gate by 0.05um ")  
 errorLayer( geomWidth(  esd20g_a_x keep > 0.25   ) 
	"ESD.20g_A 2  For high voltage tolerant I/O designed by 3.3V/2.5V/1.8V/1.5V NMOS (see N1 and N2 in Fig.5b) RPO should cover all inactive poly gates and extend to active region (Poly spacing>=0.25um).  Minimum and maximum overlap from RPO to the active poly gate by 0.05um ")  
 esd21g_x = geomAndNot(esd2_reg_gate rpo)  
 errorLayer( geomAndNot(esd2_reg geomButtOrOver(esd2_reg esd21g_x )) 
	"ESD.21g  For regular I/O designed by 5V, 3.3V, 2.5V, 1.8V and 1.5V NMOS (see N3 in Fig.6a)  Minimum and maximum overlap from RPO on the drain side to the active poly gate 0.05um or 0.06um ")  
 errorLayer( geomOutside( esd2_reg_gate rpo  ) 
	"ESD.21g 2  For regular I/O designed by 5V, 3.3V, 2.5V, 1.8V and 1.5V NMOS (see N3 in Fig.6a)  Minimum and maximum overlap from RPO on the drain side to the active poly gate 0.05um or 0.06um ")  
 drc( esd2_reg_gate rpo  ovlp < 0.05  opposite shielded withIntersection 
	"ESD.21g 3  For regular I/O designed by 5V, 3.3V, 2.5V, 1.8V and 1.5V NMOS (see N3 in Fig.6a)  Minimum and maximum overlap from RPO on the drain side to the active poly gate 0.05um or 0.06um ")  
 esd21g1_esd2_reg_gate_rpo = geomStraddle( esd2_reg_gate rpo  )   
 esd21g2_esd2_reg_gate_rpo_ch = geomAnd(esd21g1_esd2_reg_gate_rpo rpo)  
 esd21g3_a = geomWidth(  esd21g2_esd2_reg_gate_rpo_ch keep > 0.05   )   
 drc( esd21g3_a   width < 0.06  opposite 
	"ESD.21g 4  For regular I/O designed by 5V, 3.3V, 2.5V, 1.8V and 1.5V NMOS (see N3 in Fig.6a)  Minimum and maximum overlap from RPO on the drain side to the active poly gate 0.05um or 0.06um ")  
 errorLayer( geomWidth(  esd21g3_a keep > 0.06   ) 
	"ESD.21g 5  For regular I/O designed by 5V, 3.3V, 2.5V, 1.8V and 1.5V NMOS (see N3 in Fig.6a)  Minimum and maximum overlap from RPO on the drain side to the active poly gate 0.05um or 0.06um ")  
/*  ESD.22g is checked by ESD.21g */
/*  ESD.23g is checked by ESD.21g */
 ensd_wco_or1 =  geomOr(ensd_wco epsd_wco)  
 ensd_wco_or11 =  geomAnd(ensd_wco_or1 esd2dmy)  
 esd24g_x = geomAnd(ensd_wco_or11 rpo)  
 esd24g1_y = geomGetEdge(egte butting esd24g_x)   
 esd24g2_z = geomGetEdge(rpo coincident esd24g_x)   
 drc( esd24g2_z esd24g1_y  enc < 1.95  shielded withIntersection 
	"ESD.24g  The minimum width of RPO on drain side (X) for 5V,3.3V, 2.5V, 1.8V and 1.5V NMOS and PMOS. 1.8V and 1.5V NMOS when used as power clamp device>=1.95um  ")  
 enmos_or1 =  geomOr(enmos epmos)  
 enmos_or1_iact1 =  geomButtOrOver( enmos_or1 rpo  )   
 esd25g_x = geomAnd(ecos enmos_or1_iact1)  
 drc( esd25g_x egte_w  sep < 0.5  opposite shielded withIntersection 
	"ESD.25g  The minimum clearance from poly edge to CO edge on source side for NMOS and PMOS (Except ESD.26g)>=0.5um ")  
 esd25g1_y = geomAnd(eco esd1_ncs)  
 drc( esd25g1_y egte_w  sep < 0.5  opposite shielded withIntersection 
	"ESD.25g 2  The minimum clearance from poly edge to CO edge on source side for NMOS and PMOS (Except ESD.26g)>=0.5um ")  
 enmos_not1 =  geomAndNot(enmos geomButtOrOver(enmos rpo ))   
 esd26g_x = geomAnd(eco enmos_not1)  
 drc( esd26g_x egte_w  sep < 0.25  opposite shielded withIntersection 
	"ESD.26g  The minimum clearance of poly edge to CO edge on D/S side for 1.8V and 1.5V power clamp device>=0.25um  ")  
 esd27g_x = geomStraddle( egte rpo  )   
 enmos_enc1 =  geomEnclose( enmos esd27g_x  )   
 egte_ins3 =  geomInside( egte enmos_enc1  )   
 errorLayer( geomAndNot(egte_ins3 esd2dmy) 
	"ESD.27g  For RPO DRC purpose,we need a dummy layers in ESD protection device.layers should cover all ESD protection devices. ESD2DMY is for the cascade NMOS in high voltage tolerant I/O designed by 3.3V/2.5V NMOS (see Fig.5b), regular IO designed by 5V/3.3V/2.5V/1.8V/1.5V NMOS and PMOS (see Fig.6b), power clmap designed by 5V/3.3V/2.5V NMOS.     ") 
 epmos_enc1 =  geomEnclose( epmos esd27g_x  )   
 egte_ins4 =  geomInside( egte epmos_enc1  )   
 errorLayer( geomAndNot(egte_ins4 esd2dmy) 
	"ESD.27g 2  For RPO DRC purpose,we need a dummy layers in ESD protection device.layers should cover all ESD protection devices. ESD2DMY is for the cascade NMOS in high voltage tolerant I/O designed by 3.3V/2.5V NMOS (see Fig.5b), regular IO designed by 5V/3.3V/2.5V/1.8V/1.5V NMOS and PMOS (see Fig.6b), power clmap designed by 5V/3.3V/2.5V NMOS.     ") 
if(!(HIGH_VOLTAGE == 5) then
 enmos_enc2 =  geomEnclose( enmos legt  )   
 enmos_enc2_iact1 =  geomButtOrOver( enmos_enc2 esd2dmy  )   
 errorLayer( geomButtOrOver( enmos_enc2_iact1 esd3dmy  ) 
	"ESD.28g  ESD implant is required for High Voltage Tolerant I/O designed by 3.3V NMOS device for 5V signal  input or 2.5V NMOS device for 3.3V signal input at I/O pad. ESD mask (No. 111) can be generated by  logical operation. It is not allowed to use ESD mask (No. 111) for 5V NMOS device. ESD3DMY is for the cascade NMOS in high voltage tolerant I/O designed by 3.3V/2.5V NMOS (see Fig.5b).  ")  
 esd2_tol_gate1 =  geomAnd(esd2_tol_gate od2)  
 errorLayer( geomAndNot(esd2_tol_gate1 esd3dmy) 
	"ESD.28g 2  ESD implant is required for High Voltage Tolerant I/O designed by 3.3V NMOS device for 5V signal  input or 2.5V NMOS device for 3.3V signal input at I/O pad. ESD mask (No. 111) can be generated by  logical operation. It is not allowed to use ESD mask (No. 111) for 5V NMOS device. ESD3DMY is for the cascade NMOS in high voltage tolerant I/O designed by 3.3V/2.5V NMOS (see Fig.5b).  ") 
 errorLayer( geomAnd(esd3dmy gate_pp) 
	"ESD.28g 3  ESD implant is required for High Voltage Tolerant I/O designed by 3.3V NMOS device for 5V signal  input or 2.5V NMOS device for 3.3V signal input at I/O pad. ESD mask (No. 111) can be generated by  logical operation. It is not allowed to use ESD mask (No. 111) for 5V NMOS device. ESD3DMY is for the cascade NMOS in high voltage tolerant I/O designed by 3.3V/2.5V NMOS (see Fig.5b).  ") 
) ; 
/*  ESD.29g is checked by ESD.19g */
 drc( rpo1 egte1_w  sep < 0.45  opposite shielded withIntersection 
	"ESD.30g  For regular 1.8V I/O in NMOS region : Minumum clearance from RPO to poly spacing >=0.45um. ")  
 errorLayer( geomAnd(egte1 rpo1) 
	"ESD.30g 2  For regular 1.8V I/O in NMOS region : Minumum clearance from RPO to poly spacing >=0.45um. ") 
/* ESD.31g is checked by ESD.30g */
 esd32g_y = geomGetEdge(rpo1 inside od)   
 drc( esd32g_y   width < 1.5  
	"ESD.32g The minimum width of RPO on drain side (X) for 1.8V NMOS and 5V/3.3V/1.8V/1.5V PMOS.>=1.5um ")  
/* ESD.33g is checked by ESD.25g */
 enmos_iact2 =  geomButtOrOver( enmos esd1dmy  )   
 errorLayer( geomAndNot(enmos_iact2 erpoa) 
	"ESD.34g  5V, 3.3V and 2.5V NMOS devices when used as power clamp devices, the RPO can fully cover the  uncontacted poly gate, source/drain (except contact region should keep silicided).  ") 

 od_iact1 =  geomButtOrOver( od egte  )   
 od_iact1_not1 =  geomAndNot(od_iact1 poly)  
 ncs_sd_1 = geomAnd(od_iact1_not1 esd1dmy)  
 ncs_sd = geomCat( ncs_sd_1 )
 geomStamp(ncs_sd nsdi)  
 ncs_s = geomNodeRelate( ncs_sd ptapi conn )
 ncs_d = geomAndNot(ncs_sd ncs_s)  
 esd35g_x = geomAnd(ncs_d rpo)  
 esd35g1_y = geomGetEdge(egte butting ncs_d)   
 esd35g2_z = geomGetEdge(rpo coincident esd35g_x)   
 drc( esd35g2_z esd35g1_y  enc < 1.95  shielded withIntersection 
	"ESD.35g  Minimum width of RPO on drain side (X) for 5V, 3.3V and 2.5V NMOS devices when used as power clamp  devices. Ncs Drain is defined as (((OD INTERACT GATE) NOT PO) AND ESD1DMY)  which not connect to PW Pickup.>=1.95um ") 

/* ESD.36g is checked by ESD.25g */
 esd37g_x = geomAndNot(egte geomInside(egte rpo ))   
 esd37g1_y = geomAndNot(enmos geomEnclose(enmos esd37g_x ))   
 errorLayer( geomAndNot(esd37g1_y geomButtOrOver(esd37g1_y esd1dmy )) 
	"ESD.37g   For RPO DRC purpose, we need a dummy layers for 5V, 3.3Vand 2.5V NMOS devices when used as power   clamp devices. The layers should cover all ESD protection devices.    ")  
 errorLayer( geomAnd(esd1dmy gate_pp) 
	"ESD.37g 2   For RPO DRC purpose, we need a dummy layers for 5V, 3.3Vand 2.5V NMOS devices when used as power   clamp devices. The layers should cover all ESD protection devices.    ") 
 enmos_enc3 =  geomEnclose( enmos esd1_gate  )  /*  ESD1DMY should cover all EGTE in new design rule. */ 
 egte_ins5 =  geomInside( egte enmos_enc3  )  /*  ESD1DMY should cover all EGTE in new design rule. */ 
 errorLayer( geomAndNot(egte_ins5 esd1dmy) 
	"ESD.37g 3   For RPO DRC purpose, we need a dummy layers for 5V, 3.3Vand 2.5V NMOS devices when used as power   clamp devices. The layers should cover all ESD protection devices.    ") /*  ESD1DMY should cover all EGTE in new design rule. */
 epsd_or1 =  geomOr(epsd ensd)  
 esdwarn1_red = geomButtOrOver( epsd_or1 rpo1  )   
 esdwarn11_xrpo = geomAndNot(esdwarn1_red rpo1)  
 esdwarn12_xrpg = geomButtOnly(geomOutside(esdwarn11_xrpo egte1) egte1 )   
 errorLayer( geomButtOrOver( esdwarn12_xrpg eco  ) 
	"ESD.WARN.1  CO can't inserted between gate and RPO for 1.8V NMOS and all PMOS I/O pattern. ")  
if((HIGH_VOLTAGE == 5) then
 errorLayer( geomCat(esd3dmy) 
	"ESD.WARN.2  ESD3DMY is not allowed in 5V process. ")  
) ; 
if(!(HIGH_VOLTAGE == 5) then
 errorLayer( geomCat(esd) 
	"ESD.WARN.3  ESD3DMY is not allowed in processes except 5V. ")  
) ; 
) ; 
if((HIGH_VOLTAGE == 5) then
/*  ESD checks */
/* =========== */
 drc( esd   width < 0.6  withCornerTouch 
	"ESD.W.1  Minimum esd width < 0.6 ")  
 drc( esd  0 <  sepNotch < 0.6  
	"ESD.S.1  Minimum esd space < 0.6 ")  
 drc( esd pp 0 < sep < 0.3  shielded withIntersection withSingularPoint 
	"ESD.S.2  Minimum space between ESD and NP or PP < 0.3 ")  
 drc( esd np  sep < 0.3  shielded withIntersection withSingularPoint 
	"ESD.S.2 2  Minimum space between ESD and NP or PP < 0.3 ")  
 esds2_x = drc( esd pp  sep < 0.001  shielded withIntersection edgeb )
 esds21_y = geomSize(esds2_x 0.001 edges)   
 errorLayer( geomAndNot(esds21_y geomButtOrOver(esds21_y npod )) 
	"ESD.S.2 3  Minimum space between ESD and NP or PP < 0.3 ")  
 drc( esd npod  sep < 0.6  shielded withIntersection withSingularPoint 
	"ESD.C.1  Minimum clearance from an ESD to an NP OD < 0.6 ")  
 drc( esd gate_w  enc < 0.45  shielded withIntersection 
	"ESD.C.2  Minimum clearance from an ESD to a N-ch PO gate < 0.45 ")  
 errorLayer( geomStraddle( all_gate esd  ) 
	"ESD.C.2 2  Minimum clearance from an ESD to a N-ch PO gate < 0.45 ")  
 drc( esd od 0 < ovlp < 0.45  shielded withIntersection withSingularPoint 
	"ESD.O.1  Minimum overlap from an ESD edge to an OD region < 0.45 ")  
 esdc4_x = geomButtOrOver( npod esd  )   
 drc( esd esdc4_x  sep < 0.6  shielded withIntersection withSingularPoint 
	"ESD.C.4  Min. space from ESD to ESD OD < 0.6 ")  
 drc( esd od  enc < 0.25  shielded withIntersection withSingularPoint 
	"ESD.E.1  Minimum extension of an ESD region beyond an ESD OD < 0.25 ")  
 errorLayer( geomInside( esd od  ) 
	"ESD.E.1 2  Minimum extension of an ESD region beyond an ESD OD < 0.25 ")  
/*  ESD.C.5 is not necessary to check */
 esdr1_a = geomAnd(esd poly)  
 errorLayer( geomAnd(esdr1_a pp) 
	"ESD.R.1  ESD and PP not allowed on same POLY region ") 
 all_gate_and1 =  geomAnd(all_gate pp)  
 errorLayer( geomAnd(esd all_gate_and1) 
	"ESD.R.2  ESD is for 5.0V NMOS only ") 
 all_gate_and2 =  geomAnd(all_gate np)  
 all_gate_and21 =  geomAndNot(all_gate_and2 od2)  
 errorLayer( geomAnd(esd all_gate_and21) 
	"ESD.R.2 2  ESD is for 5.0V NMOS only ") 
) ; 
/*  Latch-Up CHECKS */
/* ================ */
 pores_or1 =  geomOr(pores odres)  
 rh = geomButtOrOver( pores_or1 rpo  )   
 dmn2v_or1 =  geomOr(dmn2v dmp2v)  
 rpdmy = geomOr(dmn2v_or1 ffod)  
 rpdmyi = geomAndNot(rpdmy geomButtOrOver(rpdmy rpoi ))   
 rpo_rpdmy = geomOr(rpoi rpdmyi)  
 nsdc = geomAndNot(nsdi rpo_rpdmy)  /*  NMOS source/drain for connection */
 psdc = geomAndNot(psdi rpo_rpdmy)  /*  PMOS source/drain for connection */
 rwi = geomInside( pweli dnwi  )   
 nweli_iact1 =  geomButtOrOver( nweli rwdmy  )  /*  NWR terminal */ 
 nwrit = geomAndNot(nweli_iact1 rwdmy)  /*  NWR terminal */
 srm = geomCat(excl)   
 ubmi_not1 =  geomAndNot(ubmi geomButtOrOver(ubmi ppii ))  /*  UBM lie on Top Metal */ 
 ubmn = geomAndNot(ubmi_not1 geomButtOrOver(ubmi_not1 mdi ))  /*  UBM lie on Top Metal */ 
 ubmd = geomAndNot(ubmi ubmn)  /*  UBM lie on PPI or MD */

/*  Wire-Bond */
/*  Flip-chip */
/*  1_Ground up */
/*  2_RDL (before passivation) */
/* CONNECT M6xd MDxd BY VIADi */
/*  3_PPI (After passivation) */
geomConnect( incremental
	buttOrOver(nwel dnw)
	buttOrOver(m6xd cbi)
	via(cbdi m6xd ubmn)
	buttOrOver(mdxd ubmd)
	via(cbdi m6xd ppii)
	buttOrOver(ppii ubmd)
)
 emptyi = geomAndNot(chip bulk)  
 ntapiu = geomAndNot(ntapi emptyi)  
 ptapiu = geomAndNot(ptapi emptyi)  
 nsdiu = geomAndNot(nsdc emptyi)  
 psdiu = geomAndNot(psdc emptyi)  
 cbiu = geomAndNot(cbi emptyi)  
 ubmniu = geomAndNot(ubmn emptyi)  
 ubmdiu = geomAndNot(ubmd emptyi)  

 pwr_m1iu_by_text = geomGetTexted( m1xd m1pin "AVDDBG" "AVDDR" "AVDWELL" "VDWELL" "VD33APST" "VDD5V" "TAVD33" "VD33PST" "AVDD" "TAVDD" "TAVD33PST" "TAVDDPST" "AVD33B" "VDD" "AVD33G" "DVDD" "AVDDG" "AVDDB" "VDDG" "VDDPST" "VD33REF" "VD33" "AVD33R" "VDDSA" )
 gnd_m1iu_by_text = geomGetTexted( m1xd m1pin "VSSPST" "AVS33R" "AVSSUB" "VSSREF" "VSSAPST" "VS33APST" "DVSS" "AVS33G" "AVSSBG" "TAVSS" "AVS33B" "AVSSB" "GND" "VSSG" "VSSUB" "VSS" "AVSS" "TAVSSPST" "AGND" "AVSSR" "AVSSG" )
 pad_m1iu_by_text = geomGetTexted( m1xd m1pin "*" )
 gnd_m1iu_text    = geomGetTexted( geomTextShape( m1pin 1.0 ) m1pin "AVDDBG" "AVDDR" "AVDWELL" "VDWELL" "VD33APST" "VDD5V" "TAVD33" "VD33PST" "AVDD" "TAVDD" "TAVD33PST" "TAVDDPST" "AVD33B" "VDD" "AVD33G" "DVDD" "AVDDG" "AVDDB" "VDDG" "VDDPST" "VD33REF" "VD33" "AVD33R" "VDDSA" )
 pwr_m1iu_text    = geomGetTexted( geomTextShape( m1pin 1.0 ) m1pin "VSSPST" "AVS33R" "AVSSUB" "VSSREF" "VSSAPST" "VS33APST" "DVSS" "AVS33G" "AVSSBG" "TAVSS" "AVS33B" "AVSSB" "GND" "VSSG" "VSSUB" "VSS" "AVSS" "TAVSSPST" "AGND" "AVSSR" "AVSSG" )

 pwr_m2iu_by_text = geomGetTexted( m2xd m2pin "AVDDBG" "AVDDR" "AVDWELL" "VDWELL" "VD33APST" "VDD5V" "TAVD33" "VD33PST" "AVDD" "TAVDD" "TAVD33PST" "TAVDDPST" "AVD33B" "VDD" "AVD33G" "DVDD" "AVDDG" "AVDDB" "VDDG" "VDDPST" "VD33REF" "VD33" "AVD33R" "VDDSA" )
 gnd_m2iu_by_text = geomGetTexted( m2xd m2pin "VSSPST" "AVS33R" "AVSSUB" "VSSREF" "VSSAPST" "VS33APST" "DVSS" "AVS33G" "AVSSBG" "TAVSS" "AVS33B" "AVSSB" "GND" "VSSG" "VSSUB" "VSS" "AVSS" "TAVSSPST" "AGND" "AVSSR" "AVSSG" )
 pad_m2iu_by_text = geomGetTexted( m2xd m2pin "*" )
 gnd_m2iu_text    = geomGetTexted( geomTextShape( m2pin 1.0 ) m2pin "AVDDBG" "AVDDR" "AVDWELL" "VDWELL" "VD33APST" "VDD5V" "TAVD33" "VD33PST" "AVDD" "TAVDD" "TAVD33PST" "TAVDDPST" "AVD33B" "VDD" "AVD33G" "DVDD" "AVDDG" "AVDDB" "VDDG" "VDDPST" "VD33REF" "VD33" "AVD33R" "VDDSA" )
 pwr_m2iu_text    = geomGetTexted( geomTextShape( m2pin 1.0 ) m2pin "VSSPST" "AVS33R" "AVSSUB" "VSSREF" "VSSAPST" "VS33APST" "DVSS" "AVS33G" "AVSSBG" "TAVSS" "AVS33B" "AVSSB" "GND" "VSSG" "VSSUB" "VSS" "AVSS" "TAVSSPST" "AGND" "AVSSR" "AVSSG" )

 pwr_m3iu_by_text = geomGetTexted( m3xd m3pin "AVDDBG" "AVDDR" "AVDWELL" "VDWELL" "VD33APST" "VDD5V" "TAVD33" "VD33PST" "AVDD" "TAVDD" "TAVD33PST" "TAVDDPST" "AVD33B" "VDD" "AVD33G" "DVDD" "AVDDG" "AVDDB" "VDDG" "VDDPST" "VD33REF" "VD33" "AVD33R" "VDDSA" )
 gnd_m3iu_by_text = geomGetTexted( m3xd m3pin "VSSPST" "AVS33R" "AVSSUB" "VSSREF" "VSSAPST" "VS33APST" "DVSS" "AVS33G" "AVSSBG" "TAVSS" "AVS33B" "AVSSB" "GND" "VSSG" "VSSUB" "VSS" "AVSS" "TAVSSPST" "AGND" "AVSSR" "AVSSG" )
 pad_m3iu_by_text = geomGetTexted( m3xd m3pin "*" )
 gnd_m3iu_text    = geomGetTexted( geomTextShape( m3pin 1.0 ) m3pin "AVDDBG" "AVDDR" "AVDWELL" "VDWELL" "VD33APST" "VDD5V" "TAVD33" "VD33PST" "AVDD" "TAVDD" "TAVD33PST" "TAVDDPST" "AVD33B" "VDD" "AVD33G" "DVDD" "AVDDG" "AVDDB" "VDDG" "VDDPST" "VD33REF" "VD33" "AVD33R" "VDDSA" )
 pwr_m3iu_text    = geomGetTexted( geomTextShape( m3pin 1.0 ) m3pin "VSSPST" "AVS33R" "AVSSUB" "VSSREF" "VSSAPST" "VS33APST" "DVSS" "AVS33G" "AVSSBG" "TAVSS" "AVS33B" "AVSSB" "GND" "VSSG" "VSSUB" "VSS" "AVSS" "TAVSSPST" "AGND" "AVSSR" "AVSSG" )

 pwr_m4iu_by_text = geomGetTexted( m4xd m4pin "AVDDBG" "AVDDR" "AVDWELL" "VDWELL" "VD33APST" "VDD5V" "TAVD33" "VD33PST" "AVDD" "TAVDD" "TAVD33PST" "TAVDDPST" "AVD33B" "VDD" "AVD33G" "DVDD" "AVDDG" "AVDDB" "VDDG" "VDDPST" "VD33REF" "VD33" "AVD33R" "VDDSA" )
 gnd_m4iu_by_text = geomGetTexted( m4xd m4pin "VSSPST" "AVS33R" "AVSSUB" "VSSREF" "VSSAPST" "VS33APST" "DVSS" "AVS33G" "AVSSBG" "TAVSS" "AVS33B" "AVSSB" "GND" "VSSG" "VSSUB" "VSS" "AVSS" "TAVSSPST" "AGND" "AVSSR" "AVSSG" )
 pad_m4iu_by_text = geomGetTexted( m4xd m4pin "*" )
 gnd_m4iu_text    = geomGetTexted( geomTextShape( m4pin 1.0 ) m4pin "AVDDBG" "AVDDR" "AVDWELL" "VDWELL" "VD33APST" "VDD5V" "TAVD33" "VD33PST" "AVDD" "TAVDD" "TAVD33PST" "TAVDDPST" "AVD33B" "VDD" "AVD33G" "DVDD" "AVDDG" "AVDDB" "VDDG" "VDDPST" "VD33REF" "VD33" "AVD33R" "VDDSA" )
 pwr_m4iu_text    = geomGetTexted( geomTextShape( m4pin 1.0 ) m4pin "VSSPST" "AVS33R" "AVSSUB" "VSSREF" "VSSAPST" "VS33APST" "DVSS" "AVS33G" "AVSSBG" "TAVSS" "AVS33B" "AVSSB" "GND" "VSSG" "VSSUB" "VSS" "AVSS" "TAVSSPST" "AGND" "AVSSR" "AVSSG" )

 pwr_m5iu_by_text = geomGetTexted( m5xd m5pin "AVDDBG" "AVDDR" "AVDWELL" "VDWELL" "VD33APST" "VDD5V" "TAVD33" "VD33PST" "AVDD" "TAVDD" "TAVD33PST" "TAVDDPST" "AVD33B" "VDD" "AVD33G" "DVDD" "AVDDG" "AVDDB" "VDDG" "VDDPST" "VD33REF" "VD33" "AVD33R" "VDDSA" )
 gnd_m5iu_by_text = geomGetTexted( m5xd m5pin "VSSPST" "AVS33R" "AVSSUB" "VSSREF" "VSSAPST" "VS33APST" "DVSS" "AVS33G" "AVSSBG" "TAVSS" "AVS33B" "AVSSB" "GND" "VSSG" "VSSUB" "VSS" "AVSS" "TAVSSPST" "AGND" "AVSSR" "AVSSG" )
 pad_m5iu_by_text = geomGetTexted( m5xd m5pin "*" )
 gnd_m5iu_text    = geomGetTexted( geomTextShape( m5pin 1.0 ) m5pin "AVDDBG" "AVDDR" "AVDWELL" "VDWELL" "VD33APST" "VDD5V" "TAVD33" "VD33PST" "AVDD" "TAVDD" "TAVD33PST" "TAVDDPST" "AVD33B" "VDD" "AVD33G" "DVDD" "AVDDG" "AVDDB" "VDDG" "VDDPST" "VD33REF" "VD33" "AVD33R" "VDDSA" )
 pwr_m5iu_text    = geomGetTexted( geomTextShape( m5pin 1.0 ) m5pin "VSSPST" "AVS33R" "AVSSUB" "VSSREF" "VSSAPST" "VS33APST" "DVSS" "AVS33G" "AVSSBG" "TAVSS" "AVS33B" "AVSSB" "GND" "VSSG" "VSSUB" "VSS" "AVSS" "TAVSSPST" "AGND" "AVSSR" "AVSSG" )

 pwr_m6iu_by_text = geomGetTexted( m6xd m6pin "AVDDBG" "AVDDR" "AVDWELL" "VDWELL" "VD33APST" "VDD5V" "TAVD33" "VD33PST" "AVDD" "TAVDD" "TAVD33PST" "TAVDDPST" "AVD33B" "VDD" "AVD33G" "DVDD" "AVDDG" "AVDDB" "VDDG" "VDDPST" "VD33REF" "VD33" "AVD33R" "VDDSA" )
 gnd_m6iu_by_text = geomGetTexted( m6xd m6pin "VSSPST" "AVS33R" "AVSSUB" "VSSREF" "VSSAPST" "VS33APST" "DVSS" "AVS33G" "AVSSBG" "TAVSS" "AVS33B" "AVSSB" "GND" "VSSG" "VSSUB" "VSS" "AVSS" "TAVSSPST" "AGND" "AVSSR" "AVSSG" )
 pad_m6iu_by_text = geomGetTexted( m6xd m6pin "*" )
 ;errorLayer( pad_m6iu_by_text )
 gnd_m6iu_text    = geomGetTexted( geomTextShape( m6pin 1.0 ) m6pin "AVDDBG" "AVDDR" "AVDWELL" "VDWELL" "VD33APST" "VDD5V" "TAVD33" "VD33PST" "AVDD" "TAVDD" "TAVD33PST" "TAVDDPST" "AVD33B" "VDD" "AVD33G" "DVDD" "AVDDG" "AVDDB" "VDDG" "VDDPST" "VD33REF" "VD33" "AVD33R" "VDDSA" )
 pwr_m6iu_text    = geomGetTexted( geomTextShape( m6pin 1.0 ) m6pin "VSSPST" "AVS33R" "AVSSUB" "VSSREF" "VSSAPST" "VS33APST" "DVSS" "AVS33G" "AVSSBG" "TAVSS" "AVS33B" "AVSSB" "GND" "VSSG" "VSSUB" "VSS" "AVSS" "TAVSSPST" "AGND" "AVSSR" "AVSSG" )

LUP_2 = 20.0
LUP_2_S = 8.0
LUP_3_1 = 3.0
LUP_3_2 = 6.0
LUP_3_3 = 12.0
LUP_3_4 = 23.0
LUP_4 = 0.42
LUP_5_1 = 3.0
LUP_5_2 = 6.0
LUP_5_3 = 12.0
LUP_5_4 = 23.0
LUP_5_4_1 = 40.0
LUP_6 = 30.0
LUP_6_SRAM = 40.0
NW_S_1 = 0.6
 rh_or1 =  geomOr(rh rpdmy)  
 odres_a = geomAnd(odres rh_or1)  
 ntapux = geomAndNot(ntapi geomButtOrOver(ntapi rnwel ))   

/*  Power PAD */
 geomStamp( ntapux ntapi  )
 geomStamp( ptapiu ptapi  )
 geomStamp( nsdiu  nsdi   )
 geomStamp( psdiu  psdi   )
 geomStamp( cbiu   cbi    )
 geomStamp( ubmniu ubmn  )
 geomStamp( ubmdiu ubmd  )

 vdd_cb      = geomNodeRelate( cbiu   ntapux  conn )
 vss_cb      = geomNodeRelate( cbiu   ptapiu  conn )
 vdd_ubmn    = geomNodeRelate( ubmniu ntapux  conn )
 vss_ubmn    = geomNodeRelate( ubmniu ptapiu  conn )
 vdd_ubmd    = geomNodeRelate( ubmdiu ntapux  conn )
 vss_ubmd    = geomNodeRelate( ubmdiu ptapiu  conn )

/*  Signal PAD */
 cbiu_not1 =  geomAndNot(cbiu vdd_cb)  
 io_cb = geomAndNot(cbiu_not1 vss_cb)  
 ubmniu_not1 =  geomAndNot(ubmniu vdd_ubmn)  
 io_ubmn = geomAndNot(ubmniu_not1 vss_ubmn)  
 ubmdiu_not1 =  geomAndNot(ubmdiu vdd_ubmd)  
 io_ubmd = geomAndNot(ubmdiu_not1 vss_ubmd)  
geomStamp(io_cb cbiu)
geomStamp( io_ubmn ubmniu )
geomStamp( io_ubmd ubmdiu )

 psd_pad_1 = geomNodeRelate( psdiu cbiu   conn )
 psd_pad_2 = geomNodeRelate( psdiu ubmniu conn )
 psd_pad_3 = geomNodeRelate( psdiu ubmdiu conn )
 psd_pad   = geomOr( psd_pad_1 psd_pad_2 psd_pad_3 )

 nsd_pad_1 = geomNodeRelate( nsdiu cbiu   conn )
 nsd_pad_2 = geomNodeRelate( nsdiu ubmniu conn )
 nsd_pad_3 = geomNodeRelate( nsdiu ubmdiu conn )
 nsd_pad   = geomOr( nsd_pad_1 nsd_pad_2 nsd_pad_3 )

 psd_iopad1    = geomNodeRelate( psdiu io_cb conn )
 psd_iopad2    = geomNodeRelate( psdiu io_ubmn conn )
 psd_iopad3    = geomNodeRelate( psdiu io_ubmd conn )
 psd_iopad     = geomOr( psd_iopad1 psd_iopad2 psd_iopad3 )


 nsd_iopad1    = geomNodeRelate( nsdiu io_cb   conn )
 nsd_iopad2    = geomNodeRelate( nsdiu io_ubmn conn )
 nsd_iopad3    = geomNodeRelate( nsdiu io_ubmd conn )
 nsd_iopad     = geomOr( nsd_iopad1 nsd_iopad2 nsd_iopad3 )

 vdd_vss_dummy = geomOr(vdddmy vssdmy)  
 cb_dummy = geomButtOrOver( cbiu vdd_vss_dummy  )   
 ubmn_dummy = geomButtOrOver( ubmniu vdd_vss_dummy  )   
 ubmd_dummy = geomButtOrOver( ubmdiu vdd_vss_dummy  )   
 cubd_dummy = geomOr( cb_dummy ubmn_dummy ubmd_dummy )

 geomStamp( cb_dummy cbiu)
 geomStamp( ubmn_dummy ubmniu )
 geomStamp( ubmd_dummy ubmdiu )

 psd_vdd_vss_pad_dummy1 = geomNodeRelate( psdiu cb_dummy conn )
 psd_vdd_vss_pad_dummy2 = geomNodeRelate( psdiu ubmn_dummy conn )
 psd_vdd_vss_pad_dummy3 = geomNodeRelate( psdiu ubmd_dummy conn )
 psd_vdd_vss_pad_dummy = geomOr( psd_vdd_vss_pad_dummy1 psd_vdd_vss_pad_dummy2 psd_vdd_vss_pad_dummy3 ) 

 nsd_vdd_vss_pad_dummy1 = geomNodeRelate( nsdiu cb_dummy conn )
 nsd_vdd_vss_pad_dummy2 = geomNodeRelate( nsdiu ubmn_dummy conn )
 nsd_vdd_vss_pad_dummy3 = geomNodeRelate( nsdiu ubmd_dummy conn )
 nsd_vdd_vss_pad_dummy = geomOr( nsd_vdd_vss_pad_dummy1 nsd_vdd_vss_pad_dummy2 nsd_vdd_vss_pad_dummy3 ) 

 
psd_pad_text_m6 = geomNodeRelate( psdiu pad_m6iu_by_text conn )
psd_pad_text_m5 = geomNodeRelate( psdiu pad_m5iu_by_text conn )
psd_pad_text_m4 = geomNodeRelate( psdiu pad_m4iu_by_text conn )
psd_pad_text_m3 = geomNodeRelate( psdiu pad_m3iu_by_text conn )
psd_pad_text_m2 = geomNodeRelate( psdiu pad_m2iu_by_text conn )
psd_pad_text_m1 = geomNodeRelate( psdiu pad_m1iu_by_text conn )
psd_pad_text = geomOr( psd_pad_text_m6 psd_pad_text_m5 psd_pad_text_m4 psd_pad_text_m3 psd_pad_text_m2 psd_pad_text_m1 )
/*
     processAntenna(
                    gate((psdiu psdiu))
                    antenna( psdiu )
                    ratio = pad_m6iu_by_text.area + pad_m5iu_by_text.area + pad_m4iu_by_text.area + pad_m3iu_by_text.area + pad_m2iu_by_text.area + pad_m1iu_by_text.area 
         	    ERR = drcAntenna( psdiu ( psdiu ) ratio keep > 0 suppressErrorMessage )
                   )
    psd_pad_text = geomOr( ERR_psdiu )
*/ 

nsd_pad_text_m6 = geomNodeRelate( nsdiu pad_m6iu_by_text conn )
nsd_pad_text_m5 = geomNodeRelate( nsdiu pad_m5iu_by_text conn )
nsd_pad_text_m4 = geomNodeRelate( nsdiu pad_m4iu_by_text conn )
nsd_pad_text_m3 = geomNodeRelate( nsdiu pad_m3iu_by_text conn )
nsd_pad_text_m2 = geomNodeRelate( nsdiu pad_m2iu_by_text conn )
nsd_pad_text_m1 = geomNodeRelate( nsdiu pad_m1iu_by_text conn )
nsd_pad_text = geomOr( nsd_pad_text_m6 nsd_pad_text_m5 nsd_pad_text_m4 nsd_pad_text_m3 nsd_pad_text_m2 nsd_pad_text_m1 )
/*
     processAntenna(
                    gate((nsdiu nsdiu))
                    antenna( nsdiu )
                    ratio = pad_m6iu_by_text.area + pad_m5iu_by_text.area + pad_m4iu_by_text.area + pad_m3iu_by_text.area + pad_m2iu_by_text.area + pad_m1iu_by_text.area 
         	    ERR = drcAntenna( nsdiu ( nsdiu ) ratio keep > 0 suppressErrorMessage )
                   )
    nsd_pad_text = geomOr( ERR_nsdiu )
*/

psd_vdd_pad_text_m6 = geomNodeRelate( psdiu pwr_m6iu_by_text conn )
psd_vdd_pad_text_m5 = geomNodeRelate( psdiu pwr_m5iu_by_text conn )
psd_vdd_pad_text_m4 = geomNodeRelate( psdiu pwr_m4iu_by_text conn )
psd_vdd_pad_text_m3 = geomNodeRelate( psdiu pwr_m3iu_by_text conn )
psd_vdd_pad_text_m2 = geomNodeRelate( psdiu pwr_m2iu_by_text conn )
psd_vdd_pad_text_m1 = geomNodeRelate( psdiu pwr_m1iu_by_text conn )
psd_vdd_pad_text = geomOr( psd_vdd_pad_text_m6 psd_vdd_pad_text_m5 psd_vdd_pad_text_m4 psd_vdd_pad_text_m3 psd_vdd_pad_text_m2 psd_vdd_pad_text_m1 )

psd_vss_pad_text_m6 = geomNodeRelate( psdiu gnd_m6iu_by_text conn )
psd_vss_pad_text_m5 = geomNodeRelate( psdiu gnd_m5iu_by_text conn )
psd_vss_pad_text_m4 = geomNodeRelate( psdiu gnd_m4iu_by_text conn )
psd_vss_pad_text_m3 = geomNodeRelate( psdiu gnd_m3iu_by_text conn )
psd_vss_pad_text_m2 = geomNodeRelate( psdiu gnd_m2iu_by_text conn )
psd_vss_pad_text_m1 = geomNodeRelate( psdiu gnd_m1iu_by_text conn )
psd_vss_pad_text = geomOr( psd_vss_pad_text_m6 psd_vss_pad_text_m5 psd_vss_pad_text_m4 psd_vss_pad_text_m3 psd_vss_pad_text_m2 psd_vss_pad_text_m1 )

psd_vdd_vss_pad_text = geomOr( psd_vdd_pad_text psd_vss_pad_text )
/*
     processAntenna(
                    gate((psdiu psdiu))
                    antenna( psdiu )
                    ratio = pwr_m6iu_by_text.area + pwr_m5iu_by_text.area + pwr_m4iu_by_text.area + pwr_m3iu_by_text.area + pwr_m2iu_by_text.area + pwr_m1iu_by_text.area + gnd_m6iu_by_text.area + gnd_m5iu_by_text.area + gnd_m4iu_by_text.area + gnd_m3iu_by_text.area + gnd_m2iu_by_text.area + gnd_m1iu_by_text.area
         	    ERR = drcAntenna( psdiu ( psdiu ) ratio keep > 0 suppressErrorMessage )
                   )
    psd_vdd_vss_pad_text = geomOr( ERR_psdiu )
*/
nsd_vdd_pad_text_m6 = geomNodeRelate( nsdiu pwr_m6iu_by_text conn )
nsd_vdd_pad_text_m5 = geomNodeRelate( nsdiu pwr_m5iu_by_text conn )
nsd_vdd_pad_text_m4 = geomNodeRelate( nsdiu pwr_m4iu_by_text conn )
nsd_vdd_pad_text_m3 = geomNodeRelate( nsdiu pwr_m3iu_by_text conn )
nsd_vdd_pad_text_m2 = geomNodeRelate( nsdiu pwr_m2iu_by_text conn )
nsd_vdd_pad_text_m1 = geomNodeRelate( nsdiu pwr_m1iu_by_text conn )
nsd_vdd_pad_text = geomOr( nsd_vdd_pad_text_m6 nsd_vdd_pad_text_m5 nsd_vdd_pad_text_m4 nsd_vdd_pad_text_m3 nsd_vdd_pad_text_m2 nsd_vdd_pad_text_m1 )

nsd_vss_pad_text_m6 = geomNodeRelate( nsdiu gnd_m6iu_by_text conn )
nsd_vss_pad_text_m5 = geomNodeRelate( nsdiu gnd_m5iu_by_text conn )
nsd_vss_pad_text_m4 = geomNodeRelate( nsdiu gnd_m4iu_by_text conn )
nsd_vss_pad_text_m3 = geomNodeRelate( nsdiu gnd_m3iu_by_text conn )
nsd_vss_pad_text_m2 = geomNodeRelate( nsdiu gnd_m2iu_by_text conn )
nsd_vss_pad_text_m1 = geomNodeRelate( nsdiu gnd_m1iu_by_text conn )
nsd_vss_pad_text = geomOr( nsd_vss_pad_text_m6 nsd_vss_pad_text_m5 nsd_vss_pad_text_m4 nsd_vss_pad_text_m3 nsd_vss_pad_text_m2 nsd_vss_pad_text_m1 )

nsd_vdd_vss_pad_text = geomOr( nsd_vdd_pad_text nsd_vss_pad_text )
/*
    processAntenna(
                    gate((nsdiu nsdiu))
                    antenna( nsdiu )
                    ratio = pwr_m6iu_by_text.area + pwr_m5iu_by_text.area + pwr_m4iu_by_text.area + pwr_m3iu_by_text.area + pwr_m2iu_by_text.area + pwr_m1iu_by_text.area + gnd_m6iu_by_text.area + gnd_m5iu_by_text.area + gnd_m4iu_by_text.area + gnd_m3iu_by_text.area + gnd_m2iu_by_text.area + gnd_m1iu_by_text.area
         	    ERR = drcAntenna( nsdiu ( nsdiu ) ratio keep > 0 suppressErrorMessage )
                   )
    nsd_vdd_vss_pad_text = geomOr( ERR_nsdiu )
*/

   pwr_text = geomOr( pwr_m1iu_text pwr_m2iu_text pwr_m3iu_text pwr_m4iu_text pwr_m5iu_text pwr_m6iu_text )
   gnd_text = geomOr( gnd_m1iu_text gnd_m2iu_text gnd_m3iu_text gnd_m4iu_text gnd_m5iu_text gnd_m6iu_text )



if((CHECK_LATCHUP_BY_TEXT == 1) then
    psd_iopad_all = geomAndNot( geomOr( psd_iopad psd_pad_text ) geomOr( psd_vdd_vss_pad_text psd_vdd_vss_pad_dummy ) )
    nsd_iopad_all = geomAndNot( geomOr( nsd_iopad nsd_pad_text ) geomOr( nsd_vdd_vss_pad_text nsd_vdd_vss_pad_dummy ) )
    sd_iopad = geomOr( psd_iopad_all nsd_iopad_all) 
    mos = geomButtOrOver( dact all_gate  )  
    pmos_filter = geomCat(emptyi)   
    nmos_filter = geomCat(emptyi) 
  else
    psd_iopad_all = geomAndNot(psd_iopad psd_vdd_vss_pad_dummy)  
    nsd_iopad_all = geomAndNot(nsd_iopad nsd_vdd_vss_pad_dummy)  
    sd_iopad = geomOr(psd_iopad_all nsd_iopad_all)  
    mos = geomButtOrOver( dact all_gate  )   
    pmos_filter_1 = geomButtOrOver( mos psd_pad )
    geomStamp( psd_pad psdiu )
    geomStamp( pmos_filter_1 psd_pad buttOrOver )
    pmos_filter_2 = geomButtOrOver( pmos_filter_1 psd_pad diffNet )
    pmos_filter = geomAndNot( pmos_filter_1 pmos_filter_2 )
    nmos_filter_1 = geomButtOrOver( mos nsd_pad )
    geomStamp( nsd_pad nsdiu )
    geomStamp( nmos_filter_1 nsd_pad buttOrOver )
    nmos_filter_2 = geomButtOrOver( nmos_filter_1 nsd_pad diffNet )
    nmos_filter = geomAndNot( nmos_filter_1 nmos_filter_2 )
  ) ; end of CHECK_LATCHUP_BY_TEXT

 dummy_mos = geomAvoiding( geomAvoiding( mos co ) geomButtOrOver( poly co ) )
 post_driver_dummy_layers = geomCat(sdi)   
 dact_real = geomAvoiding( geomAvoiding( dact odres_a ) rnwel )
 pact_real = geomAnd(pact dact_real)  
 nact_real = geomAnd(nact dact_real)  

/*  ESD device [covered by dummy layers] */
 post_driver_act1 = geomAnd(dact_real post_driver_dummy_layers)  /*  MOS with active region in SDI */
/*  ESD device [connected to Signal PAD but not connected to one PAD only] */
  post_driver_act2 = geomButtOrOver(geomAndNot( geomAndNot( dact_real pmos_filter ) nmos_filter ) sd_iopad )

if((CHECK_LATCHUP_BY_PAD_CONNECTION == 1) then
 post_driver_act = geomOr(post_driver_act1 post_driver_act2)  
else;
 post_driver_act = geomCat(post_driver_act1)   
) ; 
/*  For LUP.1/LUP.2/LUP.4 - GuardRing */
/* ==================================== */
 nw_inside_guard_ring_pre1 = geomAndNot(nweli ntapi)  
 nw_inside_guard_ring_pre2 = geomAndNot(nw_inside_guard_ring_pre1 geomGetEdge(nw_inside_guard_ring_pre1 butting ntapi))   
 nw_inside_guard_ring_pre21 = geomSize(nw_inside_guard_ring_pre2 0.005 edges)
 nw_inside_guard_ring = geomAndNot( nw_inside_guard_ring_pre1 geomButtOrCoin( nw_inside_guard_ring_pre1 nw_inside_guard_ring_pre21 ))   
 pw_inside_guard_ring_pre1 = geomAndNot(pweli ptapi)  
 pw_inside_guard_ring_pre2 = geomAndNot(pw_inside_guard_ring_pre1 geomGetEdge(pw_inside_guard_ring_pre1 butting ptapi))   
 pw_inside_guard_ring_pre21 = geomSize(pw_inside_guard_ring_pre2 0.005 edges)
 pw_inside_guard_ring = geomAndNot( pw_inside_guard_ring_pre1 geomButtOrCoin( pw_inside_guard_ring_pre1 pw_inside_guard_ring_pre21 ))   
ntapi_out1 = geomHoles(ntapi innermost )
 ntapi_ho1 =  ntapi_out1  
 ntapi_ho1_ins1 =  geomInside( ntapi_ho1 nweli  )   
 ntap_guard_ring_hole = geomOr(ntapi_ho1_ins1 nw_inside_guard_ring)  
ptapi_out1 = geomHoles(ptapi innermost )
 ptapi_ho1 =  ptapi_out1  
 ptapi_ho1_ins1 =  geomInside( ptapi_ho1 pweli  )   
 ptap_guard_ring_hole = geomOr(ptapi_ho1_ins1 pw_inside_guard_ring)  
/*  For LUP.1 - I/O PAD N/P ACTIVE */
/* ================================= */
 post_driver_act1 =  geomButtOrOver( post_driver_act psdiu  )   
 post_driver_pact = geomAndNot(post_driver_act1 geomInside(post_driver_act1 lupwdmy ))   
 post_driver_act2 =  geomButtOrOver( post_driver_act nsdiu  )   
 post_driver_nact = geomAndNot(post_driver_act2 geomInside(post_driver_act2 lupwdmy ))   
/*  For LUP.3 */
/* ================== */
 post_driver_pmos = geomButtOrOver( post_driver_pact all_gate  )   
post_driver_pmos_nw = geomCat( post_driver_pmos )
geomStamp(post_driver_pmos_nw nwel)  
 post_driver_pmos_nw_hv = geomButtOrOver( post_driver_pmos_nw hvgt  )   
 post_driver_pmos_nw_33v = geomButtOrOver( post_driver_pmos_nw_hv od2i  )   
 post_driver_pmos_nw_25v = geomButtOrOver( post_driver_pmos_nw_hv od2i  )   
 post_driver_pmos_nw_50v = geomButtOrOver( post_driver_pmos_nw_hv od2i  )   
 post_driver_pmos_nw_lv = geomAndNot(post_driver_pmos_nw post_driver_pmos_nw_hv)  
post_driver_pmos_nwi = geomCat( post_driver_pmos )
geomStamp(post_driver_pmos_nwi nweli)  
 post_driver_pmos_nwi_hv = geomButtOrOver( post_driver_pmos_nwi hvgt  )   
 post_driver_pmos_nwi_33v = geomButtOrOver( post_driver_pmos_nwi_hv od2i  )   
 post_driver_pmos_nwi_25v = geomButtOrOver( post_driver_pmos_nwi_hv od2i  )   
 post_driver_pmos_nwi_50v = geomButtOrOver( post_driver_pmos_nwi_hv od2i  )   
 post_driver_pmos_nwi_lv = geomAndNot(post_driver_pmos_nwi post_driver_pmos_nwi_hv)  
 post_driver_nmos = geomButtOrOver( post_driver_nact all_gate  )   
 post_driver_nmos1 =  geomInside( post_driver_nmos dnw  )   
post_driver_nmos_rw = geomCat( post_driver_nmos1 )
geomStamp(post_driver_nmos_rw dnw)  
 post_driver_nmos_pw = geomAndNot(post_driver_nmos post_driver_nmos_rw)  
 post_driver_nmos_rw_hv = geomButtOrOver( post_driver_nmos_rw hvgt  )   
 post_driver_nmos_rw_33v = geomButtOrOver( post_driver_nmos_rw_hv od2i  )   
 post_driver_nmos_rw_25v = geomButtOrOver( post_driver_nmos_rw_hv od2i  )   
 post_driver_nmos_rw_50v = geomButtOrOver( post_driver_nmos_rw_hv od2i  )   
 post_driver_nmos_rw_lv = geomAndNot(post_driver_nmos_rw post_driver_nmos_rw_hv)  
 post_driver_nmos_pw_hv = geomButtOrOver( post_driver_nmos_pw hvgt  )   
 post_driver_nmos_pw_33v = geomButtOrOver( post_driver_nmos_pw_hv od2i  )   
 post_driver_nmos_pw_25v = geomButtOrOver( post_driver_nmos_pw_hv od2i  )   
 post_driver_nmos_pw_50v = geomButtOrOver( post_driver_nmos_pw_hv od2i  )   
 post_driver_nmos_pw_lv = geomAndNot(post_driver_nmos_pw post_driver_nmos_pw_hv)  
dnwc = geomCat( dnw )
geomStamp(dnwc nweli)  
 post_driver_nmos2 =  geomInside( post_driver_nmos dnwc  )   
post_driver_nmos_rwi = geomCat( post_driver_nmos2 )
geomStamp(post_driver_nmos_rwi dnwc)  
 post_driver_nmos_rwi_hv = geomButtOrOver( post_driver_nmos_rwi hvgt  )   
 post_driver_nmos_rwi_33v = geomButtOrOver( post_driver_nmos_rwi_hv od2i  )   
 post_driver_nmos_rwi_25v = geomButtOrOver( post_driver_nmos_rwi_hv od2i  )   
 post_driver_nmos_rwi_50v = geomButtOrOver( post_driver_nmos_rwi_hv od2i  )   
 post_driver_nmos_rwi_lv = geomAndNot(post_driver_nmos_rwi post_driver_nmos_rwi_hv)  
 post_driver_mos = geomOr(post_driver_nmos post_driver_pmos)  
 beside_post_driver = geomSize( post_driver_mos LUP_2 noClipAcute )   
 nact_real_iact1 =  geomButtOrOver( nact_real all_gate  )   
 nact_real_iact11 =  geomAndNot(nact_real_iact1 geomOutside(nact_real_iact1 beside_post_driver ))   
 nact_real_iact111 =  geomAndNot(nact_real_iact11 post_driver_nact)  
 beside_post_driver_nmos = geomAndNot(nact_real_iact111 dummy_mos)  
 pact_real_iact1 =  geomButtOrOver( pact_real all_gate  )   
 pact_real_iact11 =  geomAndNot(pact_real_iact1 geomOutside(pact_real_iact1 beside_post_driver ))   
 pact_real_iact111 =  geomAndNot(pact_real_iact11 post_driver_pact)  
 beside_post_driver_pmos = geomAndNot(pact_real_iact111 dummy_mos)  
/*  for LUP.5.4 */
 beside_post_driver_1 = geomSize( post_driver_mos LUP_5_4_1 noClipAcute )   
 nact_real_iact2 =  geomButtOrOver( nact_real all_gate  )   
 nact_real_iact21 =  geomAndNot(nact_real_iact2 geomOutside(nact_real_iact2 beside_post_driver_1 ))   
 nact_real_iact211 =  geomAndNot(nact_real_iact21 post_driver_nact)  
 beside_post_driver_nmos_1 = geomAndNot(nact_real_iact211 dummy_mos)  
 pact_real_iact2 =  geomButtOrOver( pact_real all_gate  )   
 pact_real_iact21 =  geomAndNot(pact_real_iact2 geomOutside(pact_real_iact2 beside_post_driver_1 ))   
 pact_real_iact211 =  geomAndNot(pact_real_iact21 post_driver_pact)  
 beside_post_driver_pmos_1 = geomAndNot(pact_real_iact211 dummy_mos)  
beside_post_driver_pmos_nw = geomCat( beside_post_driver_pmos )
geomStamp(beside_post_driver_pmos_nw nwel)  
 beside_post_driver_pmos_nw_hv = geomButtOrOver( beside_post_driver_pmos_nw hvgt  )   
 beside_post_driver_pmos_nw_33v = geomButtOrOver( beside_post_driver_pmos_nw_hv od2i  )   
 beside_post_driver_pmos_nw_25v = geomButtOrOver( beside_post_driver_pmos_nw_hv od2i  )   
 beside_post_driver_pmos_nw_50v = geomButtOrOver( beside_post_driver_pmos_nw_hv od2i  )   
 beside_post_driver_pmos_nw_lv = geomAndNot(beside_post_driver_pmos_nw beside_post_driver_pmos_nw_hv)  
beside_post_driver_pmos_nwi = geomCat( beside_post_driver_pmos )
geomStamp(beside_post_driver_pmos_nwi nweli)  
 beside_post_driver_pmos_nwi_hv = geomButtOrOver( beside_post_driver_pmos_nwi hvgt  )   
 beside_post_driver_pmos_nwi_33v = geomButtOrOver( beside_post_driver_pmos_nwi_hv od2i  )   
 beside_post_driver_pmos_nwi_25v = geomButtOrOver( beside_post_driver_pmos_nwi_hv od2i  )   
 beside_post_driver_pmos_nwi_50v = geomButtOrOver( beside_post_driver_pmos_nwi_hv od2i  )   
 beside_post_driver_pmos_nwi_lv = geomAndNot(beside_post_driver_pmos_nwi beside_post_driver_pmos_nwi_hv)  
 beside_post_driver_nmos1 =  geomInside( beside_post_driver_nmos dnw  )   
beside_post_driver_nmos_rw = geomCat( beside_post_driver_nmos1 )
geomStamp(beside_post_driver_nmos_rw dnw)  
 beside_post_driver_nmos_pw = geomAndNot(beside_post_driver_nmos beside_post_driver_nmos_rw)  
 beside_post_driver_nmos_rw_hv = geomButtOrOver( beside_post_driver_nmos_rw hvgt  )   
 beside_post_driver_nmos_rw_33v = geomButtOrOver( beside_post_driver_nmos_rw_hv od2i  )   
 beside_post_driver_nmos_rw_25v = geomButtOrOver( beside_post_driver_nmos_rw_hv od2i  )   
 beside_post_driver_nmos_rw_50v = geomButtOrOver( beside_post_driver_nmos_rw_hv od2i  )   
 beside_post_driver_nmos_rw_lv = geomAndNot(beside_post_driver_nmos_rw beside_post_driver_nmos_rw_hv)  
 beside_post_driver_nmos_pw_hv = geomButtOrOver( beside_post_driver_nmos_pw hvgt  )   
 beside_post_driver_nmos_pw_33v = geomButtOrOver( beside_post_driver_nmos_pw_hv od2i  )   
 beside_post_driver_nmos_pw_25v = geomButtOrOver( beside_post_driver_nmos_pw_hv od2i  )   
 beside_post_driver_nmos_pw_50v = geomButtOrOver( beside_post_driver_nmos_pw_hv od2i  )   
 beside_post_driver_nmos_pw_lv = geomAndNot(beside_post_driver_nmos_pw beside_post_driver_nmos_pw_hv)  
 beside_post_driver_nmos2 =  geomInside( beside_post_driver_nmos dnwc  )   
beside_post_driver_nmos_rwi = geomCat( beside_post_driver_nmos2 )
geomStamp(beside_post_driver_nmos_rwi dnwc)  
 beside_post_driver_nmos_rwi_hv = geomButtOrOver( beside_post_driver_nmos_rwi hvgt  )   
 beside_post_driver_nmos_rwi_33v = geomButtOrOver( beside_post_driver_nmos_rwi_hv od2i  )   
 beside_post_driver_nmos_rwi_25v = geomButtOrOver( beside_post_driver_nmos_rwi_hv od2i  )   
 beside_post_driver_nmos_rwi_50v = geomButtOrOver( beside_post_driver_nmos_rwi_hv od2i  )   
 beside_post_driver_nmos_rwi_lv = geomAndNot(beside_post_driver_nmos_rwi beside_post_driver_nmos_rwi_hv)  
/*  for LUP.5.4  */
beside_post_driver_pmos_nw_1 = geomCat( beside_post_driver_pmos_1 )
geomStamp(beside_post_driver_pmos_nw_1 nwel)  
beside_post_driver_pmos_nwi_1 = geomCat( beside_post_driver_pmos_1 )
geomStamp(beside_post_driver_pmos_nwi_1 nweli)  
 beside_post_driver_nmos_11 =  geomInside( beside_post_driver_nmos_1 dnw  )   
beside_post_driver_nmos_rw_1 = geomCat( beside_post_driver_nmos_11 )
geomStamp(beside_post_driver_nmos_rw_1 dnw)  
 beside_post_driver_nmos_pw_1 = geomAndNot(beside_post_driver_nmos_1 beside_post_driver_nmos_rw_1)  
 beside_post_driver_nmos_12 =  geomInside( beside_post_driver_nmos_1 dnwc  )   
beside_post_driver_nmos_rwi_1 = geomCat( beside_post_driver_nmos_12 )
geomStamp(beside_post_driver_nmos_rwi_1 dnwc)  
if((GUIDELINE_LUP == 1) then
 errorLayer( geomAndNot(post_driver_nact geomInside(post_driver_nact ptap_guard_ring_hole )) 
	"LUP.1g  Any N+Active or an N+Active cluster connected to an I/O pad must be surrounded by a P+ guard-ring. Any P+Active or a P+Active cluster connected to an I/O pad must be surrounded by a N+ guard-ring ")  
 errorLayer( geomAndNot(post_driver_pact geomInside(post_driver_pact ntap_guard_ring_hole )) 
	"LUP.1g 2  Any N+Active or an N+Active cluster connected to an I/O pad must be surrounded by a P+ guard-ring. Any P+Active or a P+Active cluster connected to an I/O pad must be surrounded by a N+ guard-ring ")  
 lup2g_x = drc( post_driver_pmos_nw beside_post_driver_nmos_rw  sep < LUP_2_S  sameNet withIntersection withSingularPoint )
 lup2g1_y = drc( post_driver_pmos_nwi beside_post_driver_nmos_rwi  sep < LUP_2_S  diffNet withIntersection withSingularPoint )
 beside_post_driver_nmos_rwi1 =  geomAndNot(beside_post_driver_nmos_rwi geomButtOrOver(beside_post_driver_nmos_rwi lup2g_x ))   
 lup2g2_beside_post_driver_nmos_waive = geomAndNot(beside_post_driver_nmos_rwi1 geomButtOrOver(beside_post_driver_nmos_rwi1 lup2g1_y ))   
 beside_post_driver_nmos3 =  geomAndNot(beside_post_driver_nmos lup2g2_beside_post_driver_nmos_waive)  
 errorLayer( geomAndNot(beside_post_driver_nmos3 geomInside(beside_post_driver_nmos3 ptap_guard_ring_hole )) 
	"LUP.2g  Within =LUP_2 um space from the MOS connected to an I/O pad, a P+ guard-ring is required to surround an NMOS or an NMOS cluster. And an N+ guard-ring is required to surround a PMOS or a PMOS cluster. ")  
 errorLayer( geomAndNot(beside_post_driver_pmos geomInside(beside_post_driver_pmos ntap_guard_ring_hole )) 
	"LUP.2g 2  Within =LUP_2 um space from the MOS connected to an I/O pad, a P+ guard-ring is required to surround an NMOS or an NMOS cluster. And an N+ guard-ring is required to surround a PMOS or a PMOS cluster. ")  
if((CORE_VOLTAGE == 1.8) then
 drc( post_driver_nmos_pw_lv post_driver_pmos_nw_lv  sep < LUP_3_1  shielded withIntersection withSingularPoint 
	"LUP.3.1g_1.8V  For the 1.8V or 1.5V N/PMOS which connects to an I/O pad, space between the NMOS and the PMOS.Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= =LUP_3_1 um ")  
 drc( post_driver_nmos_rw_lv post_driver_pmos_nw_lv  sep < LUP_3_1  sameNet shielded withIntersection withSingularPoint 
	"LUP.3.1g_1.8V 2  For the 1.8V or 1.5V N/PMOS which connects to an I/O pad, space between the NMOS and the PMOS.Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= =LUP_3_1 um ")  
 drc( post_driver_nmos_rwi_lv post_driver_pmos_nwi_lv  sep < LUP_3_1  diffNet shielded withIntersection withSingularPoint 
	"LUP.3.1g_1.8V 3  For the 1.8V or 1.5V N/PMOS which connects to an I/O pad, space between the NMOS and the PMOS.Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= =LUP_3_1 um ")  
) ; 
if((CORE_VOLTAGE == 1.5) then
 drc( post_driver_nmos_pw_lv post_driver_pmos_nw_lv  sep < LUP_3_1  shielded withIntersection withSingularPoint 
	"LUP.3.1g_1.5V  For the 1.8V or 1.5V N/PMOS which connects to an I/O pad, space between the NMOS and the PMOS.Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= =LUP_3_1 um ")  
 drc( post_driver_nmos_rw_lv post_driver_pmos_nw_lv  sep < LUP_3_1  sameNet shielded withIntersection withSingularPoint 
	"LUP.3.1g_1.5V 2  For the 1.8V or 1.5V N/PMOS which connects to an I/O pad, space between the NMOS and the PMOS.Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= =LUP_3_1 um ")  
 drc( post_driver_nmos_rwi_lv post_driver_pmos_nwi_lv  sep < LUP_3_1  diffNet shielded withIntersection withSingularPoint 
	"LUP.3.1g_1.5V 3  For the 1.8V or 1.5V N/PMOS which connects to an I/O pad, space between the NMOS and the PMOS.Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= =LUP_3_1 um ")  
) ; 
if((HIGH_VOLTAGE == 2.5) then
 drc( post_driver_nmos_pw_25v post_driver_pmos_nw_25v  sep < LUP_3_2  shielded withIntersection withSingularPoint 
	"LUP.3.2g_2.5V  For the 2.5V N/PMOS which connects to an I/O pad directly, space between the 2.5V NMOS and the 2.5V/1.5V PMOS, space between the 2.5V PMOS and the 2.5V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.>= =LUP_3_2 um ")  
 drc( post_driver_nmos_pw_25v post_driver_pmos_nw_lv  sep < LUP_3_2  shielded withIntersection withSingularPoint 
	"LUP.3.2g_2.5V 2  For the 2.5V N/PMOS which connects to an I/O pad directly, space between the 2.5V NMOS and the 2.5V/1.5V PMOS, space between the 2.5V PMOS and the 2.5V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.>= =LUP_3_2 um ")  
 drc( post_driver_nmos_pw_lv post_driver_pmos_nw_25v  sep < LUP_3_2  shielded withIntersection withSingularPoint 
	"LUP.3.2g_2.5V 3  For the 2.5V N/PMOS which connects to an I/O pad directly, space between the 2.5V NMOS and the 2.5V/1.5V PMOS, space between the 2.5V PMOS and the 2.5V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.>= =LUP_3_2 um ")  
 drc( post_driver_nmos_rw_25v post_driver_pmos_nw_25v  sep < LUP_3_2  sameNet shielded withIntersection withSingularPoint 
	"LUP.3.2g_2.5V 4  For the 2.5V N/PMOS which connects to an I/O pad directly, space between the 2.5V NMOS and the 2.5V/1.5V PMOS, space between the 2.5V PMOS and the 2.5V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.>= =LUP_3_2 um ")  
 drc( post_driver_nmos_rw_25v post_driver_pmos_nw_lv  sep < LUP_3_2  sameNet shielded withIntersection withSingularPoint 
	"LUP.3.2g_2.5V 5  For the 2.5V N/PMOS which connects to an I/O pad directly, space between the 2.5V NMOS and the 2.5V/1.5V PMOS, space between the 2.5V PMOS and the 2.5V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.>= =LUP_3_2 um ")  
 drc( post_driver_nmos_rw_lv post_driver_pmos_nw_25v  sep < LUP_3_2  sameNet shielded withIntersection withSingularPoint 
	"LUP.3.2g_2.5V 6  For the 2.5V N/PMOS which connects to an I/O pad directly, space between the 2.5V NMOS and the 2.5V/1.5V PMOS, space between the 2.5V PMOS and the 2.5V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.>= =LUP_3_2 um ")  
 drc( post_driver_nmos_rwi_25v post_driver_pmos_nwi_25v  sep < LUP_3_2  diffNet shielded withIntersection withSingularPoint 
	"LUP.3.2g_2.5V 7  For the 2.5V N/PMOS which connects to an I/O pad directly, space between the 2.5V NMOS and the 2.5V/1.5V PMOS, space between the 2.5V PMOS and the 2.5V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.>= =LUP_3_2 um ")  
 drc( post_driver_nmos_rwi_25v post_driver_pmos_nwi_lv  sep < LUP_3_2  diffNet shielded withIntersection withSingularPoint 
	"LUP.3.2g_2.5V 8  For the 2.5V N/PMOS which connects to an I/O pad directly, space between the 2.5V NMOS and the 2.5V/1.5V PMOS, space between the 2.5V PMOS and the 2.5V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.>= =LUP_3_2 um ")  
 drc( post_driver_nmos_rwi_lv post_driver_pmos_nwi_25v  sep < LUP_3_2  diffNet shielded withIntersection withSingularPoint 
	"LUP.3.2g_2.5V 9  For the 2.5V N/PMOS which connects to an I/O pad directly, space between the 2.5V NMOS and the 2.5V/1.5V PMOS, space between the 2.5V PMOS and the 2.5V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.>= =LUP_3_2 um ")  
) ; 
if((HIGH_VOLTAGE == 3.3) then
 drc( post_driver_nmos_pw_33v post_driver_pmos_nw_33v  sep < LUP_3_3  shielded withIntersection withSingularPoint 
	"LUP.3.3g_3.3V  For the 3.3V N/PMOS which connects to an I/O pad directly, space between the 3.3V NMOS and the 3.3V/1.8V/1.5V PMOS, space between the 3.3V PMOS and the 3.3V/1.8V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= =LUP_3_3 um ")  
 drc( post_driver_nmos_pw_33v post_driver_pmos_nw_lv  sep < LUP_3_3  shielded withIntersection withSingularPoint 
	"LUP.3.3g_3.3V 2  For the 3.3V N/PMOS which connects to an I/O pad directly, space between the 3.3V NMOS and the 3.3V/1.8V/1.5V PMOS, space between the 3.3V PMOS and the 3.3V/1.8V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= =LUP_3_3 um ")  
 drc( post_driver_nmos_pw_lv post_driver_pmos_nw_33v  sep < LUP_3_3  shielded withIntersection withSingularPoint 
	"LUP.3.3g_3.3V 3  For the 3.3V N/PMOS which connects to an I/O pad directly, space between the 3.3V NMOS and the 3.3V/1.8V/1.5V PMOS, space between the 3.3V PMOS and the 3.3V/1.8V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= =LUP_3_3 um ")  
 drc( post_driver_nmos_rw_33v post_driver_pmos_nw_33v  sep < LUP_3_3  sameNet shielded withIntersection withSingularPoint 
	"LUP.3.3g_3.3V 4  For the 3.3V N/PMOS which connects to an I/O pad directly, space between the 3.3V NMOS and the 3.3V/1.8V/1.5V PMOS, space between the 3.3V PMOS and the 3.3V/1.8V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= =LUP_3_3 um ")  
 drc( post_driver_nmos_rw_33v post_driver_pmos_nw_lv  sep < LUP_3_3  sameNet shielded withIntersection withSingularPoint 
	"LUP.3.3g_3.3V 5  For the 3.3V N/PMOS which connects to an I/O pad directly, space between the 3.3V NMOS and the 3.3V/1.8V/1.5V PMOS, space between the 3.3V PMOS and the 3.3V/1.8V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= =LUP_3_3 um ")  
 drc( post_driver_nmos_rw_lv post_driver_pmos_nw_33v  sep < LUP_3_3  sameNet shielded withIntersection withSingularPoint 
	"LUP.3.3g_3.3V 6  For the 3.3V N/PMOS which connects to an I/O pad directly, space between the 3.3V NMOS and the 3.3V/1.8V/1.5V PMOS, space between the 3.3V PMOS and the 3.3V/1.8V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= =LUP_3_3 um ")  
 drc( post_driver_nmos_rwi_33v post_driver_pmos_nwi_33v  sep < LUP_3_3  diffNet shielded withIntersection withSingularPoint 
	"LUP.3.3g_3.3V 7  For the 3.3V N/PMOS which connects to an I/O pad directly, space between the 3.3V NMOS and the 3.3V/1.8V/1.5V PMOS, space between the 3.3V PMOS and the 3.3V/1.8V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= =LUP_3_3 um ")  
 drc( post_driver_nmos_rwi_33v post_driver_pmos_nwi_lv  sep < LUP_3_3  diffNet shielded withIntersection withSingularPoint 
	"LUP.3.3g_3.3V 8  For the 3.3V N/PMOS which connects to an I/O pad directly, space between the 3.3V NMOS and the 3.3V/1.8V/1.5V PMOS, space between the 3.3V PMOS and the 3.3V/1.8V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= =LUP_3_3 um ")  
 drc( post_driver_nmos_rwi_lv post_driver_pmos_nwi_33v  sep < LUP_3_3  diffNet shielded withIntersection withSingularPoint 
	"LUP.3.3g_3.3V 9  For the 3.3V N/PMOS which connects to an I/O pad directly, space between the 3.3V NMOS and the 3.3V/1.8V/1.5V PMOS, space between the 3.3V PMOS and the 3.3V/1.8V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= =LUP_3_3 um ")  
) ; 
if((HIGH_VOLTAGE == 5) then
 drc( post_driver_nmos_pw_50v post_driver_pmos_nw_50v  sep < LUP_3_4  shielded withIntersection withSingularPoint 
	"LUP.3.4g_5V  For the 5V N/PMOS which connects to an I/O pad directly, space between the 1.8V NMOS and the 5V/1.8V PMOS, space between the 1.8V PMOS and the 5V/1.8V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.  >= =LUP_3_4 um ")  
 drc( post_driver_nmos_pw_50v post_driver_pmos_nw_lv  sep < LUP_3_4  shielded withIntersection withSingularPoint 
	"LUP.3.4g_5V 2  For the 5V N/PMOS which connects to an I/O pad directly, space between the 1.8V NMOS and the 5V/1.8V PMOS, space between the 1.8V PMOS and the 5V/1.8V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.  >= =LUP_3_4 um ")  
 drc( post_driver_nmos_pw_lv post_driver_pmos_nw_50v  sep < LUP_3_4  shielded withIntersection withSingularPoint 
	"LUP.3.4g_5V 3  For the 5V N/PMOS which connects to an I/O pad directly, space between the 1.8V NMOS and the 5V/1.8V PMOS, space between the 1.8V PMOS and the 5V/1.8V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.  >= =LUP_3_4 um ")  
 drc( post_driver_nmos_rw_50v post_driver_pmos_nw_50v  sep < LUP_3_4  sameNet shielded withIntersection withSingularPoint 
	"LUP.3.4g_5V 4  For the 5V N/PMOS which connects to an I/O pad directly, space between the 1.8V NMOS and the 5V/1.8V PMOS, space between the 1.8V PMOS and the 5V/1.8V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.  >= =LUP_3_4 um ")  
 drc( post_driver_nmos_rw_50v post_driver_pmos_nw_lv  sep < LUP_3_4  sameNet shielded withIntersection withSingularPoint 
	"LUP.3.4g_5V 5  For the 5V N/PMOS which connects to an I/O pad directly, space between the 1.8V NMOS and the 5V/1.8V PMOS, space between the 1.8V PMOS and the 5V/1.8V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.  >= =LUP_3_4 um ")  
 drc( post_driver_nmos_rw_lv post_driver_pmos_nw_50v  sep < LUP_3_4  sameNet shielded withIntersection withSingularPoint 
	"LUP.3.4g_5V 6  For the 5V N/PMOS which connects to an I/O pad directly, space between the 1.8V NMOS and the 5V/1.8V PMOS, space between the 1.8V PMOS and the 5V/1.8V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.  >= =LUP_3_4 um ")  
 drc( post_driver_nmos_rwi_50v post_driver_pmos_nwi_50v  sep < LUP_3_4  diffNet shielded withIntersection withSingularPoint 
	"LUP.3.4g_5V 7  For the 5V N/PMOS which connects to an I/O pad directly, space between the 1.8V NMOS and the 5V/1.8V PMOS, space between the 1.8V PMOS and the 5V/1.8V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.  >= =LUP_3_4 um ")  
 drc( post_driver_nmos_rwi_50v post_driver_pmos_nwi_lv  sep < LUP_3_4  diffNet shielded withIntersection withSingularPoint 
	"LUP.3.4g_5V 8  For the 5V N/PMOS which connects to an I/O pad directly, space between the 1.8V NMOS and the 5V/1.8V PMOS, space between the 1.8V PMOS and the 5V/1.8V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.  >= =LUP_3_4 um ")  
 drc( post_driver_nmos_rwi_lv post_driver_pmos_nwi_50v  sep < LUP_3_4  diffNet shielded withIntersection withSingularPoint 
	"LUP.3.4g_5V 9  For the 5V N/PMOS which connects to an I/O pad directly, space between the 1.8V NMOS and the 5V/1.8V PMOS, space between the 1.8V PMOS and the 5V/1.8V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.  >= =LUP_3_4 um ")  
) ; 
 post_driver_nact1 =  geomOr(post_driver_nact beside_post_driver_nmos)  
 lup4g_ptap_guard_ring_holex = geomEnclose( ptap_guard_ring_hole post_driver_nact1  )   
 post_driver_pact1 =  geomOr(post_driver_pact beside_post_driver_pmos)  
 lup4g1_ntap_guard_ring_holex = geomEnclose( ntap_guard_ring_hole post_driver_pact1  )   
 ptapi_tch1 =  geomButtOnly(geomOutside(ptapi lup4g_ptap_guard_ring_holex) lup4g_ptap_guard_ring_holex )   
 lup4g2_ptap_guard_ring_wide = geomWidth(ptapi_tch1 keep  >= LUP_4) 
 ntapi_tch1 =  geomButtOnly(geomOutside(ntapi lup4g1_ntap_guard_ring_holex) lup4g1_ntap_guard_ring_holex )   
 lup4g3_ntap_guard_ring_wide = geomWidth(ntapi_tch1 keep  >= LUP_4) 
lup4g2_ptap_guard_ring_wide5 = geomHoles(lup4g2_ptap_guard_ring_wide innermost )
 ptap_guard_ring_wide1 =  lup4g2_ptap_guard_ring_wide5  
 lup4g4_ptap_guard_ring_wide_hole = geomInside( ptap_guard_ring_wide1 pweli  )   
lup4g3_ntap_guard_ring_wide5 = geomHoles(lup4g3_ntap_guard_ring_wide innermost )
 ntap_guard_ring_wide1 =  lup4g3_ntap_guard_ring_wide5  
 lup4g5_ntap_guard_ring_wide_hole = geomInside( ntap_guard_ring_wide1 nweli  )   
 lup4g6_ptap_guard_ring_hole_check = geomAndNot(lup4g_ptap_guard_ring_holex geomInside(lup4g_ptap_guard_ring_holex lup4g4_ptap_guard_ring_wide_hole ))   
 lup4g7_ntap_guard_ring_hole_check = geomAndNot(lup4g1_ntap_guard_ring_holex geomInside(lup4g1_ntap_guard_ring_holex lup4g5_ntap_guard_ring_wide_hole ))   
 lup4g8_ptap_guard_ring_check = geomGetEdge(ptapi butting lup4g6_ptap_guard_ring_hole_check)   
 lup4g9_ntap_guard_ring_check = geomGetEdge(ntapi butting lup4g7_ntap_guard_ring_hole_check)   
 drc( lup4g8_ptap_guard_ring_check ptapi  ovlp < LUP_4  shielded withIntersection 
	"LUP.4g  Width of the N+ guard-ring, P+ guard-ring, N+ STRAP and P+ STRAP for the Active connected to an I/O pad, and also MOS within 20um space from the MOS connected to an I/O pad. >= =LUP_4 um ")  
 drc( lup4g9_ntap_guard_ring_check ntapi  ovlp < LUP_4  shielded withIntersection 
	"LUP.4g 2  Width of the N+ guard-ring, P+ guard-ring, N+ STRAP and P+ STRAP for the Active connected to an I/O pad, and also MOS within 20um space from the MOS connected to an I/O pad. >= =LUP_4 um ")  
if((CORE_VOLTAGE == 1.8) then
 drc( post_driver_pmos_nw_lv beside_post_driver_nmos_pw  sep < LUP_5_1  shielded withIntersection withSingularPoint 
	"LUP.5.1g_1.8V  Minimum space >= =LUP_5_1 um 1. between 1.8V-1.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 1.8V-1.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_pmos_nw_lv beside_post_driver_nmos_rw  sep < LUP_5_1  sameNet shielded withIntersection withSingularPoint 
	"LUP.5.1g_1.8V 2  Minimum space >= =LUP_5_1 um 1. between 1.8V-1.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 1.8V-1.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_pmos_nwi_lv beside_post_driver_nmos_rwi  sep < LUP_5_1  diffNet shielded withIntersection withSingularPoint 
	"LUP.5.1g_1.8V 3  Minimum space >= =LUP_5_1 um 1. between 1.8V-1.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 1.8V-1.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_nmos_pw_lv beside_post_driver_pmos_nw  sep < LUP_5_1  shielded withIntersection withSingularPoint 
	"LUP.5.1g_1.8V 4  Minimum space >= =LUP_5_1 um 1. between 1.8V-1.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 1.8V-1.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_nmos_rw_lv beside_post_driver_pmos_nw  sep < LUP_5_1  sameNet shielded withIntersection withSingularPoint 
	"LUP.5.1g_1.8V 5  Minimum space >= =LUP_5_1 um 1. between 1.8V-1.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 1.8V-1.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_nmos_rwi_lv beside_post_driver_pmos_nwi  sep < LUP_5_1  diffNet shielded withIntersection withSingularPoint 
	"LUP.5.1g_1.8V 6  Minimum space >= =LUP_5_1 um 1. between 1.8V-1.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 1.8V-1.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
) ; 
if((CORE_VOLTAGE == 1.5) then
 drc( post_driver_pmos_nw_lv beside_post_driver_nmos_pw  sep < LUP_5_1  shielded withIntersection withSingularPoint 
	"LUP.5.1g_1.5V  Minimum space >= =LUP_5_1 um 1. between 1.8V-1.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 1.8V-1.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_pmos_nw_lv beside_post_driver_nmos_rw  sep < LUP_5_1  sameNet shielded withIntersection withSingularPoint 
	"LUP.5.1g_1.5V 2  Minimum space >= =LUP_5_1 um 1. between 1.8V-1.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 1.8V-1.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_pmos_nwi_lv beside_post_driver_nmos_rwi  sep < LUP_5_1  diffNet shielded withIntersection withSingularPoint 
	"LUP.5.1g_1.5V 3  Minimum space >= =LUP_5_1 um 1. between 1.8V-1.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 1.8V-1.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_nmos_pw_lv beside_post_driver_pmos_nw  sep < LUP_5_1  shielded withIntersection withSingularPoint 
	"LUP.5.1g_1.5V 4  Minimum space >= =LUP_5_1 um 1. between 1.8V-1.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 1.8V-1.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_nmos_rw_lv beside_post_driver_pmos_nw  sep < LUP_5_1  sameNet shielded withIntersection withSingularPoint 
	"LUP.5.1g_1.5V 5  Minimum space >= =LUP_5_1 um 1. between 1.8V-1.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 1.8V-1.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_nmos_rwi_lv beside_post_driver_pmos_nwi  sep < LUP_5_1  diffNet shielded withIntersection withSingularPoint 
	"LUP.5.1g_1.5V 6  Minimum space >= =LUP_5_1 um 1. between 1.8V-1.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 1.8V-1.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
) ; 
if((HIGH_VOLTAGE == 2.5) then
 drc( post_driver_pmos_nw_25v beside_post_driver_nmos_pw  sep < LUP_5_2  shielded withIntersection withSingularPoint 
	"LUP.5.2g_2.5V  Minimum space >= =LUP_5_2 um 1. between 2.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 2.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_pmos_nw_25v beside_post_driver_nmos_rw  sep < LUP_5_2  sameNet shielded withIntersection withSingularPoint 
	"LUP.5.2g_2.5V 2  Minimum space >= =LUP_5_2 um 1. between 2.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 2.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_pmos_nwi_25v beside_post_driver_nmos_rwi  sep < LUP_5_2  diffNet shielded withIntersection withSingularPoint 
	"LUP.5.2g_2.5V 3  Minimum space >= =LUP_5_2 um 1. between 2.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 2.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_nmos_pw_25v beside_post_driver_pmos_nw  sep < LUP_5_2  shielded withIntersection withSingularPoint 
	"LUP.5.2g_2.5V 4  Minimum space >= =LUP_5_2 um 1. between 2.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 2.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_nmos_rw_25v beside_post_driver_pmos_nw  sep < LUP_5_2  sameNet shielded withIntersection withSingularPoint 
	"LUP.5.2g_2.5V 5  Minimum space >= =LUP_5_2 um 1. between 2.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 2.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_nmos_rwi_25v beside_post_driver_pmos_nwi  sep < LUP_5_2  diffNet shielded withIntersection withSingularPoint 
	"LUP.5.2g_2.5V 6  Minimum space >= =LUP_5_2 um 1. between 2.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 2.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
) ; 
if((HIGH_VOLTAGE == 3.3) then
 drc( post_driver_pmos_nw_33v beside_post_driver_nmos_pw  sep < LUP_5_3  shielded withIntersection withSingularPoint 
	"LUP.5.3g_3.3V  Minimum space >= =LUP_5_3 um 1. between 3.3V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 3.3V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_pmos_nw_33v beside_post_driver_nmos_rw  sep < LUP_5_3  sameNet shielded withIntersection withSingularPoint 
	"LUP.5.3g_3.3V 2  Minimum space >= =LUP_5_3 um 1. between 3.3V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 3.3V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_pmos_nwi_33v beside_post_driver_nmos_rwi  sep < LUP_5_3  diffNet shielded withIntersection withSingularPoint 
	"LUP.5.3g_3.3V 3  Minimum space >= =LUP_5_3 um 1. between 3.3V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 3.3V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_nmos_pw_33v beside_post_driver_pmos_nw  sep < LUP_5_3  shielded withIntersection withSingularPoint 
	"LUP.5.3g_3.3V 4  Minimum space >= =LUP_5_3 um 1. between 3.3V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 3.3V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_nmos_rw_33v beside_post_driver_pmos_nw  sep < LUP_5_3  sameNet shielded withIntersection withSingularPoint 
	"LUP.5.3g_3.3V 5  Minimum space >= =LUP_5_3 um 1. between 3.3V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 3.3V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_nmos_rwi_33v beside_post_driver_pmos_nwi  sep < LUP_5_3  diffNet shielded withIntersection withSingularPoint 
	"LUP.5.3g_3.3V 6  Minimum space >= =LUP_5_3 um 1. between 3.3V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 3.3V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
) ; 
if((HIGH_VOLTAGE == 5) then
 drc( post_driver_pmos_nw_50v beside_post_driver_nmos_pw_1  sep < LUP_5_4  shielded withIntersection withSingularPoint 
	"LUP.5.4g_5V  Minimum space >= =LUP_5_4 um 1. between 5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_pmos_nw_50v beside_post_driver_nmos_rw_1  sep < LUP_5_4  sameNet shielded withIntersection withSingularPoint 
	"LUP.5.4g_5V 2  Minimum space >= =LUP_5_4 um 1. between 5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_pmos_nwi_50v beside_post_driver_nmos_rwi_1  sep < LUP_5_4  diffNet shielded withIntersection withSingularPoint 
	"LUP.5.4g_5V 3  Minimum space >= =LUP_5_4 um 1. between 5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_nmos_pw_50v beside_post_driver_pmos_nw_1  sep < LUP_5_4  shielded withIntersection withSingularPoint 
	"LUP.5.4g_5V 4  Minimum space >= =LUP_5_4 um 1. between 5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_nmos_rw_50v beside_post_driver_pmos_nw_1  sep < LUP_5_4  sameNet shielded withIntersection withSingularPoint 
	"LUP.5.4g_5V 5  Minimum space >= =LUP_5_4 um 1. between 5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
 drc( post_driver_nmos_rwi_50v beside_post_driver_pmos_nwi_1  sep < LUP_5_4  diffNet shielded withIntersection withSingularPoint 
	"LUP.5.4g_5V 6  Minimum space >= =LUP_5_4 um 1. between 5V NMOS which connects to the IO pad and the the PMOS in the internal circuit  2. between 5V PMOS which connects to the IO pad and the the NMOS in the internal circuit   ")  
) ; 
) ; 
 psdc_not1 =  geomAndNot(psdc geomOutside(psdc coi ))   
 co_pact = geomOr(coi psdc_not1)  
 npui = geomButtOrOver( ntapi co_pact  )   
 npui_sram = geomInside( npui srm  )   
nstp_os = geomSizeAnd( npui nweli NW_S_1* 0.7 LUP_6 )  
nstp_os_sram = geomSizeAnd( npui_sram nweli NW_S_1* 0.7 LUP_6_SRAM )  
 pacti_iact1 =  geomButtOrOver( pacti coi  )   
 pacti_iact11 =  geomButtOrOver( pacti_iact1 polyi  )   
 pact_check = geomAndNot(pacti_iact11 polyi)  
 pact_check_non_sram = geomAndNot(pact_check geomInside(pact_check srm ))   
 pact_check_sram = geomInside( pact_check srm  )   
 nsdc_not1 =  geomAndNot(nsdc geomOutside(nsdc coi ))   
 co_nact = geomOr(coi nsdc_not1)  
 ppui = geomButtOrOver( ptapi co_nact  )   
 ppui_sram = geomInside( ppui srm  )   
pstp_os = geomSizeAnd( ppui pweli NW_S_1* 0.7 LUP_6 )  
pstp_os_sram = geomSizeAnd( ppui_sram pweli NW_S_1* 0.7 LUP_6_SRAM )  
 nacti_iact1 =  geomButtOrOver( nacti coi  )   
 nacti_iact11 =  geomButtOrOver( nacti_iact1 polyi  )   
 nact_check = geomAndNot(nacti_iact11 polyi)  
 nact_check_non_sram = geomAndNot(nact_check geomInside(nact_check srm ))   
 nact_check_sram = geomInside( nact_check srm  )   
 errorLayer( geomAndNot(pact_check_non_sram nstp_os) 
	"LUP.6  Any point inside NMOS source/drain space to the nearest PW STRAP in the same PW <= =LUP_6 um Any point inside PMOS source/drain space to the nearest NW STRAP in the same NW <= =LUP_6 um In SRAM bit cell region, the rule is relaxed to =LUP_6_SRAM um     ") 
 nstp_os_or1 =  geomOr(nstp_os nstp_os_sram)  
 errorLayer( geomAndNot(pact_check_sram nstp_os_or1) 
	"LUP.6 2  Any point inside NMOS source/drain space to the nearest PW STRAP in the same PW <= =LUP_6 um Any point inside PMOS source/drain space to the nearest NW STRAP in the same NW <= =LUP_6 um In SRAM bit cell region, the rule is relaxed to =LUP_6_SRAM um     ") 
 errorLayer( geomAndNot(nact_check_non_sram pstp_os) 
	"LUP.6 3  Any point inside NMOS source/drain space to the nearest PW STRAP in the same PW <= =LUP_6 um Any point inside PMOS source/drain space to the nearest NW STRAP in the same NW <= =LUP_6 um In SRAM bit cell region, the rule is relaxed to =LUP_6_SRAM um     ") 
 pstp_os_or1 =  geomOr(pstp_os pstp_os_sram)  
 errorLayer( geomAndNot(nact_check_sram pstp_os_or1) 
	"LUP.6 4  Any point inside NMOS source/drain space to the nearest PW STRAP in the same PW <= =LUP_6 um Any point inside PMOS source/drain space to the nearest NW STRAP in the same NW <= =LUP_6 um In SRAM bit cell region, the rule is relaxed to =LUP_6_SRAM um     ") 
/*  LOGO CHECKS */
/* ============ */
 logo_sz1 =  geomSize( logo 3 noClipAcute )   
 logos1_logo_ext = geomAndNot(logo_sz1 logo)  
 errorLayer( geomAnd(logos1_logo_ext nweli) 
	"LOGO.S.1  Min. LOGO space to NW, OD, PO, or Metals (non-dummy patterns) >= 3um ") 
 errorLayer( geomAnd(logos1_logo_ext odi) 
	"LOGO.S.1 2  Min. LOGO space to NW, OD, PO, or Metals (non-dummy patterns) >= 3um ") 
 errorLayer( geomAnd(logos1_logo_ext polyi) 
	"LOGO.S.1 3  Min. LOGO space to NW, OD, PO, or Metals (non-dummy patterns) >= 3um ") 
 errorLayer( geomAnd(logos1_logo_ext m1i) 
	"LOGO.S.1 4  Min. LOGO space to NW, OD, PO, or Metals (non-dummy patterns) >= 3um ") 
 errorLayer( geomAnd(logos1_logo_ext m2i) 
	"LOGO.S.1 5  Min. LOGO space to NW, OD, PO, or Metals (non-dummy patterns) >= 3um ") 
 errorLayer( geomAnd(logos1_logo_ext m3i) 
	"LOGO.S.1 6  Min. LOGO space to NW, OD, PO, or Metals (non-dummy patterns) >= 3um ") 
 errorLayer( geomAnd(logos1_logo_ext m4i) 
	"LOGO.S.1 7  Min. LOGO space to NW, OD, PO, or Metals (non-dummy patterns) >= 3um ") 
 errorLayer( geomAnd(logos1_logo_ext m5i) 
	"LOGO.S.1 8  Min. LOGO space to NW, OD, PO, or Metals (non-dummy patterns) >= 3um ") 
 errorLayer( geomAnd(logos1_logo_ext m6i) 
	"LOGO.S.1 9  Min. LOGO space to NW, OD, PO, or Metals (non-dummy patterns) >= 3um ") 
 errorLayer( geomAnd(logos1_logo_ext mdi) 
	"LOGO.S.1 10  Min. LOGO space to NW, OD, PO, or Metals (non-dummy patterns) >= 3um ") 
 errorLayer( geomAnd(logo cbi) 
	"LOGO.O.1  LOGO overlap of CB, CBD, FW, PM, UBM, DOD, DPO, or DMx is not allowed. ") 
 errorLayer( geomAnd(logo cbdi) 
	"LOGO.O.1 2  LOGO overlap of CB, CBD, FW, PM, UBM, DOD, DPO, or DMx is not allowed. ") 
 errorLayer( geomAnd(logo ppii) 
	"LOGO.O.1 3  LOGO overlap of CB, CBD, FW, PM, UBM, DOD, DPO, or DMx is not allowed. ") 
 errorLayer( geomAnd(logo fwi) 
	"LOGO.O.1 4  LOGO overlap of CB, CBD, FW, PM, UBM, DOD, DPO, or DMx is not allowed. ") 
 errorLayer( geomAnd(logo plmidei) 
	"LOGO.O.1 5  LOGO overlap of CB, CBD, FW, PM, UBM, DOD, DPO, or DMx is not allowed. ") 
 errorLayer( geomAnd(logo ubmi) 
	"LOGO.O.1 6  LOGO overlap of CB, CBD, FW, PM, UBM, DOD, DPO, or DMx is not allowed. ") 
 errorLayer( geomAnd(logo dod) 
	"LOGO.O.1 7  LOGO overlap of CB, CBD, FW, PM, UBM, DOD, DPO, or DMx is not allowed. ") 
 errorLayer( geomAnd(logo dpo) 
	"LOGO.O.1 8  LOGO overlap of CB, CBD, FW, PM, UBM, DOD, DPO, or DMx is not allowed. ") 
 errorLayer( geomAnd(logo m1dmy) 
	"LOGO.O.1 9  LOGO overlap of CB, CBD, FW, PM, UBM, DOD, DPO, or DMx is not allowed. ") 
 errorLayer( geomAnd(logo m2dmy) 
	"LOGO.O.1 10  LOGO overlap of CB, CBD, FW, PM, UBM, DOD, DPO, or DMx is not allowed. ") 
 errorLayer( geomAnd(logo m3dmy) 
	"LOGO.O.1 11  LOGO overlap of CB, CBD, FW, PM, UBM, DOD, DPO, or DMx is not allowed. ") 
 errorLayer( geomAnd(logo m4dmy) 
	"LOGO.O.1 12  LOGO overlap of CB, CBD, FW, PM, UBM, DOD, DPO, or DMx is not allowed. ") 
 errorLayer( geomAnd(logo m5dmy) 
	"LOGO.O.1 13  LOGO overlap of CB, CBD, FW, PM, UBM, DOD, DPO, or DMx is not allowed. ") 
 errorLayer( geomAnd(logo m6dmy) 
	"LOGO.O.1 14  LOGO overlap of CB, CBD, FW, PM, UBM, DOD, DPO, or DMx is not allowed. ") 
 errorLayer( geomAnd(logo mddmy) 
	"LOGO.O.1 15  LOGO overlap of CB, CBD, FW, PM, UBM, DOD, DPO, or DMx is not allowed. ") 
 errorLayer( geomAnd(logo all_gate) 
	"LOGO.R.1  A circuit in LOGO is not allowed. ") 
 errorLayer( geomAnd(logo pores) 
	"LOGO.R.1 2  A circuit in LOGO is not allowed. ") 
 errorLayer( geomAnd(logo odres) 
	"LOGO.R.1 3  A circuit in LOGO is not allowed. ") 
 errorLayer( geomAnd(logo rnwel) 
	"LOGO.R.1 4  A circuit in LOGO is not allowed. ") 
 errorLayer( geomAnd(logo bjtdummy) 
	"LOGO.R.1 5  A circuit in LOGO is not allowed. ") 
 errorLayer( geomAnd(logo diodummy) 
	"LOGO.R.1 6  A circuit in LOGO is not allowed. ") 
 errorLayer( geomAnd(logo vardmy) 
	"LOGO.R.1 7  A circuit in LOGO is not allowed. ") 
 errorLayer( geomAnd(logo ctm5i) 
	"LOGO.R.1 8  A circuit in LOGO is not allowed. ") 
/* LOGO.R.2 has been check by other DRC rules */
/*  DRC UNSELECT CHECK DENSITY_CHECK */
if((MIX_MODE == 1) then
/* =============================================================================== */
/*  Mixed-Singal/RF part */
/* =============================================================================== */
/*  POLY CHECKS */
/* ============== */
 pow1_hri_hrepc = geomButtOrOver( hrep rlppdmy  )   
 drc( pow1_hri_hrepc   width < 1.0  withCornerTouch 
	"PO.W.1_HRI  Min. width of PO region for HRI poly resistor >= 1.0um ")  
 _por1amm_norm_gate_w = geomGetEdge(gate_w outside vardmy)   
 _por1amm_norm_gate_w1 = geomGetAngledEdge(_por1amm_norm_gate_w keep == 0 mode1 )
 _por1amm_norm_gate_w11 = geomGetAdjacentEdge(_por1amm_norm_gate_w _por1amm_norm_gate_w1 )
 _por1amm_norm_gate_w2 = geomGetAngledEdge(_por1amm_norm_gate_w keep == 45)
 errorLayer( geomAndNot(_por1amm_norm_gate_w11 _por1amm_norm_gate_w2) 
	"_PO.R.1A.MM  90 degree L shape and U shape bent gates are not allowed ") 
/*  PP CHECKS */
/* ============ */
 drc( pp pores  enc < 0.18  shielded withIntersection withSingularPoint 
	"_PP.E.6.MM  Min. extension of a PP region beyond a PO as resistor >= 0.18um ")  
 rpo_and3 =  geomAnd(rpo poly)  
 rpo_and3_not1 =  geomAndNot(rpo_and3 imp)  
 errorLayer( geomAndNot(rpo_and3_not1 hri) 
	"_PP.E.6.MM 2  Min. extension of a PP region beyond a PO as resistor >= 0.18um ") 
/*  RPO CHECKS */
/* ============= */
 rpoo1_hri_x = geomButtOrOver( poly_iso hri  )   
 rpoo1_hri1_y = geomGetEdge(rpo inside rpoo1_hri_x)   
 drc( pp rpoo1_hri1_y  ovlp < 0.3  shielded withIntersection 
	"RPO.O.1_HRI  Min. and Max. overlap of a PP region to RPO region for HRI == 0.3um ")  
 errorLayer( geomGetEdge(rpoo1_hri1_y outside pp) 
	"RPO.O.1_HRI 2  Min. and Max. overlap of a PP region to RPO region for HRI == 0.3um ") /*  not overlap by P+ not allowed. */ 
 rpoo1_hri2_z = geomSize(rpoo1_hri1_y -0.30 edges)   
 rpoo1_hri3_pppo = geomAnd(pp poly)  
 rpoo1_hri4_a = geomAnd(rpoo1_hri3_pppo pores)  
 rpoo1_hri5_b = geomButtOrOver( rpoo1_hri4_a hri  )   
 errorLayer( geomAndNot(rpoo1_hri5_b rpoo1_hri2_z) 
	"RPO.O.1_HRI 3  Min. and Max. overlap of a PP region to RPO region for HRI == 0.3um ") 
if((C016 == 0) then
geomConnect( incremental
	buttOrOver(ntapi nweli)
	buttOrOver(ntapi psdi)
	buttOrOver(ptapi nsdi)
	via(coi m1xd ilp1i ntapi ptapi psdi nsdi)
	via(via1i m1xd m2xd)
	via(via2i m2xd m3xd)
	via(via3i m3xd m4xd)
	via(via4i m4xd m5xd)
	via(viat m5xd m6xd)
	via(viac ctm5i m6xd)
	via(viadi m6xd mdxd)
)
/*  M6 checks */
/* ============= */
 m6t_nind = geomAndNot(m6xd inddmy)  
 inddmyi = geomSize( inddmy -7 noClipAcute )  /* exclude M1 substrate pick up node */ 
 indm = geomAnd(inddmy m4)  
 indme = geomGetEdge(indm coincident inddmy)   
 indme_sz1 = geomSize(indme 0.005 edges)
 inddmya = geomButtOrCoin( inddmy indme_sz1  keep < 2)   
 inddmy3 = geomEnclose( inddmya m5  )  /* for 3 terminals inductor(central tap) */ 
 inddmy2 = geomAndNot(inddmy inddmy3)  /* for 2 terminals inductor */
if((THICK_20K == 1) then

UTM20K_W_1 = 1.50
UTM20KW1 = MxW1( m6 UTM20K_W_1 )
errorLayer( UTM20KW1 "UTM20K.W.1  Min. M6 width >= 1.50 um ")  



 drc( m6   sepNotch < 1.50  
	"UTM20K.S.1  Min. M6 spacing >= 1.50 um ")  
 drc( m6 via5  enc < 0.3  shielded withIntersection withSingularPoint 
	"UTM20K.E.1  Min. extension of a M6 region beyond a VIA5 region >= 0.3 um ")  
 errorLayer( geomAndNot(via5 m6) 
	"UTM20K.E.1 2  Min. extension of a M6 region beyond a VIA5 region >= 0.3 um ") 
 utm20ke2_x = drc( m6 via5  enc < 0.45  oppositeB shielded withIntersection edgeb )/*  a narrow side */
 utm20ke2_x_ang01 = geomGetAngledEdge(utm20ke2_x keep == 0)
 utm20ke2_x_ang011 = geomGetAdjacentEdge(utm20ke2_x utm20ke2_x_ang01 )
 utm20ke2_x1 = geomGetAngledEdge(utm20ke2_x keep == 45)
 errorLayer( geomAndNot(utm20ke2_x_ang011 utm20ke2_x1) 
	"UTM20K.E.2  Min. extension of M6 end-of-line region beyond VIA5 region >= 0.45 um ") /*  adjacent narrow sides */


UTM20K_WIDE = 16
UTM20KS2    = 3.0 
UTM20K_INCR = 1.05
UTM20K_DIST = 1 
UTM20K_S_2  = MxS2( m6t_nind m6xd UTM20K_WIDE GRID UTM20KS2 UTM20K_DIST UTM20K_INCR 0 89.5 )
errorLayer( UTM20K_S_2 "UTM20K.S.2  Min. space of Wide M6 (>16um) and M6 >= 3.0 um (exclude application for inductor)")


 drc( m6  area < 2.25 
	"UTM20K.A.1  Min. area of M6 region >= 2.25 um2 ") 
 utm20kr1_chip_nind = geomAndNot(chip inddmy)  

processCoverage(
	backup
         
        measure( 
            
            m6t_nind_den2_pc = calculate( area(m6t_nind) / area(utm20kr1_chip_nind))
            m6t_nind_den2 = output( m6t_nind_den2_pc  0 <=  keep < 0.3)
        ); end measure
); end processCoverage
  errorLayer( m6t_nind_den2 
	"UTM20K.R.1  Min. density of M6 area >= 30% (exclude application for inductor) ") 
if((Recommend == 1) then
 inddmy_sz1 =  geomSize( inddmy -50.5 noClipAcute )   
 utm20kc1_ind_m6 = geomButtOrOver( m6 inddmy_sz1  )   
 utm20kc11_ind_m6v5 = geomButtOrOver( via5 utm20kc1_ind_m6  )   
 utm20kc12_ind_m5 = geomButtOrOver( m5 utm20kc11_ind_m6v5  )   
 utm20kc13_ind_m5v5 = geomButtOrOver( via5 utm20kc12_ind_m5  )   
 utm20kc14_ind_m6_conn = geomButtOrOver( m6 utm20kc13_ind_m5v5  )   
 utm20kc15_ind_m6_all = geomOr(utm20kc1_ind_m6 utm20kc14_ind_m6_conn)  
 utm20kc16_im6 = geomAnd(utm20kc15_ind_m6_all inddmy)  
 utm20kc17_rm6 = geomAndNot(m6 utm20kc15_ind_m6_all)  
 utm20kc18_om6 = geomAndNot(utm20kc15_ind_m6_all utm20kc16_im6)  
 drc( utm20kc17_rm6 utm20kc16_im6  sep < 50  shielded withIntersection withSingularPoint 
	"UTM20K.C.1  Min. clearance from M6 as inductor to M6 >= 50 um ")  
 drc( utm20kc16_im6 utm20kc18_om6 0 < sep < 50  shielded  app > 0 parallel withIntersection 
	"UTM20K.C.1 2  Min. clearance from M6 as inductor to M6 >= 50 um ")  
) ; 
 drc( inddmy m6 0 < enc < 50  shielded withIntersection withSingularPoint 
	"UTM20K.E.3  Min. extension of INDDMY beyond M6 >= 50 um ")  
 errorLayer( geomAnd(inddmyi m1) 
	"UTM20K.I.1  No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect, and the M1 substrate pick up node of inductor ") 
 errorLayer( geomAnd(inddmy via1) 
	"UTM20K.I.1 2  No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect, and the M1 substrate pick up node of inductor ") 
 errorLayer( geomAnd(inddmy m2) 
	"UTM20K.I.1 3  No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect, and the M1 substrate pick up node of inductor ") 
 errorLayer( geomAnd(inddmy via2) 
	"UTM20K.I.1 4  No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect, and the M1 substrate pick up node of inductor ") 
 errorLayer( geomAnd(inddmy m3) 
	"UTM20K.I.1 5  No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect, and the M1 substrate pick up node of inductor ") 
 errorLayer( geomAnd(inddmy via3) 
	"UTM20K.I.1 6  No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect, and the M1 substrate pick up node of inductor ") 
 errorLayer( geomAnd(inddmy2 m4) 
	"UTM20K.I.1 7  No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect, and the M1 substrate pick up node of inductor ") 
 errorLayer( geomAnd(inddmy2 via4) 
	"UTM20K.I.1 8  No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect, and the M1 substrate pick up node of inductor ") 
 errorLayer( geomAnd(inddmy nwel) 
	"UTM20K.I.2  Both active and passive devices not allow inside INDDMY besides guard ring ") 
 errorLayer( geomAnd(inddmy poly) 
	"UTM20K.I.2 2  Both active and passive devices not allow inside INDDMY besides guard ring ") 
 errorLayer( geomAnd(inddmyi od) 
	"UTM20K.I.2 3  Both active and passive devices not allow inside INDDMY besides guard ring ") /* exclude M1 substrate pick up node of inductor */
) ; 
if((THICK_40K == 1) then

UTM40K_W_1 = 2.60
UTM40KW1 = MxW1( m6 UTM40K_W_1 )
errorLayer( UTM40KW1 "UTM40K.W.1  Min. M6 width >= 2.60 um ")  

 drc( m6   sepNotch < 2.50  
	"UTM40K.S.1  Min. M6 space >= 2.50 um ")  
 drc( m6 via5  enc < 0.4  shielded withIntersection withSingularPoint 
	"UTM40K.E.1  Min. extension of a M6 region beyond a VIA5 region >= 0.4 um ")  
 errorLayer( geomAndNot(via5 m6) 
	"UTM40K.E.1 2  Min. extension of a M6 region beyond a VIA5 region >= 0.4 um ") 
 utm40ke2_x = drc( m6 via5  enc < 0.45  oppositeB shielded withIntersection edgeb )/*  a narrow side */
 utm40ke2_x_ang01 = geomGetAngledEdge(utm40ke2_x keep == 0)
 utm40ke2_x_ang011 = geomGetAdjacentEdge(utm40ke2_x utm40ke2_x_ang01 )
 utm40ke2_x1 = geomGetAngledEdge(utm40ke2_x keep == 45)
 errorLayer( geomAndNot(utm40ke2_x_ang011 utm40ke2_x1) 
	"UTM40K.E.2  Min. extension of M6 end-of-line region beyond VIA5 region >= 0.45 um ") /*  adjacent narrow sides */



UTM40K_WIDE = 16
UTM40KS2    = 4.0 
UTM40K_INCR = 1.75
UTM40K_DIST = 1 
UTM40K_S_2  = MxS2( m6t_nind m6xd UTM40K_WIDE GRID UTM40KS2 UTM40K_DIST UTM40K_INCR 0 89.5 )
errorLayer( UTM40K_S_2 "UTM40K.S.2  Min. space of Wide M6 (>16um) and M6 >= 4.0 um (exclude application for inductor)")


 drc( m6  area < 6.76 
	"UTM40K.A.1  Min. area of M6 region >= 6.76 um2 ") 
 utm40kr1_chip_nind = geomAndNot(chip inddmy)  

processCoverage(
	backup
         
        measure( 
            
            m6t_nind_den2_pc = calculate( area(m6t_nind) / area(utm40kr1_chip_nind))
            m6t_nind_den2 = output( m6t_nind_den2_pc  0 <=  keep < 0.3)
        ); end measure
); end processCoverage
  errorLayer( m6t_nind_den2 
	"UTM40K.R.1  Min. density of M6 area >= 30% (exclude application for inductor) ") 
if((Recommend == 1) then

 inddmy_sz2 =  geomSize( inddmy -50.5 noClipAcute )   
 utm40kc1_ind_m6 = geomButtOrOver( m6 inddmy_sz2  )   
 utm40kc11_ind_m6v5 = geomButtOrOver( via5 utm40kc1_ind_m6  )   
 utm40kc12_ind_m5 = geomButtOrOver( m5 utm40kc11_ind_m6v5  )   
 utm40kc13_ind_m5v5 = geomButtOrOver( via5 utm40kc12_ind_m5  )   
 utm40kc14_ind_m6_conn = geomButtOrOver( m6 utm40kc13_ind_m5v5  )   
 utm40kc15_ind_m6_all = geomOr(utm40kc1_ind_m6 utm40kc14_ind_m6_conn)  
 utm40kc16_im6 = geomAnd(utm40kc15_ind_m6_all inddmy)  
 utm40kc17_rm6 = geomAndNot(m6 utm40kc15_ind_m6_all)  
 utm40kc18_om6 = geomAndNot(utm40kc15_ind_m6_all utm40kc16_im6)  
 drc( utm40kc17_rm6 utm40kc16_im6  sep < 50  shielded withIntersection withSingularPoint 
	"UTM40K.C.1  Min. clearance from M6 as inductor to M6 >= 50 um ")  
 drc( utm40kc16_im6 utm40kc18_om6 0 < sep < 50  shielded  app > 0 parallel withIntersection 
	"UTM40K.C.1 2  Min. clearance from M6 as inductor to M6 >= 50 um ")
) ; 
 drc( inddmy m6 0 < enc < 50  shielded withIntersection withSingularPoint 
	"UTM40K.E.3  Min. extension of INDDMY beyond M6 >= 50 um ")  
 errorLayer( geomAnd(inddmyi m1) 
	"UTM40K.I.1  No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect, and the M1 substrate pick up node of inductor ") 
 errorLayer( geomAnd(inddmy via1) 
	"UTM40K.I.1 2  No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect, and the M1 substrate pick up node of inductor ") 
 errorLayer( geomAnd(inddmy m2) 
	"UTM40K.I.1 3  No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect, and the M1 substrate pick up node of inductor ") 
 errorLayer( geomAnd(inddmy via2) 
	"UTM40K.I.1 4  No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect, and the M1 substrate pick up node of inductor ") 
 errorLayer( geomAnd(inddmy m3) 
	"UTM40K.I.1 5  No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect, and the M1 substrate pick up node of inductor ") 
 errorLayer( geomAnd(inddmy via3) 
	"UTM40K.I.1 6  No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect, and the M1 substrate pick up node of inductor ") 
 errorLayer( geomAnd(inddmy2 m4) 
	"UTM40K.I.1 7  No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect, and the M1 substrate pick up node of inductor ") 
 errorLayer( geomAnd(inddmy2 via4) 
	"UTM40K.I.1 8  No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect, and the M1 substrate pick up node of inductor ") 
 errorLayer( geomAnd(inddmy nwel) 
	"UTM40K.I.2  Both active and passive devices not allow inside INDDMY besides guard ring ") 
 errorLayer( geomAnd(inddmy poly) 
	"UTM40K.I.2 2  Both active and passive devices not allow inside INDDMY besides guard ring ") 
 errorLayer( geomAnd(inddmyi od) 
	"UTM40K.I.2 3  Both active and passive devices not allow inside INDDMY besides guard ring ") /* exclude M1 substrate pick up node of inductor */
) ; 
) ; 
/*  DNW CHECKS */
/* ============== */
 rw = geomAndNot(dnw nwel)  /*  RW is PW in DNW */
if((C016 == 0) then
 drc( dnw   width < 3  withCornerTouch 
	"DNW.W.1  Min. width of a DNW region >= 3um ")  
 drc( dnw   sepNotch < 5  
	"DNW.S.1  Min. space between two DNW regions >= 5um ")  
) ; 
if((Recommend == 1) then
geomConnect( incremental
	buttOrOver(ptapi pweli)
)
dnws2_rw_nodal = geomCat( rw )
geomStamp(dnws2_rw_nodal pweli)  
dnws21_pwel_nodal = geomCat( pwel )
geomStamp(dnws21_pwel_nodal pweli)  
 drc( dnws2_rw_nodal dnws21_pwel_nodal  sep < 1.4  diffNet withIntersection withSingularPoint 
	"DNW.S.2  Min. space between RW and {RW OR PW} with different potential >= 1.4um ")  
) ; 
 drc( dnw nwel  ovlp < 2.0  shielded withIntersection withSingularPoint 
	"DNW.O.1  Min. overlap from a NW edge to a DNW region >= 2.0um ")  
geomConnect( incremental
	buttOrOver(nwel dnw)
)
 drc( nwel dnw  sep < 3.5  diffNet withIntersection withSingularPoint 
	"DNW.C.1  Min. clearance from DNW to NW >= 3.5um ")  
 dnwc4_a = geomAndNot(pwel dnw)  
 dnwc41_b = geomButtOrOver( npod dnwc4_a  )   
 drc( dnwc41_b dnw  sep < 3.0  shielded withIntersection withSingularPoint 
	"DNW.C.4  Min. clearance from DNW to N+OD outside NW >= 3.0um ")  
 errorLayer( geomStraddle( dnwc41_b dnw  ) 
	"DNW.C.4 2  Min. clearance from DNW to N+OD outside NW >= 3.0um ")  
if((Recommend == 1) then
/*  DNW.R.3 is a recommended rule and un-checkable. */
 drc( nwel dnw  enc < 1.5  shielded withIntersection withSingularPoint 
	"DNW.E.1  Min. extension of NW beyond DNW for a better noise isolation >= 1.5um ")  
 dnw_not1 =  geomAndNot(dnw geomButtOrOver(dnw sbddmy ))   
 errorLayer( geomGetEdge(dnw_not1 outside nwel) 
	"DNW.E.1 2  Min. extension of NW beyond DNW for a better noise isolation >= 1.5um ")  
) ; 
 dnwe2_a = geomAnd(pwel dnw)  
 dnwe21_b = geomButtOrOver( npod dnwe2_a  )   
 drc( dnw dnwe21_b  enc < 1.5  shielded withIntersection withSingularPoint 
	"DNW.E.2  Min. extension of DNW beyond N+OD outside NW >= 1.5um ")  
 errorLayer( geomStraddle( dnwe21_b dnw  ) 
	"DNW.E.2 2  Min. extension of DNW beyond N+OD outside NW >= 1.5um ")  
 errorLayer( geomAnd(dnw rwdmy) 
	"DNW.R.4  It is not allowed to use DNW as a resistor ") 
 errorLayer( geomButtOrOver( rnwel dnw  ) 
	"DNW.R.5  It is not allowed to use {NW interact DNW} as a resistor ")  
 errorLayer( geomButtOrOver( nwres dnw  ) 
	"DNW.R.5 2  It is not allowed to use {NW interact DNW} as a resistor ")  
if((C016 == 1) then
 drc( dnw   width < 3.3  withCornerTouch 
	"DNW.W.1 2  Min. DNW width < 3.3 ")  
 drc( dnw   sepNotch < 5.5  
	"DNW.S.1 2  Min. DNW space < 5.5 ")  
) ; 
/* VTM_N */
/* ===== */
 drc( vtmn   width < 0.74  withCornerTouch 
	"VTM_N.W.1  Min. dimension of a VTM_N region >= 0.74um ")  
 vtm_nw2_z = geomGetEdge(gate_w inside vtmn)   
 drc( vtm_nw2_z   width < 0.3  
	"VTM_N.W.2  Min. PO gate dimension of a 1.8V medium Vt NMOS >= 0.3um ")  
 vtm_nw3_z = geomGetEdge(hv_ngate_w inside vtmn)   
 drc( vtm_nw3_z   width < 0.6  
	"VTM_N.W.3  Min. PO gate dimension of a 3.3V medium Vt NMOS >= 0.6um ")  
 drc( vtmn   sepNotch < 0.44  
	"VTM_N.S.1  Min. space between two VTM_N regions >= 0.44um ")  
 drc( vtmn nact  enc < 0.26  shielded withIntersection withSingularPoint 
	"VTM_N.E.1  Min. extension from a VTM_N region beyond an N+OD region >= 0.26um ")  
 errorLayer( geomStraddle( nact vtmn  ) 
	"VTM_N.E.1 2  Min. extension from a VTM_N region beyond an N+OD region >= 0.26um ")  
 drc( nact vtmn  sep < 0.7  shielded withIntersection withSingularPoint 
	"VTM_N.C.1  Min. clearance from a VTM_N region to an N+OD region >= 0.7um ")  
 drc( vtmn nwel  sep < 0.43  shielded withIntersection withSingularPoint 
	"VTM_N.C.2  Min. clearance from a VTM_N region to an NW edge >= 0.43um ")  
 errorLayer( geomAnd(vtmn nwel) 
	"VTM_N.C.2 2  Min. clearance from a VTM_N region to an NW edge >= 0.43um ") 
 errorLayer( geomAnd(vtmn ntn) 
	"VTM_N.R.2  VTM_N interact NT_N is not allowed ") 
 errorLayer( geomAnd(vtmn gate_pp) 
	"VTM_N.R.3  A P+ Gate is not allowed in VTM_N region ") 
 vtm_nr4_vtmn_po = geomAnd(poly vtmn)  
 errorLayer( geomGetVertex(vtm_nr4_vtmn_po ignore == 4) 
	"VTM_N.R.4  A bent PO region is not allowed in VTM_N region ")  
 vtm_nr5_vtmn_od = geomAnd(vtmn od)  
 drc( vtm_nr5_vtmn_od poly_iso 0 < sep < 0.26  shielded withIntersection withSingularPoint 
	"VTM_N.R.5  Min. clearance from an OD region in VTM_N region to a PO on field oxide >= 0.26um ")  
/*  VTM_P */
/* ====== */
 drc( vtmp   width < 0.74  withCornerTouch 
	"VTM_P.W.1  Min. dimension of a VTM_P region >= 0.74um ")  
 vtm_pw2_z = geomGetEdge(gate_w inside vtmp)   
 drc( vtm_pw2_z   width < 0.25  
	"VTM_P.W.2  Min. PO gate dimension of a 1.8V medium Vt PMOS >= 0.25um ")  
 drc( vtmp   sepNotch < 0.44  
	"VTM_P.S.1  Min. space between two VTM_P regions >= 0.44um ")  
 drc( vtmp pact  enc < 0.26  shielded withIntersection withSingularPoint 
	"VTM_P.E.1  Min. extension from a VTM_P region beyond a P+OD region >= 0.26um ")  
 errorLayer( geomStraddle( pact vtmp  ) 
	"VTM_P.E.1 2  Min. extension from a VTM_P region beyond a P+OD region >= 0.26um ")  
 drc( pact vtmp  sep < 0.7  shielded withIntersection withSingularPoint 
	"VTM_P.C.1  Min. clearance from a VTM_P region to a P+OD region >= 0.7um ")  
 drc( nwel vtmp  enc < 0.43  shielded withIntersection withSingularPoint 
	"VTM_P.C.2  Min. clearance from a VTM_P region to a PW edge >= 0.43um ")  
 errorLayer( geomAndNot(vtmp nwel) 
	"VTM_P.C.2 2  Min. clearance from a VTM_P region to a PW edge >= 0.43um ") 
 errorLayer( geomAnd(vtmp ntn) 
	"VTM_P.R.2  VTM_P interact NT_N is not allowed ") 
 errorLayer( geomAnd(vtmp od2) 
	"VTM_P.R.3  VTM_P interact OD2 is not allowed. ") 
 errorLayer( geomAnd(vtmp gate_np) 
	"VTM_P.R.4  A N+ Gate is not allowed in VTM_P region ") 
 vtm_pr5_vtmp_po = geomAnd(poly vtmp)  
 errorLayer( geomGetVertex(vtm_pr5_vtmp_po ignore == 4) 
	"VTM_P.R.5  A bent PO region is not allowed in VTM_P region ")  
 vtm_pr6_vtmp_od = geomAnd(vtmp od)  
 drc( vtm_pr6_vtmp_od poly_iso 0 < sep < 0.26  shielded withIntersection withSingularPoint 
	"VTM_P.R.6  Min. clearance from an OD region in VTM_P region to a PO on field oxide >= 0.26um ")  
/* HRI   */
/* ===   */
 drc( hri   width < 0.44  withCornerTouch 
	"HRI.W.1  Min. width of a HRI region >= 0.44um ")  
 drc( hri   sepNotch < 0.44  
	"HRI.S.1  Min. space between two HRI regions >= 0.44um ")  
 hric1_x = drc( hri np  sep < 0.26  shielded withIntersection withSingularPoint )
 errorLayer( geomAndNot(hric1_x geomButtOrOver(hric1_x butt_ptap )) 
	"HRI.C.1  Min. clearance from an HRI region to an NP region >= 0.26um ")  

; hric11_y = geomGetEdge(np butting hri)   
;hric11_y_11 = geomSize(hric11_y 0.001 edges)
;hric11_y_21 = geomSize(hric11_y -0.001 edges)
; hric12_z = geomOr(hric11_y_11 hric11_y_21)   
; errorLayer( geomAndNot(hric12_z geomButtOrOver(hric12_z butt_ptap )) 
;	"HRI.C.1 2  Min. clearance from an HRI region to an NP region >= 0.26um ")  

 drc( hri pp  sep < 0.26  shielded withIntersection withSingularPoint 
	"HRI.C.2  Min. clearance from an HRI region to a PP region >= 0.26um ")  
 drc( hri all_gate  sep < 0.32  shielded withIntersection withSingularPoint 
	"HRI.C.3_C.4  Min. clearance from an HRI edge to Poly gate >= 0.32um ")  
 drc( hri pores  enc < 0.26  shielded withIntersection withSingularPoint 
	"HRI.E.1  Min. enclosure from an HRI region beyond a PO resistor region >= 0.26um ")  
 pores_not1 =  geomAndNot(pores geomOutside(pores hri ))   
 errorLayer( geomAndNot(pores_not1 hri) 
	"HRI.E.1 2  Min. enclosure from an HRI region beyond a PO resistor region >= 0.26um ") 
 errorLayer( geomAnd(hri np) 
	"HRI.R.1  Overlap of NP and HRI is not allowed ") 
 errorLayer( geomAnd(hri od) 
	"HRI.R.2  Overlap of OD and HRI is not allowed ") 
 drc( hri  area < 0.3844 
	"HRI.A.1  Min. area of a HRI region >= 0.3844um2 ") 
/*  CTM CHECK */
/* ============ */
 tctm = geomButtOrOver( ctm5 via5  )  /*  True CTM */ 
 dctm = geomAndNot(ctm5 geomButtOrOver(ctm5 via5 ))  /*  Dummy CTM */ 
bpm5 = geomSizeAnd( tctm m5 0.28* 0.7 2 )  /*  CBM = TCTM SIZE 2 */
 dpm5 = geomButtOrOver( m5 dctm  )  /*  M5 as a dummy CBM */ 
 bpm5c = geomGetEdge(bpm5 coincident m5)   
 drc( tctm   width < 4.0  withCornerTouch 
	"CTM.W.1  Min. width of a CTM region >= 4.0um ")  
 drc( dctm   width < 0.4  withCornerTouch 
	"CTM.W.2  Min. width of a dummy CTM region >= 0.4um ")  
 drc( tctm   sepNotch < 1.2  
	"CTM.S.1  Min. space between two CTM regions >= 1.2um ")  
 drc( dctm tctm  sep < 0.8  shielded withIntersection withSingularPoint 
	"CTM.S.2  Min. space between a dummy CTM and a CTM region or two dummy CTM regions >= 0.8um ")  
 drc( dctm   sepNotch < 0.8  
	"CTM.S.2 2  Min. space between a dummy CTM and a CTM region or two dummy CTM regions >= 0.8um ")  

processCoverage(
	precision = 6
         
	measure( 
             ctm5i_den_pc = layerList( ctm5i )
             ctm5i_den2 = output(ctm5i_den_pc  0 < keep < 0.03)
        ); end measure
  );end processCovearage
  errorLayer( ctm5i_den2 
	"CTM.R.2  Min. density of all CTM area >= 3% ") 
/* CTM.R.3 is not necessary to check */
 errorLayer( geomEncloseRect( tctm 30.005 4 manhattanOnly) 
	"CTM.W.4  Max. dimension (one side) of a CTM region <= 30um ") /*  4um is min TCTM width */ 
 errorLayer( geomEncloseRect( dctm 30.005 0.4 manhattanOnly) 
	"CTM.W.4 2  Max. dimension (one side) of a CTM region <= 30um ") /*  0.4um is min DCTM width */ 
 drc( ctm5  area < 0.202 
	"CTM.A.1  Min. area of CTM region >= 0.202um2 ") 
/* CTM.R.1 is checked by MIM_M5.E.3 */
 errorLayer( geomCat(ctm2) 
	"CTM.R.5  The MIM capacitor must be placed between M6 amd M5 ")  
 errorLayer( geomCat(ctm3) 
	"CTM.R.5 2  The MIM capacitor must be placed between M6 amd M5 ")  
 errorLayer( geomCat(ctm4) 
	"CTM.R.5 3  The MIM capacitor must be placed between M6 amd M5 ")  
/*  MIM_M5 CHECK */
/* ============== */
 errorLayer( geomWidth(  bpm5 keep > 35   ) 
	"MIM_M5.W.1  Max. dimension (both width and length) of M5 as MIM capacitor bottom metal <= 35um ")  
 drc( bpm5c  0 <  sepNotch < 0.8  
	"MIM_M5.S.1  Min. space between two M5 regions as MIM capacitor bottom metal >= 0.8um ")  
 drc( bpm5c dpm5  sep < 0.8  shielded withIntersection 
	"MIM_M5.S.2  Min. space between one M5 region as a dummy MIM capacitor bottom metal and  the other M5 region as MIM capacitor bottom metal >= 0.8um ")  
 drc( m5 ctm5  enc < 0.4  shielded withIntersection withSingularPoint 
	"MIM_M5.E.3  Minimum extension of an M5 resgion as MIM capacitor bottom metal beyound  a CTM resgion and dummy CTM region >=0.40um  ")  
 errorLayer( geomAndNot(ctm5 m5) 
	"MIM_M5.E.3 2  Minimum extension of an M5 resgion as MIM capacitor bottom metal beyound  a CTM resgion and dummy CTM region >=0.40um  ") 
/*  MIMVIA CHECK */
/* =============== */
 ctmv5 = geomAnd(via5 ctm5)  /*  VIA5 locate on CTM */
 via5_and1 =  geomAnd(via5 bpm5)  /*  VIA5 locate on CBM */
 cbmv5 = geomAndNot(via5_and1 ctm5)  /*  VIA5 locate on CBM */
geomConnect( incremental
	buttOrOver(ctmv5 tctm)
	buttOrOver(cbmv5 bpm5)
)
 drc( ctmv5   sep < 2.0  sameNet shielded 
	"MIMVIA.S.1  Min. space between two VIA5 on the same CTM >= 2.0um ")  
 drc( cbmv5   sep < 4.0  sameNet shielded 
	"MIMVIA.S.2  Min. space between two VIA5 on the same M5 as MIM capacitor bottom metal >= 4.0um ")  
 drc( ctm5 via5  enc < 0.24  shielded withIntersection withSingularPoint 
	"MIMVIA.E.1  Min. extension of a CTM region beyond a VIA5 region >= 0.24um ")  
 errorLayer( geomStraddle( via5 ctm5  ) 
	"MIMVIA.E.1 2  Min. extension of a CTM region beyond a VIA5 region >= 0.24um ")  
 drc( bpm5c via4  enc < 0.12  shielded withIntersection 
	"MIMVIA.E.2  Min. extension of an M5 region as MIM capacitor bottom metal beyond a VIA4 or a VIA5 region >= 0.12um ")  
 drc( bpm5c via5  enc < 0.12  shielded withIntersection 
	"MIMVIA.E.2 2  Min. extension of an M5 region as MIM capacitor bottom metal beyond a VIA4 or a VIA5 region >= 0.12um ")  
 drc( via4 ctm5  sep < 0.4  shielded withIntersection withSingularPoint 
	"MIMVIA.C.1  Min. clearance of a VIA4 or a VIA5 to a CTM region >= 0.4um ")  
 drc( via5 ctm5  sep < 0.4  shielded withIntersection withSingularPoint 
	"MIMVIA.C.1 2  Min. clearance of a VIA4 or a VIA5 to a CTM region >= 0.4um ")  

     processAntenna(
                    gate((tctm ctmv5))
                    antenna( ctmv5 )
                    ratio = ctmv5.area/tctm.area
         	    MIMVIAR1 = drcAntenna( ctmv5 tctm ratio keep < 0.01   suppressErrorMessage )
                   )
     errorLayer( MIMVIAR1_tctm	"MIMVIA.R.1  Min. density of VIA5 on CTM >= 1% ")

 errorLayer( geomAnd(via4 ctm5) 
	"MIMVIA.R.3  VIA4 under CTM region is not allowed ") 
/* ================SBD rules Check================================ */
 ppod_and1 =  geomAnd(ppod pwel)  
 ppod_and1_and1 =  geomAnd(ppod_and1 rfdummy)  
 ppod_and1_and11 =  geomAndNot(ppod_and1_and1 dnw)  
ppod_and1_and116 = geomHoles(ppod_and1_and11 innermost )
 ppod_and1_and111 =  ppod_and1_and116  
 ppod_sbd_h = geomEnclose( ppod_and1_and111 sbdod  )   
 errorLayer( geomGetLength( ppod_sbd_w 0 < keep < 1 ) 
	"SBD.W.1_SBD.W.1.1  Minimum width of an OD region to define the width of the P+ active OD region of the SBD. >=1.0um <= 16.0um ")  
 errorLayer( geomGetLength(ppod_sbd_w 16 < keep < 999 contiguous ) 
        "SBD.W.1_SBD.W.1.1 2  Minimum width of an OD region to define the width of the P+ active OD region of the SBD. >=1.0um <= 16.0um ")  
 errorLayer( geomGetLength( ppod_sbd_l 0 < keep < 1 ) 
	"SBD.W.2_SBD.W.2.1  Minimum length of an OD region to define the length of the P+ active OD region of the SBD. >=1.0um <=4.0um ")  
 errorLayer( geomGetLength(ppod_sbd_l 4 < keep < 999 contiguous ) 
	"SBD.W.2_SBD.W.2.1 2  Minimum length of an OD region to define the length of the P+ active OD region of the SBD. >=1.0um <=4.0um ")  
 errorLayer( geomAndNot( npod_sbd geomContactCheck( npod_sbd   swap allWithTolerance=1.0) )
	"SBD.W.3  Minimum and Maximum length of an OD region to define the length of the NP OD region of the SBD.==0.42um ")
 drc( npod_sbd   width < 0.42  withCornerTouch 
	"SBD.W.3 2  Minimum and Maximum length of an OD region to define the length of the NP OD region of the SBD.==0.42um ")  
 errorLayer( geomWidth(  npod_sbd keep > 0.42   ) 
	"SBD.W.3 3  Minimum and Maximum length of an OD region to define the length of the NP OD region of the SBD.==0.42um ")  
 errorLayer( geomAndNot(npod_sbd_w geomGetEdge(npod_sbd_w butting ppod_sbd_g)) 
	"SBD.W.4  The width of NP OD region of the SBD must be equal to P+ active OD region of the SBD. ")  
 errorLayer( geomAndNot(ppod_sbd_w geomGetEdge(ppod_sbd_w butting npod_sbd_g)) 
	"SBD.W.4 2  The width of NP OD region of the SBD must be equal to P+ active OD region of the SBD. ")  
 drc( ppod_sbd npod_sbd  sep < 0.48  shielded withIntersection withSingularPoint 
	"SBD.S.1  Space between P+ active OD region and NP OD region of the SBD ==0.48um ")  
 errorLayer( geomButtOrOver( ppod_sbd npod  ) 
	"SBD.S.1 2  Space between P+ active OD region and NP OD region of the SBD ==0.48um ")  
 errorLayer(  geomAndNot(ppod_sbd geomButtOnly(geomOutside(ppod_sbd ppod_sbd_g) ppod_sbd_g keep == 2)) 
	"SBD.S.1 4  Space between P+ active OD region and NP OD region of the SBD ==0.48um ")  
 sbds1_a = geomButtOnly(geomOutside(ppod_sbd ppod_sbd_g) ppod_sbd_g keep == 2)   
 sbds11_b = geomGetEdge( sbds1_a butting ppod_sbd_g wholeEdge ) 

 sbds12_c = drc( sbds11_b width < 0.48 with_perp )
 errorLayer( geomButtOrOver( ppod_sbd sbds12_c  ) 
	"SBD.S.1 6  Space between P+ active OD region and NP OD region of the SBD ==0.48um ")  

 sbde1_x = geomOr(ppod_sbd npod_sbd)  
 sbde11_y = geomSize( sbde1_x 0.8 noClipAcute )   
 errorLayer( geomXor(sbde11_y nw_sbd) 
	"SBD.E.1  Minimum and maximum extension from NW edge to an OD region used for the SBD. ==0.80um ") 
 sbde2_x = geomSize( ppod_sbd 0.22 noClipAcute )   
 errorLayer( geomXor(sbde2_x pp_sbd_all) 
	"SBD.E.2  Minimum and maximum extension of a PP region beyond an enclosed P+ active OD region of the SBD.==0.22um ") 
 sbdo1_x = geomSize( ppod_sbd -0.22 noClipAcute )   
 errorLayer( geomXor(sbdo1_x pp_sbd_hole) 
	"SBD.O.1  Minimum and maximum overlap from a PP edge to a P+ active OD region of the SBD.==0.22um ") 
 drc( dnw_sbd nw_sbd  enc < 0.6  shielded withIntersection withSingularPoint 
	"SBD.E.1.1  Minimum extension of DNW beyond NW for a better noise isolation.>=0.60um ")  
 errorLayer( geomStraddle( nw_sbd dnw_sbd  ) 
	"SBD.E.1.1 2  Minimum extension of DNW beyond NW for a better noise isolation.>=0.60um ")  
 errorLayer( geomXor(sbddmy nw_sbd) 
	"SBD.E.3  Maximum and Minimum extension of SBDDMY beyond NW==0.00um ") 
/* SBD.R.1 is checked by SBD.S.1 { @ The P+ active OD region of the SBD must be located between the NP OD regions. */
/*           The NP OD region must be located parallel with the width of the P+ active OD region at left and right sides. */
 sbdr2_x = geomButtOrOver( sbddmy ppod_sbd keep < 17 )   
 sbdr21_y = geomAndNot(sbddmy sbdr2_x)  
 errorLayer( geomButtOrOver( ppod_sbd sbdr21_y  ) 
	"SBD.R.2  Maximum Finger Number of the P+ active OD region of the SBD should be <=16um ")  
 errorLayer( geomAndNot(nw_sbd ppod_sbd_h) 
	"SBD.R.3  The each NW of SBD should be surrounded by the P+ Guard Ring (P+ pickup ring). ") 
 errorLayer( geomButtOrOver( ppod_sbd_h sbdod_all keep > 1 ) 
	"SBD.R.3 2  The each NW of SBD should be surrounded by the P+ Guard Ring (P+ pickup ring). ")  
 errorLayer( geomButtOrOver( ppod_sbd_h nw_sbd keep > 1 ) 
	"SBD.R.3 4  The each NW of SBD should be surrounded by the P+ Guard Ring (P+ pickup ring). ")  
 errorLayer( geomAndNot(sbddmy rfdummy) 
	"SBD.R.4  Use RFDUMMY to fully cover SBD and P+ Guard Ring for LVS to recognize RF Device.COMMENT4309 ") 
 errorLayer( geomAndNot(nw_sbd rfdummy) 
	"SBD.R.4 2  Use RFDUMMY to fully cover SBD and P+ Guard Ring for LVS to recognize RF Device.COMMENT4309 ") 
 errorLayer( geomAndNot( pp_sbd_hole geomContactCheck( pp_sbd_hole   swap allWithTolerance=1.0) )
	"SBD.R.5  PP for SBD must be a rectangle ring. PP rectangle ring must surround OD. Other shape is not allowed. ")  
 errorLayer( geomAndNot( pp_sbd_all geomContactCheck( pp_sbd_all   swap allWithTolerance=1.0) )
	"SBD.R.5 2  PP for SBD must be a rectangle ring. PP rectangle ring must surround OD. Other shape is not allowed. ")  
/* SBD.R.7R don't need check.  */
) ; 

)
