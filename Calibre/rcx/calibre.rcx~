// xCalibre/calibre  RC/LVS command file based on the follow calibre command file//
/////////////////////////////////////////////////////////////////////////////////
// 
// 
// 
//  @(#) TSMC 0.18UM CALIBRE LVS/RC COMMAND FILE 
//  @(#) TSMC 0.18um Mixed-Signal RF SALICIDE(1P6M+, 1.8V/3.3V) 
//  @(#) SPICE MODEL DOCUMENT : T-018-CM-SP-018    V1.0    
//  @(#) COMMAND FILE DOCUMNET: T-018-CM-SP-018-C1 V1.0c 
//  @(#) EDA TOOL VERSION: CALIBRE_FLOW: Calibre v2007.3_36.25 
//  @(#)  
//  @(#) COMMAND FILE DOCUMENT: T-018-CM-SP-018-C1  
//  @(#) COMMAND FILE VERSION : V1.0c 
//  @(#) COMMAND FILE METAL SCHEME: 1P6M  
//  @(#) COMMAND FILE DATE: 12/02/2009 
// 
//  TSMC has developed this deck using Mentor Graphics proprietary SVRF and TVF formats.  
//  The deck is to be used only in Calibre tools.  
// 
//////////////////////////////////////////////////////////////////////////////// 
// 
// DISCLAIMER 
// 
// This file usually contains the super set of device extraction rule at TSMC
// processes. However, all of device in basic deck may not be offered at current
// SPICE model. PLEASE ALWAYS REFER TO THE CORRESPONDING SPICE MODEL DOCUMENT
// FOR ANY DEVICE YOU WOULD LIKE USE.
// 
// The information contained herein is provided by TSMC on an "AS IS" basis 
// without any warranty, and TSMC has no obligation to support or otherwise 
// maintain the information.  TSMC disclaims any representation that the 
// information does not infringe any intellectual property rights or proprietary 
// rights of any third parties.  There are no other warranties given by TSMC, 
// whether express, implied or statutory, including, without limitation, implied 
// warranties of merchantability and fitness for a particular purpose. 
// 
// STATEMENT OF USE 
// 
// This information contains confidential and proprietary information of TSMC. 
// No part of this information may be reproduced, transmitted, transcribed, 
// stored in a retrieval system, or translated into any human or computer 
// language, in any form or by any means, electronic, mechanical, magnetic, 
// optical, chemical, manual, or otherwise, without the prior written permission 
// of TSMC.  This information was prepared for informational purpose and is for 
// use by TSMC's customers only.  TSMC reserves the right to make changes in the 
// information at any time and without notice. 
// 
//////////////////////////////////////////////////////////////////////////////// 
// 
//                            CHANGE HISTORY 
//  
//   Date     version   Who                      Description 
// ---------- ------- --------- ---------------------------------------------------------- 
//    10/05/2009  v1.0a  tmwub	    1) New deck 
//				    2) moscap_rf and moscap_rf33 in this CR018GPII deck are not identical with those  
//				       two 018 rf moscap in old days. Following list the differences(DMW and properties). 
// 
//			    CR018GPII deck: 
//			    moscap_rf       Varactor on thin  oxide : w/i DNW and properties BR, GR, LR and WR   
//			    moscap_rf33     Varactor on thick oxide : w/i DNW and properties BR, GR, LR and WR 
//			    moscap_rf_nw    Varactor on thin  oxide : w/o DNW and properties BR, GR, LR and WR   
//			    moscap_rf33_nw  Varactor on thick oxide : w/o DNW and properties BR, GR, LR and WR  
//					        
//			    Other 018 decks: 
//			    moscap_rf       Varactor on thin  oxide : doesn't care DNW and w/i properties A, PJ, B and G   
//			    moscap_rf33     Varactor on thick oxide : doesn't care DNW and w/i properties A, PJ, B and G  
// 
//				    3) Because 0.18um DRM allow stacking devices under RF mimcap w/i shield and 2T  
//				       baseband mimcap, we add new mimcap_1p0_sin, mimcap_2p0_sin and mimcap_2p0_shield  
//				       with new DUMMY layer : RFDUMMY(drawing3)=(160;50) and CTMDMY(drawing5)=(131;50).  
// 
//				    4) Add a switch "OD_RES_WO_DMNP2V" : Default is off. This switch is for 2T/3T non-silicide OD resistor. 
//				       If turn off it, 2T/3T non-silicide P+ OD resistors should w/i DMP2V.  
//				                       2T/3T non-silicide N+ OD resistors should w/i DMN2V.  
// 
//    11/26/2009	v1.0b	tmwub	    1) Revise WPE for IO pmos. 
// 
//    12/02/2009	v1.0c   tmwub	    1) Revise connection of spiral inductor. 
// 
//////////////////////////////////////////////////////////////////////////////// 
// 
// 
// 
//                              
//                             DEVICE FORMULA 
//   ----- ----------------------------- ---------------------------------- 
//   NAME  DESCRIPTION                   DEVICE LAYER OPERATION 
//   ----- ----------------------------- ---------------------------------- 
//   GENERIC DEVICE 
//   --------------------------------------------------------------------- 
//   M[N]           CORE Nominal VT NMOS          ((NGATE-OD2-NTN)-DNW)  
//   M[N1]          CORE Nominal VT NMOS/DNW      ((NGATE-OD2-NTN)*DNW)  
//   M[NL]          CORE native device            ((NGATE-OD2)*NTN)  
//   M[NN]          I/O  native device            ((NGATE*OD2)*NTN)  
//   M[ND]          I/O  Nominal VT NMOS          ((NGATE*OD2-NTN)-DNW)  
//   M[N2]          I/O  Nominal VT NMOS/DNW      ((NGATE*OD2-NTN)*DNW)  
//   M[NA]          CORE medium  VT NMOS          ((NGATE-OD2-NTN)-DNW*VTMN) 
//   M[NB]          I/O  medium  VT NMOS          ((NGATE*OD2-NTN)-DNW*VTMN) 
//   M[PA]          CORE medium  VT PMOS          (PGATE-OD2*VTMP) 
//   M[P]           CORE Nominal VT PMOS          (PGATE-OD2) 
//   M[PD]          I/O  Nominal VT PMOS          (PGATE*OD2) 
//   R[PR]          P+Poly resistor w/o Silicide  (RPDMYX*POLY1*PIMP*RPO*DMP2V-RFDUMMY)  
//   R[NR]          N+Poly resistor w/o Silicide  (RPDMYX*POLY1*NIMP*RPO*DMN2V-RFDUMMY)  
//   R[PS]          P+Poly resistor w/i Silicide  (RPDMYX*POLY1*PIMP-RPO-RFDUMMY)  
//   R[NS] 	  N+Poly resistor w/i Silicide  (RPDMYX*POLY1*NIMP-RPO-RFDUMMY)  
//   R[WR]          N-Well resister under STI     (RWDMYX*NWELL-(OD*RPO))  
//   R[LR]          HRI high resistance poly R    (RPDMYX*POLY1*HRI*RLPPDMY*RPO-NIMP-PIMP-RFDUMMY)  
//   R[WO]          N-Well resistor under OD      (RWDMYX*NWELL*(OD*RPO))  
//   R[PD]          P+diff resistor w/o Silicide  (RPDMYX*NWELL*OD*PIMP*RPO-RFDUMMY*DMP2V)  
//   R[ND] 	  N+diff resistor w/o Silicide  (RPDMYX*OD*NIMP*RPO-RFDUMMY*DMN2V)  
//   R[PI] 	  P+diff resistor w/i Silicide  (RPDMYX*NWELL*OD*PIMP-RPO-RFDUMMY)  
//   R[NI]   	  N+diff resistor w/i Silicide  (RPDMYX*OD*NIMP-RPO-RFDUMMY)  
//   R[M1] 	  METAL1 resistor               (RMDMY1*METAL1)  
//   R[M2] 	  METAL2 resistor               (RMDMY2*METAL2)  
//   R[M3] 	  METAL3 resistor               (RMDMY3*METAL3)  
//   R[M4] 	  METAL4 resistor               (RMDMY4*METAL4)  
//   R[M5] 	  METAL5 resistor               (RMDMY5*METAL5)  
//   R[MT]	  METAL6 resistor               (RMDMY6*METAL6)  
//   mimcap_1p0_sin     Baseband 2T mimcap 1.0fF    (CTMDMY*CTM5*M5-CTMDMY_3t-IP_MIG)  
//   mimcap_1p0_sin_3t  Baseband 3T mimcap 1.0fF    (CTMDMY*CTM5*M5*CTMDMY_3t-IP_MIG)  
//   mimcap_2p0_sin     Baseband 2T mimcap 2.0ff    (CTMDMY*CTMDMY2p0*CTM5*M5-CTMDMY_3t-IP_MIG)  
//   mimcap_2p0_sin_3t  Baseband 3T mimcap 2.0ff    (CTMDMY*CTMDMY2p0*CTM5*M5*CTMDMY_3t-IP_MIG)   
//   D[DP]	  CORE diode P+/NW              (DIODMY*OD*PIMP-OD2*anwel)  
//   D[D1]	  I/O  diode P+/NW              (DIODMY*OD*PIMP*OD2*anwel)  
//   D[DN]	  CORE diode N+/PW              (DIODMY*OD*NIMP-OD2*PSUB)  
//   D[D2]	  I/O  diode N+/PW              (DIODMY*OD*NIMP*OD2*PSUB)  
//   D[DW]	  CORE diode NW/PW              (DIODMY*anwel-OD2)  
//   D[D3]	  I/O  diode NW/PW              (DIODMY*anwel*OD2)  
//   D[ndio_m]      CORE diode N+/PW with VTMN    (DIODMY*OD*NIMP*VTMN*PSUB-OD2) 
//   D[ndio_3m]     I/O diode N+/PW with VTMN     (DIODMY*OD*NIMP*VTMN*PSUB*OD2) 
//   D[pdio_m]      CORE diode P+/NW with VTMN    (DIODMY*OD*PIMP*VTMP*anwel-OD2) 
//   D[DB]	  I/O  ESD diode                (ESD3DMY*OD*NIMP*RPO-NWELL-POLY1) 
//   D[dnwpsub]     DNW/PSUB diode		(DNW*PSUB*anwel) 
//   D[pwdnw]       PSUB(R-WELL)/DNW diode	(DNW*PSUB-anwel) 
// 
//   Q[PV]	  CORE PNP-BJT                  (BJTDMY*OD*PIMP-OD2*NWELL)  
//   Q[PV_mis]	  CORE PNP-BJT                  (BJTDMY*LVSDMY*OD*PIMP-OD2*NWELL)  
//   Q[NV_mis]      CORE NPN-BJT		        (BJTDMY*LVSDMY*OD*NIMP-OD2*NWELL*DNW) 
//   Q[NV]          CORE NPN-BJT		        (BJTDMY*OD*NIMP-OD2*NWELL*DNW) 
//   Q[P1]	  I/O  PNP-BJT                  (BJTDMY*OD*PIMP*OD2*NWELL)  
//   rnwod_m         N-Well resistor under OD      (RWDMY1*NWELL*(OD*RPO))  
//   rpodrpo_m       P+diff resistor w/o Silicide  (RPDMY1*OD*PIMP*RPO*NWELL*DMP2V)  
//   rnodrpo_m       N+diff resistor w/o Silicide  (RPDMY1*OD*NIMP*RPO*DMN2V)  
//   rpod_m          P+diff resistor w/i Silicide  (RPDMY1*OD*PIMP-RPO*NWELL)  
//   rnod_m          N+diff resistor w/i Silicide  (RPDMY1*OD*NIMP-RPO)  
//   rpodw_m         P+diff resistor w/i Silicide  (RPDMY1*OD*PIMP-RPO*NWELL)  
//   rnodw_m         N+diff resistor w/i Silicide  (RPDMY1*OD*NIMP-RPO) 
//   rnwsti_m        N-well resistor under STI     (RWDMY1*NWELL-(OD*RPO))  
//   rnpo1rpo_dis     N+Poly resistor w/o Silicide(distributed)  (RPDMY1*POLY1*NIMP*RPO*DMN2V)  
//   rppo1rpo_dis     P+Poly resistor w/o Silicide(distributed)  (RPDMY1*POLY1*PIMP*RPO*DMP2V)  
//   rnpo1w_dis       N+Poly resistor w/i Silicide(distributed)  (RPDMY1*POLY1*NIMP-RPO)  
//   rppo1w_dis       P+Poly resistor w/i Silicide(distributed)  (RPDMY1*POLY1*PIMP-RPO)  
//   rppolyhri_dis    HRI High poly resistor                     (RPDMY1*POLY1*HRI*RLPPDMY*RPO-NIMP-PIMP)  
//   rnpo1_dis        N+Poly resistor w/i Silicide(distributed)  (RPDMY1*POLY1*NIMP-RPO)  
//   rppo1_dis        P+Poly resistor w/i Silicide(distributed)  (RPDMY1*POLY1*PIMP-RPO)  
//   nmoscap        CORE NMOS Varactor            (VARGT-OD2-RFDUMMY) 
//   nmoscap_33      I/O  NMOS Varactor            (VARGT*OD2-RFDUMMY) 
// 
//   crtmom         Baseband RTMOM                (M1*M2*MOMDMY1*MOMDMY2*POLY1-RFDUMMY1-MOMDMY100-MOMDMY22) 
//   cfmom          Baseband FMOM w/i poly shielding     (M1*M2*MOMDMY1*MOMDMY2*POLY1*NIMP-RFDUMMY1*MOMDMY100-MOMDMY22) 
//   cfmom_mx       Baseband FMOM w/i poly shielding(MX) (M1*M2*MOMDMY1*MOMDMY2*POLY1*NIMP-RFDUMMY1*MOMDMY100*MOMDMY22*MOMDMY23*MOMDMY24*MOMDMY25) 
//   --------------------------------------------------------------------- 
//   MM/RF DEVICE 
//   --------------------------------------------------------------------- 
//   nmos_rf         CORE Nominal VT NMOS/DNW      ((RFNGATE-OD2-ESD3DMY-NTN)*DRAIN*DNW*RFDUMMY1)  
//   nmos_rf33       I/O  Nominal VT NMOS/DNW      ((RFNGATE*OD2-ESD3DMY-NTN)*DRAIN*DNW*RFDUMMY1)  
//   pmos_rf         CORE Nominal VT PMOS/DNW      (RFPGATE-OD2*DRAIN*DNW*RFDUMMY1)  
//   pmos_rf_nw      CORE Nominal VT PMOS          (RFPGATE-OD2*DRAIN-DNW*RFDUMMY1)  
//   pmos_rf33       I/O  Nominal VT PMOS/DNW      (RFPGATE*OD2*DRAIN*DNW*RFDUMMY1)  
//   pmos_rf33_nw    I/O  Nominal VT PMOS          (RFPGATE*OD2*DRAIN-DNW*RFDUMMY1)  
// 
//   nmos_rf_6t      CORE Nominal VT NMOS/DNW(6T)  ((RFNGATE-OD2-ESD3DMY-NTN)*DRAIN*DNW*RFDUMMY1*RFDUMMY6T)  
//   nmos_rf33_6t    I/O  Nominal VT NMOS/DNW(6T)  ((RFNGATE*OD2-ESD3DMY-NTN)*DRAIN*DNW*RFDUMMY1*RFDUMMY6T)  
//   pmos_rf_5t      CORE Nominal VT PMOS/DNW(5T)  (RFPGATE-OD2*DRAIN*DNW*RFDUMMY1*RFDUMMY5T)  
//   pmos_rf_nw_5t   CORE Nominal VT PMOS    (5T)  (RFPGATE-OD2*DRAIN-DNW*RFDUMMY1*RFDUMMY5T)  
//   pmos_rf33_5t    I/O  Nominal VT PMOS/DNW(5T)  (RFPGATE*OD2*DRAIN*DNW*RFDUMMY1*RFDUMMY5T)  
//   pmos_rf33_nw_5t I/O  Nominal VT PMOS    (5T)  (RFPGATE*OD2*DRAIN-DNW*RFDUMMY1*RFDUMMY5T)     
//   moscap_rf       Varactor on thin oxide  w/i DNW (VARDMY*NWELL*NIMP*POLY1*RFDUMMY1*-OD2*DNW)  
//   moscap_rf33     Varactor on thick oxide w/i DNW (VARDMY*NWELL*NIMP*POLY1*RFDUMMY1*OD2*DNW) 
//   moscap_rf_nw    Varactor on thin oxide  w/o DNW (VARDMY*NWELL*NIMP*POLY1*RFDUMMY1*-OD2-DNW)  
//   moscap_rf33_nw  Varactor on thick oxide w/o DNW (VARDMY*NWELL*NIMP*POLY1*RFDUMMY1*OD2-DNW) 
//   rppolyhri_rf    HRI resistor                  (RPDMYX*POLY1*HRI*RLPPDMY*RPO*DNW*RFDUMMY1-NIMP-PIMP) 
//   rppolywo_rf     P+Poly resistor w/o Silicide  (RPDMYX*POLY1*PIMP*RPO*DMP2V*DNW*RFDUMMY1)  ( W > 5.0 ) 
//   rppolyl_rf      P+Poly resistor w/i Silicide  (RPDMYX*POLY1*PIMP*DNW*RFDUMMY1-RPO)        ( W >= 2.0 ) 
//   rppolys_rf      P+Poly resistor w/i Silicide  (RPDMYX*POLY1*PIMP*DNW*RFDUMMY1-RPO)        ( W < 2.0 ) 
// 
//   mimcap_2p0_wos  CTM/M5 capacitor           (CTM5*CTMDMY2p0*M5*RFDUMMY1)  
//   mimcap_2p0_shield CTM/M5 capacitor           (CTM5*CTMDMY2p0*M5*RFDUMMY1*M4)  
//   spiral_std_mu_x_20k     Std Inductor 20k ALCU UTM    (INDDMY*METAL6) 
//   spiral_sym_mu_x_20k     Sym Inductor 20k ALCU UTM    (INDDMY*METAL6) 
//   spiral_sym_ct_mu_x_20k  Sym CT Inductor 20k ALCU UTM (INDDMY*METAL6*METAL4*IND_D4) 
// 
// 
//   xjvar_nr36    Junction Varactor             (JVARD*OD-POLY1*NWELL*NIMP*PIMP*RFDUMMY1)  
//   xjvar_w40     Junction Varactor             (JVARD*OD-POLY1*NWELL*NIMP*PIMP*RFDUMMY1) 
//   sbd_rf         RF Schottky Diode w/i DNW        (SBDUMMY*RFDUMMY1*PIMP*NIMP*NWELL*OD*DNW) 
//   sbd_rf_nw      RF Schottky Diode w/o DNW        (SBDUMMY*RFDUMMY1*PIMP*NIMP*NWELL*OD-DNW) 
//   lcesd1_rf		   low capacitance ESD (50fF)	(OD*PIMP*RFDUMMY1*ESD2DUMMY*lcesd1*lcesd_p*lcesd_m) 
//   lcesd2_rf		   low capacitance ESD(100fF)	(OD*PIMP*RFDUMMY1*ESD2DUMMY*lcesd2*lcesd_p*lcesd_m) 
// 
//   cfmom_rf       RF FMOM w/i poly shielding   (M1*M2*MOMDMY1*MOMDMY2*POLY1*NIMP*RFDUMMY1*MOMDMY100-MOMDMY22) 
//   ----- ----------------------------- ------------------------------------------------------------------------------------- 
//   * NGATE = OD * POLY1 * NIMP - NWELL  
//   * PGATE = OD * POLY1 * PIMP * NWELL  
//   * PSUB = BULK 
//   * anwel = NWELL  
//   * VARDMY = VARDMYX -VARG3 -VARG6 -JVARD 
//   * VARGT = OD * POLY1 * NIMP * NWELL * VARDMYX 
//   * METAL1 = M1  
//   * RMDMY1 = RMDMY1i 
//   * METAL2 = M2  
//   * RMDMY2 = RMDMY2i 
//   * METAL3 = M3  
//   * RMDMY3 = RMDMY3i 
//   * METAL4 = M4  
//   * RMDMY4 = RMDMY4i 
//   * METAL5 = M5  
//   * RMDMY5 = RMDMY5i 
//   * METAL6 = M6  
//   * RMDMY6 = RMDMY6i 
//   * RFNGATE = OD * POLY1 * NIMP - NWELL  
//   * RFPGATE = OD * POLY1 * PIMP * NWELL  
//   * RFDUMMY = RFDUMMYX + RFDUMMY1  
//   * RFDUMMY1 = RFDUMMY1 - RFDUMMYX 
//  
//////////////////////////////////////////////////////////////////////////////// 
// 
// 
//////////////////////////////////////////////////////////////////////////////// 
// USER NOTES : 
// 
// 1) mnpg, mppg, ppvdd49, npvss49 are obtained in a LVS run. 
// 
// 2) For Calibre "EDTEXT" file, use .INCLUDE strings.txt. 
//        LAYOUT TEXT  "text string" [x] [y]  (layer num) (cell name) 
// 
// 3) Input layer 'OD' is defined as thin oxide (OD) area which would  
//    be drawn by one generic od mask or by seperated N+OD and P+OD. 
//    Remove layers in the 'OD' entries you don't want to use at  
//    layer definition block. 
// 
// 4) Default setting for property check is 0%. Users should check with 
//    IP/Designe providers for proper tolerance. 
// 
// 5) It's recommended to run Calibre LVS by hierarchical mode since false 
//    errors have been encountered by only flat mode option '-lvs'. 
// 
// 6) Default property resolution for ambiguity is set to 32. It could be 
//    necessary to increase this setting to resolve serious ambiguity. 
//    Uncomment statement 'LVS PROPERTY RESOLUTION MAXIMUM' in this deck 
//    to reset the capability of property resolution. 
// 
// 7) This deck default not to extracts MOS AS/AD property. To turn on the 
//    extraction of MOS AS/AD property, please uncomment the line 
//    "#DEFINE extract_as_ad". It would cause SEED PROMOTION, and pose 
//    much overhead on layout netlist extraction, erc checks, and lvs comparison. 
//  
// 8) For MOS capacitors, AS and AD values are calculated by combining the total amount of source and drain area for  
//    the device and splitting up the result evenly between AS and AD. PS and PD values are similarily calculated by  
//    evenly splitting up the total amount of source and drain perimeter. This is valid since simulation results for MOS  
//    capacitors should not depend on how AS/AD and PS/PD are split up between source and drain. 
// 
// 9) "VIRTUAL CONNECT COLON YES" : By default, VIRTUAL CONNECT COLON is set yes.  
//    Please set to NO as doing full-chip checking 
// 
// 10) So far, only 0.18um process 2T BB mimcap and rf mimcap w/i shield support stacking mimcap. 
//    If this LVS deck is 0.18um process and w/i rf devices, it will support device under mimcap.  
//    And please do not put metal resistor w/i RMDMY(69;0) under the mimcap. 
// 
// 
//////////////////////////////////////////////////////////////////////////////// 
//lvs_gen.pl version: 1.86
//calibre.pl version: 1.120

// LVS/RC switch option
// --------------------
#define RC_DECK    //uncomment this line when this deck would be used as a RC command file
//#define ZERO_NRS_NRD    //uncomment this line when this deck would set NRS=0 and NRD=0 
//#define FILTER_DGS_TIED_MOS // uncomment this line to filter MOS with D, G and S tied together (default filter MOS with all pins tied)
#define WELL_TO_PG_CHECK 
// Default is on. Turn on to highlight if nwell connects to ground or psub connects to power.
//#define GATE_TO_PG_CHECK 
// Default is off. Turn on to highlight if a mos gate directly connects to power or ground.
//#define PATH_CHECK 
// Default is off. Turn on to highlight if
//(1) nodes have a path to power but no path to ground
//(2) nodes have a path to ground but no path to power
//(3) nodes have no path to power or ground
//(4) nodes have no path to any label net
#define DS_TO_PG_CHECK 
// Default is on. Turn on to highlight if drain connects to power and source connects to ground.
#define FLOATING_GATE_CHECK 
// Default is on. Turn on to highlight if there are floating gates.
#define FLOATING_WELL_CHECK 
// Default is on. Turn on to highlight if well does not connect to power or ground. 
//The nwell of moscaps and nwell-resistor are excluded.

VARIABLE WPED 5.0
VARIABLE PRESCALE 1.0

//#define NW_RING	//uncomment this line to enable the NW ring to separate the node from BULK

// POWER and GROUND name string variable setting
VARIABLE POWER_NAME  "AVD33"  "AVD33B"  "AVD33G"  "AVD33R"  "AVD33WELL"  "AVDD"  "AVDDB"  "AVDDBG"  "AVDDG"  "AVDDR"  "AVDWELL"  "DVDD"  "TAVD33"  "TAVD33PST"  "TAVDD"  "TAVDDPST"  "VD33"  "VD33WELL"  "VDD"  "VDD5V"  "VDDG"  "VDDM"  "VDDPST"  "VDDSA"  "VDWELL" 

VARIABLE GROUND_NAME  "AGND"  "AVS33"  "AVS33B"  "AVS33G"  "AVS33R"  "AVS33SUB"  "AVSS"  "AVSSB"  "AVSSBG"  "AVSSG"  "AVSSR"  "AVSSUB"  "DVSS"  "GND"  "TAVSS"  "TAVSSPST"  "VS33"  "VS33SUB"  "VSS"  "VSSG"  "VSSM"  "VSSPST"  "VSSUB" 

//#########################################################################
//# ENVIRONMENT SETTING                              
//#########################################################################
// LVS option
// --------------------
//#define extract_as_ad
//

//  RC_BLOCKING SETTING
LAYOUT CELL LIST pcells "cfmom*" "cfmom_mx*" "cfmom_rf*" "crtmom*" "lcesd1_rf*" "lcesd2_rf*" "mimcap_rf_2p0*" "mimcap_rf_2p0*" "moscap_rf*" "moscap_rf33*" "moscap_rf33_nw*" "moscap_rf_nw*" "rfnmos2v*" "rfnmos3v*" "rfnmos3v_6t*" "rfnmos2v_6t*" "rfpmos2v*" "rfpmos3v*" "rfpmos3v_5t*" "rfpmos3v_nw*" "rfpmos3v_nw_5t*" "rfpmos2v_5t*" "rfpmos2v_nw*" "rfpmos2v_nw_5t*" "rphripoly_rf*" "rplpoly_rf*" "rplpoly_rf*" "rphpoly_rf*" "sbd_rf*" "sbd_rf_nw*" "spiral_std_mu_x_20k*" "spiral_sym_ct_mu_x_20k*" "spiral_sym_mu_x_20k*" "jvar*" "jvar*" 
LAYOUT PRESERVE CELL LIST pcells


//  Sheet Resistance table
    VARIABLE    RVM1  	0.078		//  Metal-1  resistor
    VARIABLE    RVM2  	0.078		//  Metal-2  resistor
    VARIABLE    RVM3  	0.078		//  Metal-3  resistor
    VARIABLE    RVM4  	0.078		//  Metal-4  resistor
    VARIABLE    RVM5  	0.078		//  Metal-5  resistor
    VARIABLE    RV40K  	0.007		//  40K Metal resistor
    VARIABLE    RVMT  	0.0178		//  Top Metal resistor
    VARIABLE    RVLR  	1037		//  HRI high resistance poly R 
    VARIABLE    RVWR  	927		//  NWell resistor under STI
    VARIABLE    RVWO  	440		//  NWell resistor under OD
    VARIABLE    RVPR  	321.8		//  P+Poly resistor w/o Silicide
    VARIABLE    RVNR  	295.3		//  N+Poly resistor w/o Silicide
    VARIABLE    RVPD  	140.6		//  P+Diff resistor w/o Silicide
    VARIABLE    RVND  	61.6		//  N+Diff resistor w/o Silicide
    VARIABLE    RVPS  	7.9		//  P+Poly resistor w/i Silicide
    VARIABLE    RVNS   	7.89		//  N+Poly resistor w/i Silicide 
    VARIABLE    RVPI  	7.76		//  P+Diff resistor w/i Silicide 
    VARIABLE    RVNI   	6.82		//  N+Diff resistor w/i Silicide
    VARIABLE    MIM_CA  1.025   	//  Mimcap Area Cap.
    VARIABLE    MIM_CF  .2425  		//  Mimcap Perimeter Cap
    VARIABLE    MIM_CA_2P0  1.955   	//  Mimcap_2p0 Area Cap.
    VARIABLE    MIM_CF_2P0  .27  	//  Mimcap_2p0 Perimeter Cap

    
//#load table_rsf_cal // load table values here
LVS HEAP DIRECTORY "/tmp"

//uncomment the following line, non-silicide OD resistors should w/o DMN2V or DMP2V
//#DEFINE OD_RES_WO_DMNP2V
    
//uncomment the following line to enable use of 2.0 fF mimcaps. Switch is set for user based on which folder deck is copied from in Main_Deck folder
#DEFINE CAP_2P0        


//uncomment the following line to apply the extraction of these two diodes, PWDNW and DNWPSUB 
//#DEFINE extract_dnwdio

//RESISTANCE VALUE VARIABLE SETTING    
//#DEFINE ACCURACY

//By default, macro models are not netlisted. Please turn on this switch to enable "_mac" models.
//#DEFINE MACRO

#IFDEF RC_DECK
 #DEFINE ACCURACY
#ENDIF

//#define STD_LIB
#IFDEF STD_LIB       // for tsmc N90 STD library, to estimate well proximity effect on STD cell.
	VARIABLE	NMOS_BOT_EXT 	0.86*1e-6
	VARIABLE	PMOS_TOP_EXT 	1.09*1e-6
	VARIABLE	MOS_LR_EXT 	100.0*1e-6
#ELSE
	VARIABLE	NMOS_BOT_EXT 	0
	VARIABLE	PMOS_TOP_EXT 	0
	VARIABLE	MOS_LR_EXT 	0
#ENDIF

LAYOUT PRIMARY "ts_allcelllvs"
LAYOUT PATH "ts_allcelllvs.gds"
LAYOUT SYSTEM GDSII
//LAYOUT PATH "layout.net"
//LAYOUT SYSTEM SPICE

SOURCE PRIMARY "ts_allcelllvs"
SOURCE PATH "ts_allcelllvs.cdl"
SOURCE SYSTEM SPICE

DRC RESULTS DATABASE "calibre_drc.db" ASCII // ASCII or GDSII
DRC SUMMARY REPORT "calibre_drc.sum"

ERC RESULTS DATABASE "calibre_erc.db" ASCII
ERC SUMMARY REPORT "calibre_erc.sum"

LVS REPORT "lvs.rep"
LVS REPORT MAXIMUM 1000 // ALL

#IFDEF RC_DECK
  //MASK RESULTS DATABASE NONE //"mask.db"
#ELSE
  MASK RESULTS DATABASE NONE //"mask.db"
#ENDIF

#IFDEF RC_DECK
  //MASK SVDB DIRECTORY "svdb" QUERY
#ELSE
  MASK SVDB DIRECTORY "svdb" QUERY
#ENDIF
LVS ISOLATE SHORTS YES
LVS REPORT OPTION S

PRECISION 1000
RESOLUTION 1
UNIT LENGTH U

#IFDEF RC_DECK
  //UNIT CAPACITANCE FF
#ELSE
  UNIT CAPACITANCE FF
#ENDIF

TEXT DEPTH PRIMARY
PORT DEPTH PRIMARY

FLAG SKEW YES
FLAG OFFGRID YES

LVS SPICE PREFER PINS	       YES
LVS ABORT ON SUPPLY ERROR      NO
LVS ALL CAPACITOR PINS SWAPPABLE YES
LVS RECOGNIZE GATES            NONE
LVS IGNORE PORTS               NO
LVS CHECK PORT NAMES          YES
LVS REDUCE PARALLEL BIPOLAR    YES
LVS REDUCE PARALLEL MOS        YES
LVS REDUCE PARALLEL DIODES     YES
LVS REDUCE PARALLEL CAPACITORS YES
LVS REDUCE PARALLEL RESISTORS  YES
LVS REDUCE SERIES RESISTORS    YES      //Smashes series resistors
LVS REDUCE SERIES CAPACITORS   YES      //Smashes series capacitors
LVS REDUCE SPLIT GATES         NO       //Smashes MOS split-gates.
//LVS FILTER UNUSED OPTION B D E O
//Strongly recommand to comment FILTER_DGS_TIED_MOS switch
//AG is to filter MOS with all pins tied together, AB is to filter MOS with D,G,S tied together
#IFNDEF FILTER_DGS_TIED_MOS
LVS FILTER UNUSED OPTION AG RC RE RG
#ELSE
LVS FILTER UNUSED OPTION AB RC RE RG
#ENDIF
//LVS PROPERTY RESOLUTION MAXIMUM 1000 // ALL


// should be modify
LAYOUT TOP LAYER M1 VIA1 M2 VIA2i M3 VIA3i M4 VIA4i M5 VIA5i M6
VIRTUAL CONNECT COLON YES
LVS POWER NAME POWER_NAME 
LVS GROUND NAME GROUND_NAME 
//#############################################
//# MAPPING                                   #
//#############################################
LAYER PWELLX          1  //  P-Well   for cis 
LAYER DMP2V           149  //  dummy layer to avoid P2V in P+ poly resistor
LAYER DMN2V           184  //  dummy layer to avoid N2V in N+ poly resistor
LAYER VTMP            23  //   blocking region of PMOS VT implantation
LAYER VTMN            24  //   blocking region of NMOS VT implantation
LAYER DNW             82  //  Deep N-Well
LAYER NWELL           2  //  N-Well
LAYER NTN             129  //  Native Device Blocked Implant
LAYER OD              11  12  3  //  thin oxide
LAYER DOD            300 
LAYER MAP 3 DATATYPE 1 300 //  OD dummy fill
LAYER OD2             4  //  Thick Oxide Definition
LAYER POLY1           13  //  Poly Si
LAYER DPO            301 
LAYER MAP 13 DATATYPE 1 301 //  Poly Si dummy
LAYER PIMP            7  //  P+ S/D Implantation
LAYER NIMP            8  //  N+ S/D Implantation
LAYER VTDN            26  // 
LAYER HRI             48  //  High Resistor Implant
LAYER CONT            15  //  Contact
LAYER M1              16  //  Metal-1
LAYER VIA1            17  //  Via1 Hole
LAYER M2              18  //  Metal-2
LAYER VIA2i           27  //  Via2 Hole
LAYER M3              28  //  Metal-3
LAYER VIA3i           29  //  Via3 Hole
LAYER M4              31  //  Metal-4
LAYER VIA4i           32  //  Via4 Hole
LAYER M5              33  //  Metal-5
LAYER VIA5i           39  //  Via5 Hole
LAYER M6              38  //  Metal-6
LAYER RPO             34  //  Non-salicide OD Area Definition
LAYER PSUB2           50  //  apply for subtract2 ground
LAYER RODMY           75  //  dummy layer to remove OD
LAYER BJTDMY          49  //  BJT dummy layer to form BJT
LAYER DIODMY          37  56  //  dummy layer to form diode
LAYER RWDMYX          52  //  dummy layer to form N-Well resistor
LAYER RPDMYX          132  54  //  dummy layer to form OD/POLY resistor
LAYER RLPPDMY         134  //   dummy layer to form High_Poly resistor
LAYER RMDMY          302 
LAYER MAP 69 DATATYPE 0 302 //  dummy layer to form METAL resistor
LAYER RMDMY1i        303 
LAYER MAP 69 DATATYPE 1 303 //  dummy layer to form METAL1 resistor
LAYER RMDMY2i        304 
LAYER MAP 69 DATATYPE 2 304 //  dummy layer to form METAL2 resistor
LAYER RMDMY3i        305 
LAYER MAP 69 DATATYPE 3 305 //  dummy layer to form METAL3 resistor
LAYER RMDMY4i        306 
LAYER MAP 69 DATATYPE 4 306 //  dummy layer to form METAL4 resistor
LAYER RMDMY5i        307 
LAYER MAP 69 DATATYPE 5 307 //  dummy layer to form METAL5 resistor
LAYER RMDMY6i        308 
LAYER MAP 69 DATATYPE 6 308 //  dummy layer to form METAL6 resistor
LAYER PV_P            71  //  pmos varactor P+ implant layer
LAYER PV_N            72  //  pmos varactor N+ blocking layer
LAYER INDDMY          139  //  dummy layer to form spiral inductor
LAYER IND_RAD        309 
LAYER MAP 139 DATATYPE 30 309 //  For RF Inductor devices radious
LAYER IND_GDIS       310 
LAYER MAP 139 DATATYPE 31 310 //  For RF Inductor devices guardring distance
LAYER IND_NR         311 
LAYER MAP 139 DATATYPE 32 311 //  For RF Inductor devices turns
LAYER IND_MP         312 
LAYER MAP 139 DATATYPE 33 312 //  For RF Inductor devices mimus pin 
LAYER IND_D4         313 
LAYER MAP 139 DATATYPE 34 313 //  For RF Inductor devices CTAP pin 
LAYER IND_W          314 
LAYER MAP 139 DATATYPE 35 314 //  For RF Inductor devices width 
LAYER IND_S          315 
LAYER MAP 139 DATATYPE 36 315 //  For RF Inductor devices space 
LAYER VARDMYX         138  //  dummy layer to form Varactor
LAYER ESD3DMY         234  //  ESD3DMY
LAYER RFDUMMYX        160  //  FOR normal RF device dummy layer
LAYER RFDUMMY1       316 
LAYER MAP 160 DATATYPE 1 316 //  FOR RF device additional terminal dummy layer
LAYER RFDUMMY5T      317 
LAYER MAP 160 DATATYPE 3 317 //  For RF_5T Device using only
LAYER RFDUMMY6T      318 
LAYER MAP 160 DATATYPE 4 318 //  For RF_6T Device using only
LAYER RFDUMMYUD      319 
LAYER MAP 160 DATATYPE 50 319 //  Please change RFDMY to be RFDMYUD to allow putting devices under w/i shield RF mimcap Devices (mimcap use only)
LAYER asym_rf        320 
LAYER MAP 160 DATATYPE 2 320 //  FOR RF device special recognition. 
LAYER VARG3          321 
LAYER MAP 138 DATATYPE 1 321 //  dummy layer for RF mos varactor moscap_g3
LAYER VARG6          322 
LAYER MAP 138 DATATYPE 2 322 //  dummy layer for RF mos varactor moscap_g6
LAYER JVARD          323 
LAYER MAP 138 DATATYPE 3 323 //  dummy layer for RF junction varactor xjvar
LAYER CTM2           324 
LAYER MAP 67 DATATYPE 2 324 //  Capacitor Top Metal-2
LAYER CTM3           325 
LAYER MAP 67 DATATYPE 3 325 //  Capacitor Top Metal-3
LAYER CTM4           326 
LAYER MAP 67 DATATYPE 4 326 //  Capacitor Top Metal-4
LAYER CTM5           327 
LAYER MAP 67 DATATYPE 5 327 //  Capacitor Top Metal-5
LAYER CTMDMY         328 
LAYER MAP 131 DATATYPE 0 328 //  dummy layer for MIMCAP
LAYER CTMDMY1p0      329 
LAYER MAP 131 DATATYPE 10 329 //  dummy layer for MIMCAP (1p0)
LAYER CTMDMY1p5      330 
LAYER MAP 131 DATATYPE 15 330 //  dummy layer for MIMCAP (1p5)
LAYER CTMDMY2p0      331 
LAYER MAP 131 DATATYPE 20 331 //  dummy layer for MIMCAP (2p0)
LAYER CTMDMY_3t      332 
LAYER MAP 131 DATATYPE 21 332 //  dummy layer for MIMCAP (3t)
LAYER CTMDMYUD       333 
LAYER MAP 131 DATATYPE 50 333 //  Please add CTMDMYUD to allow putting devices under 2T BB mimcap Devices (mimcap use only)
LAYER PLMIDE         334 
LAYER MAP 89 DATATYPE 0 334 //  Polyimide
LAYER VIAD            167  //  VIA between MD and Mtop
LAYER MD              168  //  RDL layer (Cu)
LAYER CBD             169  //  
LAYER UBM             170  //  Under bump metal
LAYER TSVI            251  //  i-TSV (in-process through-silicon-via etching)
LAYER DTSVI          335 
LAYER MAP 251 DATATYPE 1 335 //  dummy pattern of I-TSV
LAYER DUM1           336 
LAYER MAP 16 DATATYPE 1 336 //  dummy metal M1
LAYER DUM2           337 
LAYER MAP 18 DATATYPE 1 337 //  dummy metal M2
LAYER DUM3           338 
LAYER MAP 28 DATATYPE 1 338 //  dummy metal M3
LAYER DUM4           339 
LAYER MAP 31 DATATYPE 1 339 //  dummy metal M4
LAYER DUM5           340 
LAYER MAP 33 DATATYPE 1 340 //  dummy metal M5
LAYER DUM6           341 
LAYER MAP 38 DATATYPE 1 341 //  dummy metal M6
LAYER M1SLOT         342 
LAYER MAP 16 DATATYPE 2 342 //  M1 slot
LAYER M2SLOT         343 
LAYER MAP 18 DATATYPE 2 343 //  M2 slot
LAYER M3SLOT         344 
LAYER MAP 28 DATATYPE 2 344 //  M3 slot
LAYER M4SLOT         345 
LAYER MAP 31 DATATYPE 2 345 //  M4 slot
LAYER M5SLOT         346 
LAYER MAP 33 DATATYPE 2 346 //  M5 slot
LAYER M6SLOT         347 
LAYER MAP 38 DATATYPE 2 347 //  M6 slot
LAYER DRAIN          348 
LAYER MAP 3 DATATYPE 3 348 //  Drain layer for mos drain terminal
LAYER RWDMY1         349 
LAYER MAP 52 DATATYPE 1 349 //  dummy layer to form N-Well resistor 3 terminals
LAYER RPDMY1         350 
LAYER MAP 54 DATATYPE 1 350 //  dummy layer to form OD/POLY resistor 3 terminals
LAYER SBDUMMY        351 
LAYER MAP 144 DATATYPE 0 351 //  dummy layer to form schottky diode
LAYER MOMDMY0        352 
LAYER MAP 145 DATATYPE 0 352 //  MOM dummy for crtmom
LAYER MOMDMY1        353 
LAYER MAP 145 DATATYPE 1 353 //  MOM dummy for crtmom
LAYER MOMDMY2        354 
LAYER MAP 145 DATATYPE 2 354 //  MOM dummy for crtmom
LAYER MOMDMY3        355 
LAYER MAP 145 DATATYPE 3 355 //  MOM dummy for crtmom
LAYER MOMDMY4        356 
LAYER MAP 145 DATATYPE 4 356 //  MOM dummy for crtmom
LAYER MOMDMY5        357 
LAYER MAP 145 DATATYPE 5 357 //  MOM dummy for crtmom
LAYER MOMDMY6        358 
LAYER MAP 145 DATATYPE 6 358 //  MOM dummy for crtmom
LAYER MOMDMY22       359 
LAYER MAP 145 DATATYPE 22 359 //  MOM dummy for MX mom
LAYER MOMDMY23       360 
LAYER MAP 145 DATATYPE 23 360 //  MOM dummy for MX mom plus1 & minus1
LAYER MOMDMY24       361 
LAYER MAP 145 DATATYPE 24 361 //  MOM dummy for MX mom plus2 & minus2
LAYER MOMDMY25       362 
LAYER MAP 145 DATATYPE 25 362 //  MOM dummy for MX mom plus1 & plus2
LAYER MOMDMY100      363 
LAYER MAP 145 DATATYPE 100 363 //  MOM dummy for fmom
LAYER LVSDMY         364 
LAYER MAP 208 DATATYPE 1 364 //  LVS dummy layer for mismatch device
LAYER IP_MIG         365 
LAYER MAP 63 DATATYPE 180 365 //  Non-shrinkable dummy layer for mimcap
LAYER CELLM          366 
LAYER MAP 133 DATATYPE 0 366 //  Define blocking region of Cell VT implantation for medium VT NMOS 
LAYER CELLH          367 
LAYER MAP 133 DATATYPE 1 367 //  Define Cell High VT implantation (only for standard CIS)
LAYER NPS            368 
LAYER MAP 133 DATATYPE 2 368 //  Define N type photo sensor implantation
LAYER PL             369 
LAYER MAP 133 DATATYPE 3 369 //  
LAYER GM             370 
LAYER MAP 133 DATATYPE 4 370 // 
LAYER RM             371 
LAYER MAP 133 DATATYPE 5 371 // 
LAYER BM             372 
LAYER MAP 133 DATATYPE 6 372 // 
LAYER ML             373 
LAYER MAP 133 DATATYPE 7 373 // 
LAYER PPS            374 
LAYER MAP 133 DATATYPE 8 374 //  Define P type photo sensor implantation
LAYER NMOS_VT        375 
LAYER MAP 133 DATATYPE 9 375 //  For logic VT implant
LAYER CI             376 
LAYER MAP 133 DATATYPE 10 376 //  
LAYER CIRPO          377 
LAYER MAP 133 DATATYPE 11 377 //  Define od salicide protection in pixel
LAYER GM1            378 
LAYER MAP 133 DATATYPE 12 378 // 
LAYER GM2            379 
LAYER MAP 133 DATATYPE 13 379 // 
LAYER CELLD          380 
LAYER MAP 133 DATATYPE 14 380 // 
LAYER BGP            381 
LAYER MAP 133 DATATYPE 21 381 // 
LAYER BGN            382 
LAYER MAP 133 DATATYPE 22 382 // 
LAYER CELL_TX        383 
LAYER MAP 133 DATATYPE 23 383 // 
LAYER CELL_RS        384 
LAYER MAP 133 DATATYPE 24 384 // 
LAYER CAP_IMP        385 
LAYER MAP 133 DATATYPE 25 385 //  polycap implant
LAYER CELL_SL        386 
LAYER MAP 133 DATATYPE 30 386 //  
LAYER BASE_N         387 
LAYER MAP 250 DATATYPE 1 387 // 
LAYER LDDMY          388 
LAYER MAP 127 DATATYPE 0 388 //  dummy layer to cover HVMOS area 
LAYER SH_P           389 
LAYER MAP 141 DATATYPE 1 389 //  layer to define 5V PW implant area for HV device
LAYER ESD2DUMMY      390 
LAYER MAP 137 DATATYPE 0 390 //  for lcesd1_rf and lcesd2_rf devices
LAYER lcesd1         391 
LAYER MAP 160 DATATYPE 5 391 //  dummy layer for lcesd1_rf device
LAYER lcesd2         392 
LAYER MAP 160 DATATYPE 6 392 //  dummy layer for lcesd2_rf device
LAYER lcesd_p        393 
LAYER MAP 160 DATATYPE 7 393 //  dummy layer for rf lcesd device's PLUS pin
LAYER lcesd_m        394 
LAYER MAP 160 DATATYPE 8 394 //  dummy layer for rf lcesd device's MINUS pin
LAYER IND_TEXT       395
LAYER MAP 139 TEXTTYPE 37 395
TEXT LAYER 40 ATTACH 40 metal1
PORT LAYER TEXT 40
TEXT LAYER 41 ATTACH 41 metal2
PORT LAYER TEXT 41
TEXT LAYER 42 ATTACH 42 metal3
PORT LAYER TEXT 42
TEXT LAYER 43 ATTACH 43 metal4
PORT LAYER TEXT 43
TEXT LAYER 44 ATTACH 44 metal5
PORT LAYER TEXT 44
TEXT LAYER 45 ATTACH 45 metal6
PORT LAYER TEXT 45
#IFDEF RC_DECK
TEXT LAYER 47 ATTACH 47 poly
PORT LAYER TEXT 47
#ENDIF

#IFNDEF RC_DECK
LAYER MAP 47 TEXTTYPE 1 396
TEXT LAYER 396 ATTACH 396 poly
PORT LAYER TEXT 396
#ENDIF
//#############################################
//# LOGIC OPERATION POOL                      #
//#############################################

//Form BULK layer
DRC:1 = EXTENT
BULK  = SIZE DRC:1 BY 0.005

//* Define device -- nmos N
rpoly = POLY1 OR DPO 
p1hr1 = rpoly AND RPO 
RPDMYa = RPDMYX OR RPDMY1 
diff1 = OD OR DOD 
diff = diff1 NOT RODMY 
rpa = RPDMYa NOT INTERACT diff 
prduma = rpa INTERACT rpoly 
rpop1 = p1hr1 INTERACT prduma 
hripo1 = rpop1 AND HRI 
hripo2 = hripo1 AND RLPPDMY 
hripo3 = hripo2 NOT NIMP 
hripo4 = hripo3 NOT PIMP 
lrpop1 = hripo4 NOT RFDUMMY1 
lrpop2 = lrpop1 INTERACT POLY1 
poly1a = rpoly NOT lrpop2 
lrpop_rf = hripo4 AND RFDUMMY1  //  RF HRI high poly resistor
poly2 = poly1a NOT lrpop_rf 
rpop = rpop1 NOT INTERACT hripo1 
poly3 = poly2 NOT rpop 
p1lr1 = rpoly AND prduma 
rpip = p1lr1 NOT INTERACT RPO 
poly4 = poly3 NOT rpip  //  Interconnect poly
MOMDMYall_0 = MOMDMY0 OR MOMDMY1 
MOMDMYall_1 = MOMDMYall_0 OR MOMDMY2 
MOMDMYall_2 = MOMDMYall_1 OR MOMDMY3 
MOMDMYall_3 = MOMDMYall_2 OR MOMDMY4 
MOMDMYall_4 = MOMDMYall_3 OR MOMDMY5 
MOMDMYall_5 = MOMDMYall_4 OR MOMDMY6 
poly = poly4 NOT MOMDMYall_5 
dfhr1 = diff AND RPO 
RPDMY = RPDMYX NOT RPDMY1 
drdum = RPDMY INTERACT diff  //  diff resistor dummy
rdop1 = dfhr1 INTERACT drdum 
mdiff1 = diff NOT rdop1 
dflr1 = diff AND drdum 
rdip = dflr1 NOT INTERACT RPO 
mdiff2 = mdiff1 NOT rdip 
t_rdop1 = dfhr1 INTERACT RPDMY1 
t_rdop2 = t_rdop1 INTERACT OD 
RFDUMMY = RFDUMMYX NOT RFDUMMY1 
t_rdop = t_rdop2 NOT RFDUMMY 
mdiff3 = mdiff2 NOT t_rdop 
t_dflr1 = diff AND RPDMY1 
t_rdip1 = t_dflr1 NOT INTERACT RPO 
t_rdip = t_rdip1 INTERACT OD 
mdiff = mdiff3 NOT t_rdip 
gate = poly AND mdiff 
gate_rf1 = gate AND RFDUMMY1 
poly_rf1 = poly INTERACT CONT 
poly_rf = poly_rf1 INTERACT DRAIN 
gate_rf2 = gate_rf1 AND poly_rf 
VARDMYA1 = VARDMYX NOT VARG3 
VARDMYA2 = VARDMYA1 NOT VARG6 
VARDMY = VARDMYA2 NOT JVARD 
gate_rf3 = gate_rf2 NOT VARDMY 
gate_rf = gate_rf3 NOT JVARD 
gate_rf_mdiff = mdiff INTERACT gate_rf 
gate_norf = gate NOT gate_rf_mdiff 
tngate1 = gate_norf AND NIMP 
anwel = NWELL OR BASE_N 
RWDMY = RWDMYX NOT RWDMY1 
nxwell_a = anwel NOT RWDMY  //  define N_well region
nxwell = nxwell_a NOT RWDMY1 
tngate2 = tngate1 NOT nxwell 
tngate3 = tngate2 NOT LDDMY 
tngate4 = tngate3 NOT CIRPO 
tngate5 = tngate4 NOT lcesd1 
tngate = tngate5 NOT lcesd2 
ngate1 = tngate NOT OD2 
ngate3 = ngate1 NOT NTN 
ngate4 = ngate3 NOT DNW 
ngate5 = ngate4 NOT VTMN 
ngate6 = ngate5 NOT RFDUMMY 
#IFDEF MACRO 
MAC = COPY OD
#ELSE
MAC = OD NOT (SIZE OD BY 0.005)
#ENDIF
ngate = ngate6 NOT MAC  //  1.8V Nominal VT NMOS

//***** Define connectivity/via layer -- tndiff ****
nthin1 = mdiff AND NIMP 
ydio_a = ESD3DMY AND OD 
ydio_c = SIZE ydio_a BY -0.2 
ydio_d = ydio_c AND NIMP 
ydio_e = ydio_d AND RPO 
ydio_f = ydio_e NOT NWELL 
ydio_g = ESD3DMY AND POLY1 
ydio_h = SIZE ydio_g BY 0.2 
ydio_i = ydio_f NOT ydio_h 
ydio_j = SIZE ydio_i BY -0.8 
ydio = SIZE ydio_j BY 0.6 
nthin = nthin1 NOT ydio  //  define N+ thin oxide
tndiff = nthin NOT gate  //  define N+ diffusion region

//***** Define connectivity/via layer -- psub ****
ppsub = BULK NOT anwel 
psub2s = SIZE PSUB2 BY 0.01 
psubband = psub2s NOT PSUB2  //  psub separator band (doughnut).
psub_w5w6 = ppsub NOT psubband 
rfdmy56 = RFDUMMY5T OR RFDUMMY6T 
psub_norwel = psub_w5w6 NOT rfdmy56 
rw = ppsub INSIDE DNW 
psub = psub_norwel OR rw 

//* Define device -- nmos N1
nrgate1 = ngate3 AND DNW 
nrgate2 = nrgate1 NOT VTMN 
nrgate3 = nrgate2 NOT RFDUMMY 
nrgate = nrgate3 NOT MAC  //  1.8V nominal VT NMOS on DNW

//* Define device -- nmos ND
bngate1 = tngate AND OD2 
bngate2 = bngate1 NOT NTN 
bngate3 = bngate2 NOT DNW 
bngate4 = bngate3 NOT CAP_IMP 
bngate5 = bngate4 NOT VTMN 
bngate6 = bngate5 NOT RFDUMMY 
bngate = bngate6 NOT MAC  //  3.3/5V Nominal VT NMOS

//* Define device -- nmos N2
bnrgate1 = bngate2 AND DNW 
bnrgate2 = bnrgate1 NOT RFDUMMY 
bnrgate = bnrgate2 NOT MAC  //  3.3/5V nominal VT NMOS on DNW

//* Define device -- nmos NL
nlgate1 = ngate1 AND NTN 
nlgate2 = nlgate1 NOT RFDUMMY 
nlgate = nlgate2 NOT MAC  //  1.8V native NMOS

//* Define device -- nmos NN
bnlgate1 = bngate1 AND NTN 
bnlgate2 = bnlgate1 NOT RFDUMMY 
bnlgate = bnlgate2 NOT MAC  //  3.3/5V native NMOS

//* Define device -- pmos P
tpgate1 = gate_norf AND PIMP 
tpgate2 = tpgate1 NOT LDDMY 
tpgate = tpgate2 AND nxwell 
pgate1 = tpgate NOT OD2 
pgate2 = pgate1 NOT VTMP 
pgate3 = pgate2 NOT RFDUMMY 
pgate = pgate3 NOT MAC  //  1.8V Norminal VT PMOS

//***** Define connectivity/via layer -- tpdiff ****
pthin = mdiff AND PIMP  //  define P+ thin oxide
tpdiff = pthin NOT gate  //  define P+ diffusion region

//* Define device -- pmos PD
bpgate1 = tpgate AND OD2 
bpgate2 = bpgate1 NOT VTMP 
bpgate4 = bpgate2 NOT RFDUMMY 
bpgate = bpgate4 NOT MAC  //  3.3V Nominal VT PMOS

//* Define device -- nmos NA
mvt_ngate1 = ngate4 AND VTMN 
mvt_ngate2 = mvt_ngate1 NOT RFDUMMY 
mvt_ngate = mvt_ngate2 NOT MAC  //  1.8V medium VT NMOS

//* Define device -- nmos NB
bmvt_ngate1 = bngate4 AND VTMN 
bmvt_ngate2 = bmvt_ngate1 NOT RFDUMMY 
bmvt_ngate = bmvt_ngate2 NOT MAC  //  3.3/5V medium VT NMOS

//* Define device -- pmos PA
mvt_pgate1 = pgate1 AND VTMP 
mvt_pgate2 = mvt_pgate1 NOT RFDUMMY 
mvt_pgate = mvt_pgate2 NOT MAC  //  1.8V medium VT PMOS

//* Define device -- nmos nch_mac
ngate_mac = ngate6 AND MAC  //  1.8V Nominal VT NMOS macro model

//* Define device -- nmos nch_dnw_mac
nrgate_mac = nrgate3 AND MAC  //  1.8V nominal VT NMOS on DNW macro model

//* Define device -- nmos mench_mac
mvt_ngate_mac = mvt_ngate2 AND MAC  //  1.8V medium VT NMOS macro model

//* Define device -- nmos nanch_mac
nlgate_mac = nlgate2 AND MAC  //  1.8V native NMOS macro model

//* Define device -- nmos nch3_mac
bngate_mac = bngate6 AND MAC  //  3.3/5V Nominal VT NMOS macro model

//* Define device -- nmos mench3_mac
bmvt_ngate_mac = bmvt_ngate2 AND MAC  //  3.3/5V medium VT NMOS macro model

//* Define device -- nmos nanch3_mac
bnlgate_mac = bnlgate2 AND MAC  //  3.3/5V native NMOS macro model

//* Define device -- nmos nch3_dnw_mac
bnrgate_mac = bnrgate2 AND MAC  //  3.3/5V nominal VT NMOS on DNW macro model

//* Define device -- pmos pch_mac
pgate_mac = pgate3 AND MAC  //  1.8V Norminal VT PMOS macro model

//* Define device -- pmos mepch_mac
mvt_pgate_mac = mvt_pgate2 AND MAC  //  1.8V medium VT PMOS macro model

//* Define device -- pmos pch3_mac
bpgate_mac = bpgate4 AND MAC  //  3.3V Nominal VT PMOS macro model

//* Define device -- diode DP
pdio_a = tpdiff AND DIODMY 
pdio_b = pdio_a AND nxwell 
pdio_c = pdio_b NOT VTMP 
pdio = pdio_c NOT OD2  //  1.8V P+/NW diode

//* Define device -- diode D1
pdio_3 = pdio_c AND OD2  //  3.3V P+/NW diode

//* Define device -- diode DN
ndio_a = tndiff AND DIODMY 
ndio_b = ndio_a AND psub 
ndio_c = ndio_b NOT VTMN 
ndio = ndio_c NOT OD2  //  1.2V N+/PW diode

//* Define device -- diode D2
ndio_3 = ndio_c AND OD2  //  2.5V N+/PW diode

//* Define device -- diode DW
DIONW = DIODMY OUTSIDE tpdiff 
nwdio_a = nxwell AND DIONW 
nwdio = nwdio_a NOT OD2  //  1.8V NW/PW diode

//* Define device -- diode D3
nwdio_3 = nwdio_a AND OD2  //  3.3V NW/PW diode

//***** Define connectivity/via layer -- ydio_hole ****
ydio_hole = HOLES ydio 

//* Define device -- diode pdio_m
pdio_m1 = pdio_b AND VTMP 
pdio_m = pdio_m1 NOT OD2  //  1.8V Medium-Vt P+/NW diode

//* Define device -- diode ndio_m
ndio_m1 = ndio_b AND VTMN 
ndio_m = ndio_m1 NOT OD2  //  1.8V Medium-Vt N+/PW diode

//* Define device -- diode ndio_3m
ndio_3m = ndio_m1 AND OD2  //  3.3V Medium-Vt N+/PW diode

//* Define device -- r M1
M1X = M1 OR DUM1 
M1Y = M1X NOT M1SLOT 
RMDMY1 = RMDMY1i OR RMDMY 
M1Z = M1Y AND RMDMY1 
mt1res = M1Z INTERACT M1  //  metal1 resistor

//***** Define connectivity/via layer -- metal1 ****
metal1 = M1Y NOT mt1res  //  metal1 interconnect

//* Define device -- r M2
M2X = M2 OR DUM2 
M2Y = M2X NOT M2SLOT 
RMDMY2 = RMDMY2i OR RMDMY 
M2Z = M2Y AND RMDMY2 
mt2res = M2Z INTERACT M2  //  metal2 resistor

//***** Define connectivity/via layer -- metal2 ****
metal2 = M2Y NOT mt2res  //  metal2 interconnect

//* Define device -- r M3
M3X = M3 OR DUM3 
M3Y = M3X NOT M3SLOT 
RMDMY3 = RMDMY3i OR RMDMY 
M3Z = M3Y AND RMDMY3 
mt3res = M3Z INTERACT M3  //  metal3 resistor

//***** Define connectivity/via layer -- metal3 ****
metal3 = M3Y NOT mt3res  //  metal3 interconnect

//* Define device -- r M4
M4X = M4 OR DUM4 
M4Y = M4X NOT M4SLOT 
RMDMY4 = RMDMY4i OR RMDMY 
M4Z = M4Y AND RMDMY4 
mt4res = M4Z INTERACT M4  //  metal4 resistor

//***** Define connectivity/via layer -- metal4 ****
metal4 = M4Y NOT mt4res  //  metal4 interconnect

//* Define device -- r M5
M5X = M5 OR DUM5 
M5Y = M5X NOT M5SLOT 
RMDMY5 = RMDMY5i OR RMDMY 
M5Z = M5Y AND RMDMY5 
mt5res = M5Z INTERACT M5  //  metal5 resistor

//***** Define connectivity/via layer -- metal5 ****
mt5x = M5Y NOT mt5res 
ind_dmy1 = RFDUMMY1 AND INDDMY 
ind_dmy2 = ind_dmy1 AND NTN 
ind_dmy = SIZE ind_dmy2 BY -0.005 
metal5 = mt5x NOT ind_dmy 

//* Define device -- xdev MT1
M6X = M6 OR DUM6 
M6Y = M6X NOT M6SLOT 
RMDMY6 = RMDMY6i OR RMDMY 
M6Z = M6Y AND RMDMY6 
mt6res = M6Z INTERACT M6  //  metal6 resistor

//***** Define connectivity/via layer -- metal6 ****
mt6x = M6Y NOT mt6res 
metal6 = mt6x NOT ind_dmy 

//* Define device -- r LR
lrpop = lrpop2 NOT RPDMY1 

//* Define device -- xdev WR
trwell1 = RWDMY AND NWELL 
trwell = trwell1 NOT RWDMY1  //  N-well resistor layer
nwsti = trwell NOT dfhr1  //  RWDMY*NWELL -RPO -diff --> nwsti 

//* Define device -- xdev WO
nwod = trwell AND dfhr1  //   RWDMY*NWELL*RPO*diff --> nwod

//* Define device -- r PD
rdop = rdop1 NOT RFDUMMY 
prdop1 = rdop AND PIMP 
prdop2 = prdop1 AND nxwell 
prdop3 = prdop2 NOT RPDMY1 
#IFDEF OD_RES_WO_DMNP2V
prdop   = prdop3 INTERACT OD
#ELSE
prdop_1 = prdop3 INTERACT OD
prdop   = prdop_1 INTERACT DMP2V
#ENDIF

//* Define device -- r ND
nrdop1 = rdop AND NIMP 
nrdop2 = nrdop1 NOT nxwell 
nrdop3 = nrdop2 NOT RPDMY1 
#IFDEF OD_RES_WO_DMNP2V
nrdop   = nrdop3 INTERACT OD
#ELSE
nrdop_1 = nrdop3 INTERACT OD
nrdop   = nrdop_1 INTERACT DMN2V
#ENDIF

//* Define device -- r PR
prpop1 = rpop INTERACT DMP2V 
prpop2 = prpop1 AND PIMP 
prpop3 = prpop2 NOT RFDUMMY 
prpop4 = prpop3 NOT RFDUMMY1 
prpop5 = prpop4 INTERACT POLY1 
prpop = prpop5 NOT RPDMY1  //  (PR) P+POLY w/o silicide

//* Define device -- r NR
nrpop1 = rpop INTERACT DMN2V 
nrpop2 = nrpop1 AND NIMP 
nrpop3 = nrpop2 NOT RFDUMMY 
nrpop4 = nrpop3 INTERACT POLY1 
nrpop = nrpop4 NOT RPDMY1  //  (NR) N+POLY w/o silicide

//* Define device -- r PI1
prdip1 = rdip AND PIMP 
prdip2 = prdip1 AND nxwell 
prdip3 = prdip2 NOT RPDMY1 
prdip = prdip3 INTERACT OD  //  P+OD resistor w/i silicide
rpod_edge = prdip INSIDE EDGE diff 
l_rpod = LENGTH rpod_edge  >= 2  < 99999999 
rpodl_r = prdip WITH EDGE l_rpod  //  P+OD resistor w/i silicide >= 2

//* Define device -- r PI2
rpods_r = prdip NOT rpodl_r  //  P+OD resistor w/i silicide < 2

//* Define device -- r NI1
nrdip1 = rdip AND NIMP 
nrdip2 = nrdip1 NOT nxwell 
nrdip3 = nrdip2 NOT RPDMY1 
nrdip = nrdip3 INTERACT OD  //  N+OD resistor w/i silicide
rnod_edge = nrdip INSIDE EDGE diff 
l_rnod = LENGTH rnod_edge  >= 2  < 99999999 
rnodl_r = nrdip WITH EDGE l_rnod  //  N+OD resistor w/i silicide >= 2

//* Define device -- r NI2
rnods_r = nrdip NOT rnodl_r  //  N+OD resistor w/i silicide < 2

//* Define device -- r PS1
prpip1 = rpip AND PIMP 
prpip2 = prpip1 NOT RFDUMMY 
prpip3 = prpip2 NOT RFDUMMY1 
prpip4 = prpip3 AND RPDMYa 
prpip5 = prpip4 INTERACT POLY1 
rppoly_edge = prpip5 INSIDE EDGE rpoly 
l_rppoly = LENGTH rppoly_edge  >= 2  < 99999999 
rppolyl_r_1 = prpip5 WITH EDGE l_rppoly 
rppolyl_r_2 = rppolyl_r_1 NOT RPDMY1 
rppolyl_r = rppolyl_r_2 AND RPDMYX  //  P+POLY resistor w/i silicide >= 2

//* Define device -- r PS2
rppolys_r_1 = prpip5 NOT rppolyl_r_1 
rppolys_r_2 = rppolys_r_1 NOT RPDMY1 
rppolys_r = rppolys_r_2 AND RPDMYX  //  P+POLY resistor w/i silicide < 2

//* Define device -- r NS1
nrpip1 = rpip AND NIMP 
nrpip2 = nrpip1 NOT RFDUMMY 
nrpip3 = nrpip2 NOT RFDUMMY1 
nrpip4 = nrpip3 AND RPDMYa  //  for rnpo1_dis and rnpo1w_dis (3T)
nrpip5 = nrpip4 INTERACT POLY1 
rnpoly_edge = nrpip5 INSIDE EDGE rpoly 
l_rnpoly = LENGTH rnpoly_edge  >= 2  < 99999999 
rnpolyl_r_1 = nrpip5 WITH EDGE l_rnpoly 
rnpolyl_r = rnpolyl_r_1 NOT RPDMY1  //  N+POLY resistor w/i silicide >= 2

//* Define device -- r NS2
rnpolys_r_1 = nrpip5 NOT rnpolyl_r_1 
rnpolys_r = rnpolys_r_1 NOT RPDMY1  //  N+POLY resistor w/i silicide < 2

//* Define device -- xdev rpodrpo_m
#IFDEF OD_RES_WO_DMNP2V
t_prdop   = t_rdop AND PIMP
#ELSE
t_prdop_1 = t_rdop AND PIMP
t_prdop   = t_prdop_1 INTERACT DMP2V
#ENDIF

//* Define device -- xdev rnodrpo_m
#IFDEF OD_RES_WO_DMNP2V
t_nrdop   = t_rdop AND NIMP
#ELSE
t_nrdop_1 = t_rdop AND NIMP
t_nrdop   = t_nrdop_1 INTERACT DMN2V
#ENDIF

//* Define device -- xdev rpod_m
t_rdip_edge = t_rdip INSIDE EDGE diff 
l_trdip = LENGTH t_rdip_edge  >= 2  < 99999999 
l_trdip_r = t_rdip WITH EDGE l_trdip 
l_rpodl_3t = l_trdip_r AND PIMP  // P+OD resistor w/i silicide w>= 2

//* Define device -- xdev rpodw_m
s_trdip_r = t_rdip NOT l_trdip_r 
s_rpods_3t = s_trdip_r AND PIMP  // P+OD resistor w/i silicide w<2

//* Define device -- xdev rnod_m
l_rnodl_3t = l_trdip_r AND NIMP  // N+OD resistor w/i silicide w>= 2

//* Define device -- xdev rnodw_m
s_rnods_3t = s_trdip_r AND NIMP  // N+OD resistor w/i silicide w<2

//* Define device -- xdev rnwod_m
trwella = RWDMY1 AND NWELL  //  N-well resistor layer
nwoda = trwella AND dfhr1  //  RWDMY*NWELLRPOdiff --> nwod

//* Define device -- xdev rnwsti_m
nwstia = trwella NOT dfhr1 

//* Define device -- xdev rnpo1rpo_dis
nrpop_3t = nrpop4 AND RPDMY1  //  3T (NR) N+POLY w/o silicide

//***** Define connectivity/via layer -- poly_term ****
poly_term1 = rpoly AND RPDMY1 
poly_term2 = SIZE poly_term1 BY 0.005 
poly_term = poly_term2 NOT poly_term1 

//* Define device -- xdev rppo1rpo_dis
prpop_3t = prpop5 AND RPDMY1  //  3T (PR) P+POLY w/o silicid 

//* Define device -- xdev rnpo1w_dis
rnpolys_r_3t = rnpolys_r_1 AND RPDMY1  //  3T N+POLY resistor w/i silicide < 2

//* Define device -- xdev rppo1w_dis
rppolys_r_3t = rppolys_r_1 AND RPDMY1  //  3T P+POLY resistor w/i silicide < 2 karena

//* Define device -- xdev rnpo1_dis
rnpolyl_r_3t = rnpolyl_r_1 AND RPDMY1  //  3T N+POLY resistor w/i silicide >= 2

//* Define device -- xdev rppo1_dis
rppolyl_r_3t = rppolyl_r_1 AND RPDMY1  //  3T P+POLY resistor w/i silicide >= 2

//* Define device -- xdev rppolyhri_dis
lrpop_3t = lrpop2 AND RPDMY1  //  3T HRI high poly resistor

//* Define device -- xdev PV2
ttdiff = tpdiff AND BJTDMY 
nbase_a = nxwell NOT INTERACT DNW 
nbase_gen = nbase_a AND BJTDMY 
emit_gen = ttdiff AND nbase_gen 
emit = emit_gen NOT OD2  //  define 1.8V BJT[PV] emitter
emit2_temp = AREA emit  > 3.999  < 4.001 
emit2 = emit2_temp NOT LVSDMY  // define Q[PV]	   pnp2      CORE PNP-BJT

//***** Define connectivity/via layer -- coll ****
nbase = nbase_gen NOT OD2  //  define 1.8V BJT[PV] base terminal
collsur = psub TOUCH nbase 
coll1a = collsur OR nbase  //   define BJT[PV] collector
collsura = collsur TOUCH emit 
coll1b = coll1a NOT collsura 
coll = coll1b NOT emit  //   define pnp collector

//* Define device -- xdev PV5
emit5_temp = AREA emit  > 24.999  < 25.001 
emit5 = emit5_temp NOT LVSDMY  // define Q[PV]	   pnp5	     CORE PNP-BJT

//* Define device -- xdev PV10
emit10_temp = AREA emit  > 99.999  < 100.001 
emit10 = emit10_temp NOT LVSDMY  // define Q[PV]     pnp10     CORE PNP-BJT

//* Define device -- xdev NV2
npnrg = DNW AND BJTDMY  //  define NPN region
nndiff = tndiff AND npnrg 
pbase = psub AND npnrg  // define 1.8V BJT[NV] base terminal
nemit = nndiff AND pbase  // define 1.8V BJT[NV] emitter
nemit2_temp = AREA nemit  > 3.999  < 4.001 
nemit2 = nemit2_temp NOT LVSDMY  // define Q[NV]     npn2	 CORE NPN-BJT

//***** Define connectivity/via layer -- ncoll ****
ncollrg = nxwell AND npnrg 
ncoll1 = ncollrg TOUCH pbase 
ncoll = ncoll1 OR pbase  // define 1.8V BJT[NV] collector

//* Define device -- xdev NV5
nemit5_temp = AREA nemit  > 24.999  < 25.001 
nemit5 = nemit5_temp NOT LVSDMY  // define Q[NV]     npn5      CORE NPN-BJT

//* Define device -- xdev NV10
nemit10_temp = AREA nemit  > 99.999  < 100.001 
nemit10 = nemit10_temp NOT LVSDMY  // define Q[NV]     npn10     CORE NPN-BJT

//* Define device -- xdev P12
emit_od2 = emit_gen INTERACT OD2  //  define 3.3V BJT[P1] emitter
iemit2 = AREA emit_od2  > 3.999  < 4.001  // define Q[P1]     pnp2_3  IO   PNP-BJT

//***** Define connectivity/via layer -- coll_od2 ****
nbase_od2 = nbase_gen INTERACT OD2  //  define 3.3V BJT[P1] base terminal
collsur_3 = psub TOUCH nbase_od2 
coll2a = collsur_3 OR nbase_od2  //   define BJT[PV] collector
collsurb = collsur_3 TOUCH emit_od2 
coll2b = coll2a NOT collsurb 
coll_od2 = coll2b NOT emit_od2  //   define pnp collector

//* Define device -- xdev P15
iemit5 = AREA emit_od2  > 24.999  < 25.001  // define Q[P1]     pnp5_3  IO   PNP-BJT

//* Define device -- xdev P110
iemit10 = AREA emit_od2  > 99.999  < 100.001  // define Q[P1]     pnp10_3 IO   PNP-BJT

//* Define device -- xdev NV2_mis
nemit2_mis = nemit2_temp AND LVSDMY  // define Q[NV_mis] npn2_mis  CORE NPN-BJT

//* Define device -- xdev NV5_mis
nemit5_mis = nemit5_temp AND LVSDMY  // define Q[NV_mis] npn5_mis  CORE NPN-BJT

//* Define device -- xdev NV10_mis
nemit10_mis = nemit10_temp AND LVSDMY  // define Q[NV_mis] npn10_mis CORE NPN-BJT

//* Define device -- xdev PV2_mis
emit2_mis = emit2_temp AND LVSDMY  // define Q[PV_mis] pnp2_mis  CORE PNP-BJT mismatch model

//* Define device -- xdev PV5_mis
emit5_mis = emit5_temp AND LVSDMY  // define Q[PV_mis] pnp5_mis  CORE PNP-BJT mismatch model

//* Define device -- xdev PV10_mis
emit10_mis = emit10_temp AND LVSDMY  // define Q[PV_mis] pnp10_mis CORE PNP-BJT mismatch model

//* Define device -- xdev mimcap_1p0_sin
mim_block = CTM5 AND M5 
capm5a = mim_block INTERACT VIA5i 
capm5b = capm5a NOT RFDUMMY 
RFDUMMYall = RFDUMMY1 OR RFDUMMYUD 
capm5c = capm5b NOT RFDUMMYall 
capm5d = capm5c AND CTMDMY 
capm5 = capm5d NOT CTMDMYUD 
capm5_2t = capm5 NOT CTMDMY_3t 
CTMDMYall = CTMDMY OR CTMDMYUD 
capdmy1p0a = CTMDMYall NOT CTMDMY1p5 
capdmy1p0 = capdmy1p0a NOT CTMDMY2p0 
capm5_1p0 = capm5_2t INTERACT capdmy1p0 
capm5ud1 = capm5b NOT RFDUMMYUD 
capm5ud2 = capm5ud1 NOT CTMDMY 
capm5_ud = capm5ud2 AND CTMDMYUD 
capm5_ud_2t = capm5_ud NOT CTMDMY_3t 
capm5_1p0_ud = capm5_ud_2t INTERACT capdmy1p0 

//***** Define connectivity/via layer -- ctm ****
ctm = COPY CTM5 

//* Define device -- xdev mimcap_2p0_sin
capdmy2p0a = capdmy1p0a NOT CTMDMY1p0 
capdmy2p0 = capdmy2p0a AND CTMDMY2p0  // ctmdmy2p0
capm5_2p0 = capm5_2t INTERACT capdmy2p0 
capm5_2p0_ud = capm5_ud_2t INTERACT capdmy2p0 

//* Define device -- xdev mimcap_1p0_sin_3t
capm5_3t = capm5 AND CTMDMY_3t 
capm5_1p0_3t = capm5_3t INTERACT capdmy1p0 

//* Define device -- xdev mimcap_2p0_sin_3t
capm5_2p0_3t = capm5_3t INTERACT capdmy2p0 

//* Define device -- xdev pmos_rf33
pgate_rf1 = gate_rf AND PIMP 
pgate_rf2 = pgate_rf1 NOT VTMP 
pgate_rf3 = pgate_rf2 INTERACT nxwell 
bpgate_rf = pgate_rf3 AND OD2 
bpgate_rf4t1 = bpgate_rf AND RFDUMMY1 
bpgate_rf4t = bpgate_rf4t1 AND DNW  //  3.3V RF PMOS 4 terminals with DNW
bpgate_4t_pthin_1 = pthin INTERACT bpgate_rf4t 
bpgate_4t_pthin_2 = bpgate_4t_pthin_1 NOT INTERACT asym_rf 
bpgate_4t_pthin = bpgate_4t_pthin_2 NOT RFDUMMY5T  //  pmos_rf33

//***** Define connectivity/via layer -- d_tpdiff ****
d_tpdiff = tpdiff AND DRAIN 

//***** Define connectivity/via layer -- s_tpdiff ****
s_tpdiff1 = tpdiff NOT d_tpdiff 
s_tpdiff = s_tpdiff1 INTERACT gate_rf 

//* Define device -- xdev pmos_rf33_nw
bpgate_rf4t_nw = bpgate_rf4t1 NOT DNW  //  3.3V RF PMOS 4 terminals without DNW
bpgate_4t_pthin_nw_1 = pthin INTERACT bpgate_rf4t_nw 
bpgate_4t_pthin_nw_2 = bpgate_4t_pthin_nw_1 NOT INTERACT asym_rf 
bpgate_4t_pthin_nw = bpgate_4t_pthin_nw_2 NOT RFDUMMY5T  //  pmos_rf33_nw

//* Define device -- xdev pmos_rf
pgate_rf = pgate_rf3 NOT OD2 
pgate_rf4t1 = pgate_rf AND RFDUMMY1 
pgate_rf4t = pgate_rf4t1 AND DNW  //  1.8V RF PMOS 4 terminals with DNW
pgate_4t_pthin_1 = pthin INTERACT pgate_rf4t 
pgate_4t_pthin_2 = pgate_4t_pthin_1 NOT INTERACT asym_rf 
pgate_4t_pthin = pgate_4t_pthin_2 NOT RFDUMMY5T  //  pmos_rf

//* Define device -- xdev pmos_rf_nw
pgate_rf4t_nw = pgate_rf4t1 NOT DNW  //  1.8V RF PMOS 4 terminals without DNW
pgate_4t_pthin_nw_1 = pthin INTERACT pgate_rf4t_nw 
pgate_4t_pthin_nw_2 = pgate_4t_pthin_nw_1 NOT INTERACT asym_rf 
pgate_4t_pthin_nw = pgate_4t_pthin_nw_2 NOT RFDUMMY5T  //  pmos_rf_nw

//* Define device -- xdev nmos_rf33
nrgate_rf1 = gate_rf AND NIMP 
nrgate_rf2 = nrgate_rf1 NOT NTN 
nrgate_rf3 = nrgate_rf2 NOT VTMN 
nrgate_rf4 = nrgate_rf3 AND DNW 
bnrgate_rf = nrgate_rf4 AND OD2 
bnrgate_rf4t = bnrgate_rf AND RFDUMMY1  //  3.3V RF NMOS 4 terminals
bnrgate_4t_nthin_1 = nthin INTERACT bnrgate_rf4t 
bnrgate_4t_nthin_2 = bnrgate_4t_nthin_1 NOT INTERACT asym_rf 
bnrgate_4t_nthin = bnrgate_4t_nthin_2 NOT RFDUMMY6T  //  nmos_rf33

//***** Define connectivity/via layer -- d_tndiff ****
d_tndiff = tndiff AND DRAIN 

//***** Define connectivity/via layer -- s_tndiff ****
s_tndiff1 = tndiff NOT d_tndiff 
s_tndiff = s_tndiff1 INTERACT gate_rf 

//* Define device -- xdev nmos_rf
nrgate_rf = nrgate_rf4 NOT OD2 
nrgate_rf4t = nrgate_rf AND RFDUMMY1  //  1.8V RF NMOS 4 terminals
nrgate_4t_nthin_1 = nthin INTERACT nrgate_rf4t 
nrgate_4t_nthin_2 = nrgate_4t_nthin_1 NOT INTERACT asym_rf 
nrgate_4t_nthin = nrgate_4t_nthin_2 NOT RFDUMMY6T  //  nmos_rf

//* Define device -- xdev pmos_rf_5t
pgate_5t_pthin = pgate_4t_pthin_2 AND RFDUMMY5T  //  pmos_rf_5t

//* Define device -- xdev pmos_rf_nw_5t
pgate_5t_pthin_nw = pgate_4t_pthin_nw_2 AND RFDUMMY5T  //  pmos_rf_nw_5t

//* Define device -- xdev pmos_rf33_5t
bpgate_5t_pthin = bpgate_4t_pthin_2 AND RFDUMMY5T  //  pmos_rf33_5t

//* Define device -- xdev pmos_rf33_nw_5t
bpgate_5t_pthin_nw = bpgate_4t_pthin_nw_2 AND RFDUMMY5T  //  pmos_rf33_nw_5t

//* Define device -- xdev nmos_rf_6t
nrgate_6t_nthin = nrgate_4t_nthin_2 AND RFDUMMY6T  //  nmos_rf_6t

//* Define device -- xdev nmos_rf33_6t
bnrgate_6t_nthin = bnrgate_4t_nthin_2 AND RFDUMMY6T  //  nmos_rf33_6t

//* Define device -- xdev moscap_rf
varnwm_rf1 = nxwell AND VARDMY 
varnwm_rf2 = varnwm_rf1 AND RFDUMMY1 
varnwmc_rf_1 = varnwm_rf2 NOT OD2  //  modified by KMLiu
all_bc = PV_P OR PV_N  //  Original definition is (BC1 OR BC2).
varnwmc_rf_2 = varnwmc_rf_1 NOT INTERACT all_bc 
varnwmc_rf_3 = varnwmc_rf_2 NOT INTERACT VTDN 
varnwmc_rf_dnw_1 = varnwmc_rf_3 AND DNW 
varnwmc_rf_dnw = varnwmc_rf_dnw_1 NOT SBDUMMY  // moscap_rf

//* Define device -- xdev moscap_rf_nw
vargt1 = tngate1 AND nxwell 
vargt2 = vargt1 AND VARDMY 
vargt3 = vargt2 NOT RFDUMMY 
vargt3_rf1 = vargt3 AND RFDUMMY1 
vargt3_rf = vargt3_rf1 NOT OD2  //  core mos varactor 3 terminals

//* Define device -- xdev moscap_rf33
varnwm_rf3 = varnwm_rf2 AND OD2 
varnwmi_rf_dnw_1 = varnwm_rf3 AND DNW 
varnwmi_rf_dnw = varnwmi_rf_dnw_1 NOT SBDUMMY  // moscap_rf33

//* Define device -- xdev moscap_rf33_nw
bvargt3_rf = vargt3_rf1 AND OD2  //  io mos varactor 3 terminals
varnwmc_rf_nw_1 = varnwmc_rf_3 NOT DNW 
varnwmc_rf_nw = varnwmc_rf_nw_1 NOT SBDUMMY  // moscap_rf_nw
varnwmi_rf_nw_1 = varnwm_rf3 NOT DNW 
varnwmi_rf_nw = varnwmi_rf_nw_1 NOT SBDUMMY  // moscap_rf33_nw

//* Define device -- xdev xjvar_nr36
varnwj_rf = nxwell AND JVARD 
jvar1_rf = varnwj_rf INTERACT tpdiff 
jvar2_rf = jvar1_rf INTERACT tndiff 
jvar3_rf = jvar2_rf NOT RFDUMMY 
jvar_rf3t = jvar3_rf AND RFDUMMY1  //  Junction varactor 3 terminals
jvarp_rf = jvar2_rf AND tpdiff 
jvarn_rf = jvar2_rf AND tndiff 

//* Define device -- xdev mimcap_2p0_wos
capm5_rf3ta1 = capm5b AND CTMDMY 
capm5_rf3ta2 = capm5_rf3ta1 NOT CTMDMYUD 
capm5_rf3ta3 = capm5_rf3ta2 AND RFDUMMY1 
capm5_rf3ta = capm5_rf3ta3 NOT RFDUMMYUD 
capm5_rf3t_shield_m4 = capm5_rf3ta INSIDE M4  //  modified by KMLiu
capm5_rf3t_woa = capm5_rf3ta NOT capm5_rf3t_shield_m4 
capm5_rf3t_shield_m3 = capm5_rf3ta INSIDE M3  //  Added by KMLiu
capm5_rf3t_wob = capm5_rf3t_woa NOT capm5_rf3t_shield_m3 
capm5_rf3t_shield_poly = capm5_rf3ta INSIDE POLY1  //  Added by KMLiu
capm5_rf3t_woc = capm5_rf3t_wob NOT capm5_rf3t_shield_poly 
capm5_rf3t_shield_ntn = capm5_rf3ta INSIDE NTN  //  Added by KMLiu
capm5_rf3t = capm5_rf3t_woc NOT capm5_rf3t_shield_ntn  //  new mimcap no shield
capm5_rf3t_2p0 = capm5_rf3t INTERACT capdmy2p0 

//* Define device -- xdev mimcap_2p0_shield
capm5_rf3t_shield_m4_2p0 = capm5_rf3t_shield_m4 INTERACT capdmy2p0 
capm5_rf3ta_ud = capm5_rf3ta2 AND RFDUMMYUD 
capm5_rf3t_shield_m4_ud = capm5_rf3ta_ud INSIDE M4  //  modified by KMLiu
capm5_rf3t_shield_m4_2p0_ud = capm5_rf3t_shield_m4_ud INTERACT capdmy2p0 

//***** Define connectivity/via layer -- mim_po ****
mim_po = POLY1 INTERACT capm5_rf3t_shield_poly 

//* Define device -- xdev rppolywo_rf
prpop_rf3t = prpop3 AND RFDUMMY1  //  rppolywo_rf 3 terminals

//* Define device -- xdev rppolyl_rf
prpip_rf1 = prpip1 AND RPDMYX 
prpip_rf2 = prpip_rf1 NOT RPDMY1 
prpip_rf3t = prpip_rf2 AND RFDUMMY1  //  rppoly_rf 3 terminals
rppoly_rf_edge = prpip_rf3t INSIDE EDGE rpoly 
l_rppoly_rf = LENGTH rppoly_rf_edge  >= 2  < 99999999 
rppolyl_rf_3t = prpip_rf3t WITH EDGE l_rppoly_rf  //  rppoly_rf 3 terminal >2

//* Define device -- xdev rppolys_rf
rppolys_rf_3t = prpip_rf3t NOT rppolyl_rf_3t  //  rppoly_rf 3 terminal <2

//* Define device -- xdev spiral_std_mu_x_20k
std_mu_x_20k_ind = INDDMY WITH TEXT "spiral_std_mu_x_20k" IND_TEXT 

//***** Define connectivity/via layer -- indm6p ****
indm6a = SIZE INDDMY BY 0.005 
indm6 = indm6a AND metal6 
indm6p1 = indm6 NOT IND_MP 
indm6p2 = indm6p1 NOT INTERACT IND_MP 
indm6p = indm6p2 NOT IND_D4 

//***** Define connectivity/via layer -- indm6m ****
indm6m = indm6 AND IND_MP 

//* Define device -- xdev spiral_sym_mu_x_20k
sym_mu_x_20k_ind = INDDMY WITH TEXT "spiral_sym_mu_x_20k" IND_TEXT 

//* Define device -- xdev spiral_sym_ct_mu_x_20k
sym_ct_mu_x_20k_ind = INDDMY WITH TEXT "spiral_sym_ct_mu_x_20k" IND_TEXT 

//***** Define connectivity/via layer -- indm4c ****
indm4 = indm6a AND M4Y 
indm4c = indm4 AND IND_D4 

//* Define device -- xdev lcesd1_rf
lcesd_p_rf1 = lcesd_p AND RFDUMMY1 
lcesd_p_rf = lcesd_p_rf1 INTERACT ESD2DUMMY 
lcesd1_rl_1 = lcesd_p_rf AND lcesd1 
lcesd1_rl_2 = lcesd1_rl_1 INTERACT tpdiff 
lcesd1_rl = lcesd1_rl_2 NOT lcesd2  // lcesd1_rf 50fF

//***** Define connectivity/via layer -- lcesdp ****
lcesdp = tpdiff AND lcesd_p 

//***** Define connectivity/via layer -- lcesdm ****
lcesdm = tndiff AND lcesd_m 

//* Define device -- xdev lcesd2_rf
lcesd2_rl_1 = lcesd_p_rf AND lcesd2 
lcesd2_rl_2 = lcesd2_rl_1 INTERACT tpdiff 
lcesd2_rl = lcesd2_rl_2 NOT lcesd1  // lcesd2_rf 100fF

//* Define device -- xdev nmoscap
nthin_var1 = nthin AND nxwell 
nthin_var2 = nthin_var1 AND VARDMY 
nthin_var3 = nthin_var2 NOT RFDUMMY 
nthin_var4 = nthin_var3 NOT RFDUMMY1 
nthin_var5 = nthin_var4 INTERACT tngate1 
nthin_var_1 = nthin_var5 NOT OD2  // Myron
nthin_var = nthin_var_1 NOT VTDN  // Myron
vargt4 = vargt3 NOT RFDUMMY1 
vargt = vargt4 NOT OD2  // 1.8V baseband varactor

//* Define device -- xdev nmoscap_33
nthin_bvar = nthin_var5 AND OD2 
bvargt = vargt4 AND OD2  // 3.3V baseband varactor

//* Define device -- xdev sbd_rf
schottky_n1 = mdiff AND NIMP 
schottky_n2 = schottky_n1 AND nxwell 
schottky_n = schottky_n2 AND SBDUMMY 
schottky_body1 = nxwell INTERACT schottky_n 
schottky_p1 = diff CUT PIMP 
schottky_p2 = schottky_p1 AND nxwell 
schottky_p = schottky_p2 AND SBDUMMY 
schottky_body2 = schottky_body1 INTERACT schottky_p 
schottky_body3 = schottky_body2 INTERACT SBDUMMY 
schottky_body5 = schottky_body3 AND RFDUMMY1 
sbd_rf = schottky_body5 INTERACT DNW 

//* Define device -- xdev sbd_rf_nw
sbd_rf_nw = schottky_body5 NOT INTERACT DNW 

//* Define device -- xdev dnwpsub
dnwdio_b = nxwell INTERACT DNW 
dnwdio_a = nxwell INSIDE DNW 
dnwdio_c = dnwdio_b NOT dnwdio_a 
dnwdio = DNW INTERACT dnwdio_c 

//***** Define connectivity/via layer -- psub_term ****
psub_term_a = psub2s NOT PSUB2 
psub_term_b = BULK NOT psub_term_a 
psub_term_c = BULK AND DNW 
psub_term_d = BULK NOT psub_term_c 
psub_term_e = psub_term_b AND psub_term_d 
psub_term = psub_term_e INTERACT DNW 

//* Define device -- xdev pwdnw
rwdio_a = DNW NOT nxwell 
rwdio = rwdio_a NOT ncoll 

//***** Define connectivity/via layer -- mom5m2 ****
mom5p21 = metal5 AND MOMDMY24 
mom5m2 = mom5p21 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- polyCont ****
polyCont = CONT INTERACT rpoly  //  define POLY1 contact

//***** Define connectivity/via layer -- mom3p1 ****
mom3p11 = metal3 AND MOMDMY23 
mom3p1 = mom3p11 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- dnwc ****
dnwc = DNW AND nxwell 

//***** Define connectivity/via layer -- tiod ****
tioda = diff NOT tpdiff 
tiodb = tioda NOT tndiff 
tiod1 = tiodb NOT POLY1 
tiod2 = tiod1 NOT RPO 
tiod3 = tiod2 NOT RPDMY 
tiod4 = tiod3 NOT RPDMY1 
tiod5 = tiod4 NOT RWDMY1 
tiod = tiod5 NOT RWDMY  //  RPO, RPDMY, RWDMY cut ti-od

//***** Define connectivity/via layer -- n_psub ****
nw_dnw1 = NWELL INTERACT DNW 
nw_dnw = nw_dnw1 INTERACT rw 
n_ppsub = BULK NOT nw_dnw 
n_psub = n_ppsub NOT psubband 

//***** Define connectivity/via layer -- metal7 ****
metal7 = COPY MD  //  Mtop+1 as RDL

//***** Define connectivity/via layer -- mom4p2 ****
mom4p21 = metal4 AND MOMDMY24 
mom4p2 = mom4p21 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- gate1_not_IO1 ****
gate1_not_IO1 = gate NOT OD2 

//***** Define connectivity/via layer -- VIA5 ****
cv5 = VIA5i AND CTM5  //  via for CTM5/M6
tv51 = VIA5i NOT cv5  //  
ind_via = VIA5i AND ind_dmy 
VIA5 = tv51 NOT ind_via  //  via for M5/M6

//* Define ERC or other layers
c_pmall = NWELL NOT NTN  //  pmos all for WPE (clear tone)
c_pmIO = c_pmall AND OD2  //  pmos all for WPE (clear tone)

//***** Define connectivity/via layer -- nxwell_npn ****
ncolls = ncollrg TOUCH pbase 
ncollsa = ncolls TOUCH nemit 
nxwell_npn = ncolls NOT ncollsa 

//***** Define connectivity/via layer -- ppoly ****
ppoly = poly AND PIMP  //  For HRI high poly resistor terminals

//***** Define connectivity/via layer -- mom4m2 ****
mom4m2 = mom4p21 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- VIA3 ****
cv3 = VIA3i AND CTM3  //  via for CTM3/M4
VIA3 = VIA3i NOT cv3  //  via for M4/M4

//***** Define connectivity/via layer -- pplug ****
pplug = tpdiff AND psub  //  define p_sub contact

//***** Define connectivity/via layer -- mom3m2 ****
mom3p21 = metal3 AND MOMDMY24 
mom3m2 = mom3p21 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- odCont ****
odCont = CONT NOT polyCont  //  define OD contact 

//***** Define connectivity/via layer -- crt_poly ****
crt_poly = poly4 NOT poly 

//***** Define connectivity/via layer -- rfdmy56_via ****
rfdmy56gr = SIZE rfdmy56 BY 0.005 
rfdmy56band = rfdmy56gr NOT rfdmy56 
rfdmy56_via = rfdmy56band AND psub 

//***** Define connectivity/via layer -- mom4m1 ****
mom4p11 = metal4 AND MOMDMY23 
mom4m1 = mom4p11 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- pm_cbd ****
pm_cbd = PLMIDE AND CBD 

//***** Define connectivity/via layer -- nplug ****
nplug = tndiff AND nxwell  //  define N_well contact

//***** Define connectivity/via layer -- mom5m1 ****
mom5p11 = metal5 AND MOMDMY23 
mom5m1 = mom5p11 NOT INTERACT MOMDMY25 
erc_exclude1 = VARDMYX OR VARG3 
erc_exclude = erc_exclude1 OR VARG6 
erc_pmos_gates = tpgate NOT erc_exclude 

//***** Define connectivity/via layer -- VIA4 ****
cv4 = VIA4i AND CTM4  //  via for CTM4/M5
VIA4 = VIA4i NOT cv4  //  via for M5/M5

//***** Define connectivity/via layer -- poly_nw ****
poly_nw = poly_term AND nxwell 

//***** Define connectivity/via layer -- mom5p2 ****
mom5p2 = mom5p21 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- mom4p1 ****
mom4p1 = mom4p11 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- ntap ****
ntap1 = tndiff AND nxwell 
ntap2 = ntap1 INTERACT CONT 
tpdiffco = tpdiff INTERACT CONT 
ntap3 = ntap1 INTERACT tpdiffco 
ntap = ntap2 OR ntap3 

//***** Define connectivity/via layer -- mom3p2 ****
mom3p2 = mom3p21 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- ctm_via ****
ctm_via = COPY cv5 

//***** Define connectivity/via layer -- VIA6 ****
VIA6 = COPY VIAD 

//***** Define connectivity/via layer -- n_pplug ****
n_pplug1 = mdiff INTERACT CONT 
n_pplug2 = n_pplug1 AND PIMP 
n_pplug3 = n_pplug2 NOT nxwell 
n_pplug = n_pplug3 AND n_psub 
c_pmcore = c_pmall NOT OD2  //  pmos all for WPE (clear tone)
nw_ntn = NWELL OR NTN 
c_nmIO = OD2 NOT nw_ntn  //  nmos IO for WPE (clear tone) 

//***** Define connectivity/via layer -- mom5p1 ****
mom5p1 = mom5p11 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- mom3m1 ****
mom3m1 = mom3p11 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- rf_pplug ****
rf_pplug1 = tpdiff AND rfdmy56 
rf_pplug2 = rf_pplug1 INTERACT CONT 
tndiffco = tndiff INTERACT CONT 
rf_pplug3 = rf_pplug1 INTERACT tndiffco 
rf_pplug4 = rf_pplug2 OR rf_pplug3 
rf_pplug5 = rf_pplug4 NOT psub 
rf_pplug = rf_pplug5 NOT nxwell 
nxwell_float1 = nxwell NOT INTERACT trwell 
nxwell_float = nxwell_float1 NOT INTERACT VARDMY 

//***** Define connectivity/via layer -- ptap ****
ptap1 = tpdiff AND psub 
ptap2 = ptap1 INTERACT CONT 
ptap3 = ptap1 INTERACT tndiffco 
ptap = ptap2 OR ptap3 

//***** Define connectivity/via layer -- VIA2 ****
cv2 = VIA2i AND CTM2  //  via for CTM2/M3
VIA2 = VIA2i NOT cv2  //  via for M3/M3
erc_nmos_gates = tngate3 NOT erc_exclude 
d_nmcore = OD2 OR nw_ntn  //  nmos core for WPE (Dark tone)
c_nmcore = BULK NOT d_nmcore  //  nmos core for WPE (clear tone)

//***** Define connectivity/via layer -- poly_psub ****
poly_psub = poly_term AND psub 
//#############################################
//# CONNECTION                                #
//#############################################
CONNECT UBM metal7 BY pm_cbd
CONNECT crt_poly poly
CONNECT emit tpdiff
CONNECT emit_od2 tpdiff
CONNECT gate1_not_IO1 poly
CONNECT metal1 crt_poly BY polyCont
CONNECT metal1 poly BY polyCont
CONNECT metal1 poly_rf BY polyCont
CONNECT metal1 ppoly BY polyCont
CONNECT metal1 schottky_n BY odCont
CONNECT metal1 schottky_p BY odCont
CONNECT metal1 tndiff BY odCont
CONNECT metal1 tpdiff BY odCont
CONNECT metal2 metal1 BY VIA1
CONNECT metal3 metal2 BY VIA2
CONNECT metal3 mom3m1
CONNECT metal3 mom3m2
CONNECT metal3 mom3p1
CONNECT metal3 mom3p2
CONNECT metal4 indm4c
CONNECT metal4 metal3 BY VIA3
CONNECT metal4 mom4m1
CONNECT metal4 mom4m2
CONNECT metal4 mom4p1
CONNECT metal4 mom4p2
CONNECT metal5 metal4 BY VIA4
CONNECT metal5 mim_block
CONNECT metal5 mom5m1
CONNECT metal5 mom5m2
CONNECT metal5 mom5p1
CONNECT metal5 mom5p2
CONNECT metal6 ctm BY ctm_via
CONNECT metal6 indm6m
CONNECT metal6 indm6p
CONNECT metal6 metal5 BY VIA5
CONNECT metal7 metal6 BY VIA6
CONNECT mim_po poly
CONNECT nbase tndiff BY nplug
CONNECT nbase_od2 tndiff BY nplug
CONNECT ncoll nxwell_npn
CONNECT nemit tndiff
CONNECT ntap tndiff
CONNECT pbase tpdiff BY pplug
CONNECT poly_rf poly
CONNECT ptap tpdiff
CONNECT tiod tndiff
CONNECT tiod tpdiff
CONNECT tndiff d_tndiff
CONNECT tndiff lcesdm
CONNECT tndiff nxwell_npn BY nplug
CONNECT tndiff s_tndiff
CONNECT tndiff tpdiff
CONNECT tndiff ydio
CONNECT tndiff ydio_hole
CONNECT tpdiff d_tpdiff
CONNECT tpdiff lcesdp
CONNECT tpdiff s_tpdiff

#IFDEF RC_DECK
CONNECT  poly gate
CONNECT  nxwell poly_term BY poly_nw
CONNECT  nxwell DNW BY dnwc
CONNECT  psub poly_term BY poly_psub
CONNECT  psub rfdmy56 BY rfdmy56_via
CONNECT  tpdiff RFDUMMY5T BY rf_pplug
CONNECT  tpdiff psub BY ptap
CONNECT  tpdiff psub_term BY ptap
CONNECT  tpdiff RFDUMMY6T BY rf_pplug
CONNECT  tpdiff coll_od2 BY pplug
CONNECT  tpdiff coll BY pplug
CONNECT  tpdiff rw BY pplug
CONNECT  tndiff nxwell BY ntap
#ELSE
SCONNECT nxwell poly_term BY poly_nw
SCONNECT nxwell DNW BY dnwc
SCONNECT psub poly_term BY poly_psub
SCONNECT psub rfdmy56 BY rfdmy56_via
SCONNECT tpdiff RFDUMMY5T BY rf_pplug
#IFNDEF NW_RING
  SCONNECT tpdiff n_psub BY n_pplug
#ENDIF
SCONNECT tpdiff psub BY ptap
SCONNECT tpdiff psub_term BY ptap
SCONNECT tpdiff RFDUMMY6T BY rf_pplug
SCONNECT tpdiff coll_od2 BY pplug
SCONNECT tpdiff coll BY pplug
SCONNECT tpdiff rw BY pplug
SCONNECT tndiff nxwell BY ntap
#ENDIF
//#############################################
//# FORM DEVICE                               #
//#############################################

#IFDEF RC_DECK
ngate_aux = (SIZE ngate BY WPED) AND c_nmcore
DEVICE MN(N) ngate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <ngate_aux> netlist model nch [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate, tndiff ) + perimeter_inside(ngate, tndiff)) / 2
   L = area(ngate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate,ngate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate,ngate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

nrgate_aux = (SIZE nrgate BY WPED) AND c_nmcore
DEVICE MN(N1) nrgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <nrgate_aux> netlist model nch [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nrgate, tndiff ) + perimeter_inside(nrgate, tndiff)) / 2
   L = area(nrgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(nrgate,nrgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(nrgate,nrgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

bnrgate_aux = (SIZE bnrgate BY WPED) AND c_nmIO
DEVICE MN(N2) bnrgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <bnrgate_aux> netlist model nch3 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(bnrgate, tndiff ) + perimeter_inside(bnrgate, tndiff)) / 2
   L = area(bnrgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(bnrgate,bnrgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(bnrgate,bnrgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

mvt_ngate_aux = (SIZE mvt_ngate BY WPED) AND c_nmcore
DEVICE MN(NA) mvt_ngate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <mvt_ngate_aux> netlist model mench [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(mvt_ngate, tndiff ) + perimeter_inside(mvt_ngate, tndiff)) / 2
   L = area(mvt_ngate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(mvt_ngate,mvt_ngate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(mvt_ngate,mvt_ngate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

bmvt_ngate_aux = (SIZE bmvt_ngate BY WPED) AND c_nmIO
DEVICE MN(NB) bmvt_ngate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <bmvt_ngate_aux> netlist model mench3 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(bmvt_ngate, tndiff ) + perimeter_inside(bmvt_ngate, tndiff)) / 2
   L = area(bmvt_ngate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(bmvt_ngate,bmvt_ngate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(bmvt_ngate,bmvt_ngate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

bngate_aux = (SIZE bngate BY WPED) AND c_nmIO
DEVICE MN(ND) bngate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <bngate_aux> netlist model nch3 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(bngate, tndiff ) + perimeter_inside(bngate, tndiff)) / 2
   L = area(bngate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(bngate,bngate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(bngate,bngate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

nlgate_aux = (SIZE nlgate BY WPED) AND NTN
DEVICE MN(NL) nlgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <nlgate_aux> netlist model nanch [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nlgate, tndiff ) + perimeter_inside(nlgate, tndiff)) / 2
   L = area(nlgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(nlgate,nlgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(nlgate,nlgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

bnlgate_aux = (SIZE bnlgate BY WPED) AND NTN
DEVICE MN(NN) bnlgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <bnlgate_aux> netlist model nanch3 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(bnlgate, tndiff ) + perimeter_inside(bnlgate, tndiff)) / 2
   L = area(bnlgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(bnlgate,bnlgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(bnlgate,bnlgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

bmvt_ngate_mac_aux = (SIZE bmvt_ngate_mac BY WPED) AND c_nmIO
DEVICE MN(NB) bmvt_ngate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <bmvt_ngate_mac_aux> netlist model mench3_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(bmvt_ngate_mac, tndiff ) + perimeter_inside(bmvt_ngate_mac, tndiff)) / 2
   L = area(bmvt_ngate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(bmvt_ngate_mac,bmvt_ngate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(bmvt_ngate_mac,bmvt_ngate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

mvt_ngate_mac_aux = (SIZE mvt_ngate_mac BY WPED) AND c_nmcore
DEVICE MN(NA) mvt_ngate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <mvt_ngate_mac_aux> netlist model mench_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(mvt_ngate_mac, tndiff ) + perimeter_inside(mvt_ngate_mac, tndiff)) / 2
   L = area(mvt_ngate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(mvt_ngate_mac,mvt_ngate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(mvt_ngate_mac,mvt_ngate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

bnlgate_mac_aux = (SIZE bnlgate_mac BY WPED) AND NTN
DEVICE MN(NN) bnlgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <bnlgate_mac_aux> netlist model nanch3_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(bnlgate_mac, tndiff ) + perimeter_inside(bnlgate_mac, tndiff)) / 2
   L = area(bnlgate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(bnlgate_mac,bnlgate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(bnlgate_mac,bnlgate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

nlgate_mac_aux = (SIZE nlgate_mac BY WPED) AND NTN
DEVICE MN(NL) nlgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <nlgate_mac_aux> netlist model nanch_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nlgate_mac, tndiff ) + perimeter_inside(nlgate_mac, tndiff)) / 2
   L = area(nlgate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(nlgate_mac,nlgate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(nlgate_mac,nlgate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

bnrgate_mac_aux = (SIZE bnrgate_mac BY WPED) AND c_nmIO
DEVICE MN(N2) bnrgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <bnrgate_mac_aux> netlist model nch3_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(bnrgate_mac, tndiff ) + perimeter_inside(bnrgate_mac, tndiff)) / 2
   L = area(bnrgate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(bnrgate_mac,bnrgate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(bnrgate_mac,bnrgate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

bngate_mac_aux = (SIZE bngate_mac BY WPED) AND c_nmIO
DEVICE MN(ND) bngate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <bngate_mac_aux> netlist model nch3_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(bngate_mac, tndiff ) + perimeter_inside(bngate_mac, tndiff)) / 2
   L = area(bngate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(bngate_mac,bngate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(bngate_mac,bngate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

nrgate_mac_aux = (SIZE nrgate_mac BY WPED) AND c_nmcore
DEVICE MN(N1) nrgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <nrgate_mac_aux> netlist model nch_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nrgate_mac, tndiff ) + perimeter_inside(nrgate_mac, tndiff)) / 2
   L = area(nrgate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(nrgate_mac,nrgate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(nrgate_mac,nrgate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_mac_aux = (SIZE ngate_mac BY WPED) AND c_nmcore
DEVICE MN(N) ngate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <ngate_mac_aux> netlist model nch_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_mac, tndiff ) + perimeter_inside(ngate_mac, tndiff)) / 2
   L = area(ngate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_mac,ngate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_mac,ngate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_aux = (SIZE pgate BY WPED) AND c_pmcore
DEVICE MP(P) pgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_aux> netlist model pch [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate, tpdiff ) + perimeter_inside(pgate, tpdiff)) / 2
   L = area(pgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate,pgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate,pgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

mvt_pgate_aux = (SIZE mvt_pgate BY WPED) AND c_pmcore
DEVICE MP(PA) mvt_pgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <mvt_pgate_aux> netlist model mepch [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(mvt_pgate, tpdiff ) + perimeter_inside(mvt_pgate, tpdiff)) / 2
   L = area(mvt_pgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(mvt_pgate,mvt_pgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(mvt_pgate,mvt_pgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

bpgate_aux = (SIZE bpgate BY WPED) AND c_pmIO
DEVICE MP(PD) bpgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <bpgate_aux> netlist model pch3 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(bpgate, tpdiff ) + perimeter_inside(bpgate, tpdiff)) / 2
   L = area(bpgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(bpgate,bpgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(bpgate,bpgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

mvt_pgate_mac_aux = (SIZE mvt_pgate_mac BY WPED) AND c_pmcore
DEVICE MP(PA) mvt_pgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <mvt_pgate_mac_aux> netlist model mepch_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(mvt_pgate_mac, tpdiff ) + perimeter_inside(mvt_pgate_mac, tpdiff)) / 2
   L = area(mvt_pgate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(mvt_pgate_mac,mvt_pgate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(mvt_pgate_mac,mvt_pgate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

bpgate_mac_aux = (SIZE bpgate_mac BY WPED) AND c_pmIO
DEVICE MP(PD) bpgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <bpgate_mac_aux> netlist model pch3_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(bpgate_mac, tpdiff ) + perimeter_inside(bpgate_mac, tpdiff)) / 2
   L = area(bpgate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(bpgate_mac,bpgate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(bpgate_mac,bpgate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_mac_aux = (SIZE pgate_mac BY WPED) AND c_pmcore
DEVICE MP(P) pgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_mac_aux> netlist model pch_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_mac, tpdiff ) + perimeter_inside(pgate_mac, tpdiff)) / 2
   L = area(pgate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_mac,pgate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_mac,pgate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

#ELSE

#IFDEF extract_as_ad
DEVICE MN(N) ngate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate, tndiff ) + perimeter_inside(ngate, tndiff)) / 2
   L=area(ngate) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(N1) nrgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(nrgate, tndiff ) + perimeter_inside(nrgate, tndiff)) / 2
   L=area(nrgate) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(N2) bnrgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bnrgate, tndiff ) + perimeter_inside(bnrgate, tndiff)) / 2
   L=area(bnrgate) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(NA) mvt_ngate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(mvt_ngate, tndiff ) + perimeter_inside(mvt_ngate, tndiff)) / 2
   L=area(mvt_ngate) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(NB) bmvt_ngate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bmvt_ngate, tndiff ) + perimeter_inside(bmvt_ngate, tndiff)) / 2
   L=area(bmvt_ngate) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(ND) bngate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bngate, tndiff ) + perimeter_inside(bngate, tndiff)) / 2
   L=area(bngate) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(NL) nlgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(nlgate, tndiff ) + perimeter_inside(nlgate, tndiff)) / 2
   L=area(nlgate) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(NN) bnlgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bnlgate, tndiff ) + perimeter_inside(bnlgate, tndiff)) / 2
   L=area(bnlgate) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(NB) bmvt_ngate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bmvt_ngate_mac, tndiff ) + perimeter_inside(bmvt_ngate_mac, tndiff)) / 2
   L=area(bmvt_ngate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(NA) mvt_ngate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(mvt_ngate_mac, tndiff ) + perimeter_inside(mvt_ngate_mac, tndiff)) / 2
   L=area(mvt_ngate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(NN) bnlgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bnlgate_mac, tndiff ) + perimeter_inside(bnlgate_mac, tndiff)) / 2
   L=area(bnlgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(NL) nlgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(nlgate_mac, tndiff ) + perimeter_inside(nlgate_mac, tndiff)) / 2
   L=area(nlgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(N2) bnrgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bnrgate_mac, tndiff ) + perimeter_inside(bnrgate_mac, tndiff)) / 2
   L=area(bnrgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(ND) bngate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bngate_mac, tndiff ) + perimeter_inside(bngate_mac, tndiff)) / 2
   L=area(bngate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(N1) nrgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(nrgate_mac, tndiff ) + perimeter_inside(nrgate_mac, tndiff)) / 2
   L=area(nrgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(N) ngate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_mac, tndiff ) + perimeter_inside(ngate_mac, tndiff)) / 2
   L=area(ngate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MP(P) pgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate, tpdiff ) + perimeter_inside(pgate, tpdiff)) / 2 
   L=area(pgate) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(PA) mvt_pgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(mvt_pgate, tpdiff ) + perimeter_inside(mvt_pgate, tpdiff)) / 2 
   L=area(mvt_pgate) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(PD) bpgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bpgate, tpdiff ) + perimeter_inside(bpgate, tpdiff)) / 2 
   L=area(bpgate) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(PA) mvt_pgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(mvt_pgate_mac, tpdiff ) + perimeter_inside(mvt_pgate_mac, tpdiff)) / 2 
   L=area(mvt_pgate_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(PD) bpgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bpgate_mac, tpdiff ) + perimeter_inside(bpgate_mac, tpdiff)) / 2 
   L=area(bpgate_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(P) pgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_mac, tpdiff ) + perimeter_inside(pgate_mac, tpdiff)) / 2 
   L=area(pgate_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]


#ELSE
DEVICE MN(N) ngate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate, tndiff ) + perimeter_inside(ngate, tndiff)) / 2 
   L=area(ngate) / W
]
DEVICE MN(N1) nrgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nrgate, tndiff ) + perimeter_inside(nrgate, tndiff)) / 2 
   L=area(nrgate) / W
]
DEVICE MN(N2) bnrgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bnrgate, tndiff ) + perimeter_inside(bnrgate, tndiff)) / 2 
   L=area(bnrgate) / W
]
DEVICE MN(NA) mvt_ngate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(mvt_ngate, tndiff ) + perimeter_inside(mvt_ngate, tndiff)) / 2 
   L=area(mvt_ngate) / W
]
DEVICE MN(NB) bmvt_ngate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bmvt_ngate, tndiff ) + perimeter_inside(bmvt_ngate, tndiff)) / 2 
   L=area(bmvt_ngate) / W
]
DEVICE MN(ND) bngate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bngate, tndiff ) + perimeter_inside(bngate, tndiff)) / 2 
   L=area(bngate) / W
]
DEVICE MN(NL) nlgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nlgate, tndiff ) + perimeter_inside(nlgate, tndiff)) / 2 
   L=area(nlgate) / W
]
DEVICE MN(NN) bnlgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bnlgate, tndiff ) + perimeter_inside(bnlgate, tndiff)) / 2 
   L=area(bnlgate) / W
]
DEVICE MN(NB) bmvt_ngate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bmvt_ngate_mac, tndiff ) + perimeter_inside(bmvt_ngate_mac, tndiff)) / 2 
   L=area(bmvt_ngate_mac) / W
]
DEVICE MN(NA) mvt_ngate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(mvt_ngate_mac, tndiff ) + perimeter_inside(mvt_ngate_mac, tndiff)) / 2 
   L=area(mvt_ngate_mac) / W
]
DEVICE MN(NN) bnlgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bnlgate_mac, tndiff ) + perimeter_inside(bnlgate_mac, tndiff)) / 2 
   L=area(bnlgate_mac) / W
]
DEVICE MN(NL) nlgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nlgate_mac, tndiff ) + perimeter_inside(nlgate_mac, tndiff)) / 2 
   L=area(nlgate_mac) / W
]
DEVICE MN(N2) bnrgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bnrgate_mac, tndiff ) + perimeter_inside(bnrgate_mac, tndiff)) / 2 
   L=area(bnrgate_mac) / W
]
DEVICE MN(ND) bngate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bngate_mac, tndiff ) + perimeter_inside(bngate_mac, tndiff)) / 2 
   L=area(bngate_mac) / W
]
DEVICE MN(N1) nrgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nrgate_mac, tndiff ) + perimeter_inside(nrgate_mac, tndiff)) / 2 
   L=area(nrgate_mac) / W
]
DEVICE MN(N) ngate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_mac, tndiff ) + perimeter_inside(ngate_mac, tndiff)) / 2 
   L=area(ngate_mac) / W
]
DEVICE MP(P) pgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate, tpdiff ) + perimeter_inside(pgate, tpdiff)) / 2 
   L=area(pgate) / W
]
DEVICE MP(PA) mvt_pgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(mvt_pgate, tpdiff ) + perimeter_inside(mvt_pgate, tpdiff)) / 2 
   L=area(mvt_pgate) / W
]
DEVICE MP(PD) bpgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(bpgate, tpdiff ) + perimeter_inside(bpgate, tpdiff)) / 2 
   L=area(bpgate) / W
]
DEVICE MP(PA) mvt_pgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(mvt_pgate_mac, tpdiff ) + perimeter_inside(mvt_pgate_mac, tpdiff)) / 2 
   L=area(mvt_pgate_mac) / W
]
DEVICE MP(PD) bpgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(bpgate_mac, tpdiff ) + perimeter_inside(bpgate_mac, tpdiff)) / 2 
   L=area(bpgate_mac) / W
]
DEVICE MP(P) pgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_mac, tpdiff ) + perimeter_inside(pgate_mac, tpdiff)) / 2 
   L=area(pgate_mac) / W
]


#ENDIF

#ENDIF


#IFNDEF RC_DECK
TRACE PROPERTY MN(N) L L 0
TRACE PROPERTY MN(N) W W 0
TRACE PROPERTY MN(N1) L L 0
TRACE PROPERTY MN(N1) W W 0
TRACE PROPERTY MN(N2) L L 0
TRACE PROPERTY MN(N2) W W 0
TRACE PROPERTY MN(NA) L L 0
TRACE PROPERTY MN(NA) W W 0
TRACE PROPERTY MN(NB) L L 0
TRACE PROPERTY MN(NB) W W 0
TRACE PROPERTY MN(ND) L L 0
TRACE PROPERTY MN(ND) W W 0
TRACE PROPERTY MN(NL) L L 0
TRACE PROPERTY MN(NL) W W 0
TRACE PROPERTY MN(NN) L L 0
TRACE PROPERTY MN(NN) W W 0
TRACE PROPERTY MP(P) L L 0
TRACE PROPERTY MP(P) W W 0
TRACE PROPERTY MP(PA) L L 0
TRACE PROPERTY MP(PA) W W 0
TRACE PROPERTY MP(PD) L L 0
TRACE PROPERTY MP(PD) W W 0
#ENDIF

DEVICE D(D1) pdio_3 tpdiff nxwell netlist model pdio_3
  TRACE PROPERTY D(D1) A A 0
DEVICE D(D2) ndio_3 psub tndiff netlist model ndio_3
  TRACE PROPERTY D(D2) A A 0
DEVICE D(D3) nwdio_3 psub nxwell netlist model nwdio_3
  TRACE PROPERTY D(D3) A A 0
DEVICE D(DB) ydio psub tndiff netlist model endio_3
  TRACE PROPERTY D(DB) A A 0
DEVICE D(DN) ndio psub tndiff netlist model ndio
  TRACE PROPERTY D(DN) A A 0
DEVICE D(DP) pdio tpdiff nxwell netlist model pdio
  TRACE PROPERTY D(DP) A A 0
DEVICE D(DW) nwdio psub nxwell netlist model nwdio
  TRACE PROPERTY D(DW) A A 0
DEVICE D(ndio_3m) ndio_3m psub tndiff netlist model ndio_3m
  TRACE PROPERTY D(ndio_3m) A A 0
DEVICE D(ndio_m) ndio_m psub tndiff netlist model ndio_m
  TRACE PROPERTY D(ndio_m) A A 0
DEVICE D(pdio_m) pdio_m tpdiff nxwell netlist model pdio_m
  TRACE PROPERTY D(pdio_m) A A 0
#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(LR) lrpop poly poly netlist model rppolyhri netlist element "X" [
      property w,l,R
      w = perimeter_coincide(lrpop,poly)/2
      A = area(lrpop)
      l = A/w
      R = RVLR*l/w
    ]
    //TRACE PROPERTY R(LR) w w 0
    //TRACE PROPERTY R(LR) l l 0
    TRACE PROPERTY R(LR) R R 2
  #ELSE
    DEVICE R(LR) lrpop poly poly [
      property R
      w = perimeter_coincide(lrpop,poly)/2
      A = area(lrpop)
      l = A/w
      R = RVLR*l/w
    ]
    TRACE PROPERTY R(LR) R R 2
  #ENDIF
#ELSE
  DEVICE R(LR) lrpop poly poly [RVLR]
    TRACE PROPERTY R(LR) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(M1) mt1res metal1 metal1 netlist model rm1 netlist element "X" [
      property w,l,R
      w = perimeter_coincide(mt1res,metal1)/2
      A = area(mt1res)
      l = A/w
      R = RVM1*l/w
    ]
    //TRACE PROPERTY R(M1) w w 0
    //TRACE PROPERTY R(M1) l l 0
    TRACE PROPERTY R(M1) R R 2
  #ELSE
    DEVICE R(M1) mt1res metal1 metal1 [
      property R
      w = perimeter_coincide(mt1res,metal1)/2
      A = area(mt1res)
      l = A/w
      R = RVM1*l/w
    ]
    TRACE PROPERTY R(M1) R R 2
  #ENDIF
#ELSE
  DEVICE R(M1) mt1res metal1 metal1 [RVM1]
    TRACE PROPERTY R(M1) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(M2) mt2res metal2 metal2 netlist model rm2 netlist element "X" [
      property w,l,R
      w = perimeter_coincide(mt2res,metal2)/2
      A = area(mt2res)
      l = A/w
      R = RVM2*l/w
    ]
    //TRACE PROPERTY R(M2) w w 0
    //TRACE PROPERTY R(M2) l l 0
    TRACE PROPERTY R(M2) R R 2
  #ELSE
    DEVICE R(M2) mt2res metal2 metal2 [
      property R
      w = perimeter_coincide(mt2res,metal2)/2
      A = area(mt2res)
      l = A/w
      R = RVM2*l/w
    ]
    TRACE PROPERTY R(M2) R R 2
  #ENDIF
#ELSE
  DEVICE R(M2) mt2res metal2 metal2 [RVM2]
    TRACE PROPERTY R(M2) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(M3) mt3res metal3 metal3 netlist model rm3 netlist element "X" [
      property w,l,R
      w = perimeter_coincide(mt3res,metal3)/2
      A = area(mt3res)
      l = A/w
      R = RVM3*l/w
    ]
    //TRACE PROPERTY R(M3) w w 0
    //TRACE PROPERTY R(M3) l l 0
    TRACE PROPERTY R(M3) R R 2
  #ELSE
    DEVICE R(M3) mt3res metal3 metal3 [
      property R
      w = perimeter_coincide(mt3res,metal3)/2
      A = area(mt3res)
      l = A/w
      R = RVM3*l/w
    ]
    TRACE PROPERTY R(M3) R R 2
  #ENDIF
#ELSE
  DEVICE R(M3) mt3res metal3 metal3 [RVM3]
    TRACE PROPERTY R(M3) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(M4) mt4res metal4 metal4 netlist model rm4 netlist element "X" [
      property w,l,R
      w = perimeter_coincide(mt4res,metal4)/2
      A = area(mt4res)
      l = A/w
      R = RVM4*l/w
    ]
    //TRACE PROPERTY R(M4) w w 0
    //TRACE PROPERTY R(M4) l l 0
    TRACE PROPERTY R(M4) R R 2
  #ELSE
    DEVICE R(M4) mt4res metal4 metal4 [
      property R
      w = perimeter_coincide(mt4res,metal4)/2
      A = area(mt4res)
      l = A/w
      R = RVM4*l/w
    ]
    TRACE PROPERTY R(M4) R R 2
  #ENDIF
#ELSE
  DEVICE R(M4) mt4res metal4 metal4 [RVM4]
    TRACE PROPERTY R(M4) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(M5) mt5res metal5 metal5 netlist model rm5 netlist element "X" [
      property w,l,R
      w = perimeter_coincide(mt5res,metal5)/2
      A = area(mt5res)
      l = A/w
      R = RVM5*l/w
    ]
    //TRACE PROPERTY R(M5) w w 0
    //TRACE PROPERTY R(M5) l l 0
    TRACE PROPERTY R(M5) R R 2
  #ELSE
    DEVICE R(M5) mt5res metal5 metal5 [
      property R
      w = perimeter_coincide(mt5res,metal5)/2
      A = area(mt5res)
      l = A/w
      R = RVM5*l/w
    ]
    TRACE PROPERTY R(M5) R R 2
  #ENDIF
#ELSE
  DEVICE R(M5) mt5res metal5 metal5 [RVM5]
    TRACE PROPERTY R(M5) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(ND) nrdop tndiff tndiff netlist model rnodrpo netlist element "X" [
      property w,l,R
      w = perimeter_coincide(nrdop,tndiff)/2
      A = area(nrdop)
      l = A/w
      R = RVND*l/w
    ]
    //TRACE PROPERTY R(ND) w w 0
    //TRACE PROPERTY R(ND) l l 0
    TRACE PROPERTY R(ND) R R 2
  #ELSE
    DEVICE R(ND) nrdop tndiff tndiff [
      property R
      w = perimeter_coincide(nrdop,tndiff)/2
      A = area(nrdop)
      l = A/w
      R = RVND*l/w
    ]
    TRACE PROPERTY R(ND) R R 2
  #ENDIF
#ELSE
  DEVICE R(ND) nrdop tndiff tndiff [RVND]
    TRACE PROPERTY R(ND) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(NI) rnodl_r tndiff tndiff netlist model rnod netlist element "X" [
      property w,l,R
      w = perimeter_coincide(rnodl_r,tndiff)/2
      A = area(rnodl_r)
      l = A/w
      R = RVNI*l/w
    ]
    //TRACE PROPERTY R(NI) w w 0
    //TRACE PROPERTY R(NI) l l 0
    TRACE PROPERTY R(NI) R R 2
  #ELSE
    DEVICE R(NI) rnodl_r tndiff tndiff [
      property R
      w = perimeter_coincide(rnodl_r,tndiff)/2
      A = area(rnodl_r)
      l = A/w
      R = RVNI*l/w
    ]
    TRACE PROPERTY R(NI) R R 2
  #ENDIF
#ELSE
  DEVICE R(NI) rnodl_r tndiff tndiff [RVNI]
    TRACE PROPERTY R(NI) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(NI) rnods_r tndiff tndiff netlist model rnodw netlist element "X" [
      property w,l,R
      w = perimeter_coincide(rnods_r,tndiff)/2
      A = area(rnods_r)
      l = A/w
      R = RVNI*l/w
    ]
  #ELSE
    DEVICE R(NI) rnods_r tndiff tndiff [
      property R
      w = perimeter_coincide(rnods_r,tndiff)/2
      A = area(rnods_r)
      l = A/w
      R = RVNI*l/w
    ]
  #ENDIF
#ELSE
  DEVICE R(NI) rnods_r tndiff tndiff [RVNI]
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(NR) nrpop poly poly netlist model rnpo1rpo netlist element "X" [
      property w,l,R
      w = perimeter_coincide(nrpop,poly)/2
      A = area(nrpop)
      l = A/w
      R = RVNR*l/w
    ]
    //TRACE PROPERTY R(NR) w w 0
    //TRACE PROPERTY R(NR) l l 0
    TRACE PROPERTY R(NR) R R 2
  #ELSE
    DEVICE R(NR) nrpop poly poly [
      property R
      w = perimeter_coincide(nrpop,poly)/2
      A = area(nrpop)
      l = A/w
      R = RVNR*l/w
    ]
    TRACE PROPERTY R(NR) R R 2
  #ENDIF
#ELSE
  DEVICE R(NR) nrpop poly poly [RVNR]
    TRACE PROPERTY R(NR) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(NS) rnpolyl_r poly poly netlist model rnpo1 netlist element "X" [
      property w,l,R
      w = perimeter_coincide(rnpolyl_r,poly)/2
      A = area(rnpolyl_r)
      l = A/w
      R = RVNS*l/w
    ]
    //TRACE PROPERTY R(NS) w w 0
    //TRACE PROPERTY R(NS) l l 0
    TRACE PROPERTY R(NS) R R 2
  #ELSE
    DEVICE R(NS) rnpolyl_r poly poly [
      property R
      w = perimeter_coincide(rnpolyl_r,poly)/2
      A = area(rnpolyl_r)
      l = A/w
      R = RVNS*l/w
    ]
    TRACE PROPERTY R(NS) R R 2
  #ENDIF
#ELSE
  DEVICE R(NS) rnpolyl_r poly poly [RVNS]
    TRACE PROPERTY R(NS) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(NS) rnpolys_r poly poly netlist model rnpo1w netlist element "X" [
      property w,l,R
      w = perimeter_coincide(rnpolys_r,poly)/2
      A = area(rnpolys_r)
      l = A/w
      R = RVNS*l/w
    ]
  #ELSE
    DEVICE R(NS) rnpolys_r poly poly [
      property R
      w = perimeter_coincide(rnpolys_r,poly)/2
      A = area(rnpolys_r)
      l = A/w
      R = RVNS*l/w
    ]
  #ENDIF
#ELSE
  DEVICE R(NS) rnpolys_r poly poly [RVNS]
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(PD) prdop tpdiff tpdiff netlist model rpodrpo netlist element "X" [
      property w,l,R
      w = perimeter_coincide(prdop,tpdiff)/2
      A = area(prdop)
      l = A/w
      R = RVPD*l/w
    ]
    //TRACE PROPERTY R(PD) w w 0
    //TRACE PROPERTY R(PD) l l 0
    TRACE PROPERTY R(PD) R R 2
  #ELSE
    DEVICE R(PD) prdop tpdiff tpdiff [
      property R
      w = perimeter_coincide(prdop,tpdiff)/2
      A = area(prdop)
      l = A/w
      R = RVPD*l/w
    ]
    TRACE PROPERTY R(PD) R R 2
  #ENDIF
#ELSE
  DEVICE R(PD) prdop tpdiff tpdiff [RVPD]
    TRACE PROPERTY R(PD) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(PI) rpodl_r tpdiff tpdiff netlist model rpod netlist element "X" [
      property w,l,R
      w = perimeter_coincide(rpodl_r,tpdiff)/2
      A = area(rpodl_r)
      l = A/w
      R = RVPI*l/w
    ]
    //TRACE PROPERTY R(PI) w w 0
    //TRACE PROPERTY R(PI) l l 0
    TRACE PROPERTY R(PI) R R 2
  #ELSE
    DEVICE R(PI) rpodl_r tpdiff tpdiff [
      property R
      w = perimeter_coincide(rpodl_r,tpdiff)/2
      A = area(rpodl_r)
      l = A/w
      R = RVPI*l/w
    ]
    TRACE PROPERTY R(PI) R R 2
  #ENDIF
#ELSE
  DEVICE R(PI) rpodl_r tpdiff tpdiff [RVPI]
    TRACE PROPERTY R(PI) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(PI) rpods_r tpdiff tpdiff netlist model rpodw netlist element "X" [
      property w,l,R
      w = perimeter_coincide(rpods_r,tpdiff)/2
      A = area(rpods_r)
      l = A/w
      R = RVPI*l/w
    ]
  #ELSE
    DEVICE R(PI) rpods_r tpdiff tpdiff [
      property R
      w = perimeter_coincide(rpods_r,tpdiff)/2
      A = area(rpods_r)
      l = A/w
      R = RVPI*l/w
    ]
  #ENDIF
#ELSE
  DEVICE R(PI) rpods_r tpdiff tpdiff [RVPI]
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(PR) prpop poly poly netlist model rppo1rpo netlist element "X" [
      property w,l,R
      w = perimeter_coincide(prpop,poly)/2
      A = area(prpop)
      l = A/w
      R = RVPR*l/w
    ]
    //TRACE PROPERTY R(PR) w w 0
    //TRACE PROPERTY R(PR) l l 0
    TRACE PROPERTY R(PR) R R 2
  #ELSE
    DEVICE R(PR) prpop poly poly [
      property R
      w = perimeter_coincide(prpop,poly)/2
      A = area(prpop)
      l = A/w
      R = RVPR*l/w
    ]
    TRACE PROPERTY R(PR) R R 2
  #ENDIF
#ELSE
  DEVICE R(PR) prpop poly poly [RVPR]
    TRACE PROPERTY R(PR) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(PS) rppolyl_r poly poly netlist model rppo1 netlist element "X" [
      property w,l,R
      w = perimeter_coincide(rppolyl_r,poly)/2
      A = area(rppolyl_r)
      l = A/w
      R = RVPS*l/w
    ]
    //TRACE PROPERTY R(PS) w w 0
    //TRACE PROPERTY R(PS) l l 0
    TRACE PROPERTY R(PS) R R 2
  #ELSE
    DEVICE R(PS) rppolyl_r poly poly [
      property R
      w = perimeter_coincide(rppolyl_r,poly)/2
      A = area(rppolyl_r)
      l = A/w
      R = RVPS*l/w
    ]
    TRACE PROPERTY R(PS) R R 2
  #ENDIF
#ELSE
  DEVICE R(PS) rppolyl_r poly poly [RVPS]
    TRACE PROPERTY R(PS) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(PS) rppolys_r poly poly netlist model rppo1w netlist element "X" [
      property w,l,R
      w = perimeter_coincide(rppolys_r,poly)/2
      A = area(rppolys_r)
      l = A/w
      R = RVPS*l/w
    ]
  #ELSE
    DEVICE R(PS) rppolys_r poly poly [
      property R
      w = perimeter_coincide(rppolys_r,poly)/2
      A = area(rppolys_r)
      l = A/w
      R = RVPS*l/w
    ]
  #ENDIF
#ELSE
  DEVICE R(PS) rppolys_r poly poly [RVPS]
#ENDIF


// User define devices 
#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(MT) mt6res metal6 metal6 netlist model rmt netlist element "X" [
      property w,l,R
      w = perimeter_coincide(mt6res,metal6)/2
      A = area(mt6res)
      l = A/w
      R = RVMT*l/w
    ]
    //TRACE PROPERTY R(MT) w w 0
    //TRACE PROPERTY R(MT) l l 0
    TRACE PROPERTY R(MT) R R 0
  #ELSE
    DEVICE R(MT) mt6res metal6 metal6 [
      property R
      w = perimeter_coincide(mt6res,metal6)/2
      A = area(mt6res)
      l = A/w
      R = RVMT*l/w
    ]
    TRACE PROPERTY R(MT) R R 0
  #ENDIF
#ELSE
  DEVICE R(MT) mt6res metal6 metal6 [RVMT]
    TRACE PROPERTY R(MT) R R 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(NV) nemit10 ncoll pbase nemit netlist model npn10
#ELSE
DEVICE Q(NV) nemit10 ncoll pbase nemit netlist model npn10 [
		property A
		A = area(nemit)
]
TRACE PROPERTY Q(NV) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(NV_mis) nemit10_mis ncoll(C) pbase(B) nemit(E) netlist model npn10_mis netlist element "X"
#ELSE
DEVICE Q(NV_mis) nemit10_mis ncoll(C) pbase(B) nemit(E) netlist model npn10_mis [
		property A
		A = area(nemit)
]
TRACE PROPERTY Q(NV_mis) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(NV) nemit2 ncoll pbase nemit netlist model npn2
#ELSE
DEVICE Q(NV) nemit2 ncoll pbase nemit netlist model npn2 [
		property A
		A = area(nemit)
]
#ENDIF

#IFDEF RC_DECK
DEVICE Q(NV_mis) nemit2_mis ncoll(C) pbase(B) nemit(E) netlist model npn2_mis netlist element "X"
#ELSE
DEVICE Q(NV_mis) nemit2_mis ncoll(C) pbase(B) nemit(E) netlist model npn2_mis [
		property A
		A = area(nemit)
]
#ENDIF

#IFDEF RC_DECK
DEVICE Q(NV) nemit5 ncoll pbase nemit netlist model npn5
#ELSE
DEVICE Q(NV) nemit5 ncoll pbase nemit netlist model npn5 [
		property A
		A = area(nemit)
]
#ENDIF

#IFDEF RC_DECK
DEVICE Q(NV_mis) nemit5_mis ncoll(C) pbase(B) nemit(E) netlist model npn5_mis netlist element "X"
#ELSE
DEVICE Q(NV_mis) nemit5_mis ncoll(C) pbase(B) nemit(E) netlist model npn5_mis [
		property A
		A = area(nemit)
]
#ENDIF

#IFDEF RC_DECK
DEVICE Q(P1) iemit10 coll_od2 nbase_od2 emit_od2 netlist model pnp10_3
#ELSE
DEVICE Q(P1) iemit10 coll_od2 nbase_od2 emit_od2 netlist model pnp10_3 [
		property A
		A = area(emit_od2)
]
TRACE PROPERTY Q(P1) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(P1) iemit2 coll_od2 nbase_od2 emit_od2 netlist model pnp2_3
#ELSE
DEVICE Q(P1) iemit2 coll_od2 nbase_od2 emit_od2 netlist model pnp2_3 [
		property A
		A = area(emit_od2)
]
#ENDIF

#IFDEF RC_DECK
DEVICE Q(P1) iemit5 coll_od2 nbase_od2 emit_od2 netlist model pnp5_3
#ELSE
DEVICE Q(P1) iemit5 coll_od2 nbase_od2 emit_od2 netlist model pnp5_3 [
		property A
		A = area(emit_od2)
]
#ENDIF

#IFDEF RC_DECK
DEVICE Q(PV) emit10 coll nbase emit netlist model pnp10
#ELSE
DEVICE Q(PV) emit10 coll nbase emit netlist model pnp10 [
		property A
		A = area(emit)
]
TRACE PROPERTY Q(PV) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(PV_mis) emit10_mis coll(C) nbase(B) emit(E) netlist model pnp10_mis netlist element "X"
#ELSE
DEVICE Q(PV_mis) emit10_mis coll(C) nbase(B) emit(E) netlist model pnp10_mis [
		property A
		A = area(emit)
]
TRACE PROPERTY Q(PV_mis) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(PV) emit2 coll nbase emit netlist model pnp2
#ELSE
DEVICE Q(PV) emit2 coll nbase emit netlist model pnp2 [
		property A
		A = area(emit)
]
#ENDIF

#IFDEF RC_DECK
DEVICE Q(PV_mis) emit2_mis coll(C) nbase(B) emit(E) netlist model pnp2_mis netlist element "X"
#ELSE
DEVICE Q(PV_mis) emit2_mis coll(C) nbase(B) emit(E) netlist model pnp2_mis [
		property A
		A = area(emit)
]
#ENDIF

#IFDEF RC_DECK
DEVICE Q(PV) emit5 coll nbase emit netlist model pnp5
#ELSE
DEVICE Q(PV) emit5 coll nbase emit netlist model pnp5 [
		property A
		A = area(emit)
]
#ENDIF

#IFDEF RC_DECK
DEVICE Q(PV_mis) emit5_mis coll(C) nbase(B) emit(E) netlist model pnp5_mis netlist element "X"
#ELSE
DEVICE Q(PV_mis) emit5_mis coll(C) nbase(B) emit(E) netlist model pnp5_mis [
		property A
		A = area(emit)
]
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(WO) nwod nxwell nxwell netlist model rnwod netlist element "X" [
      property w,l,R
      w = perimeter_coincide(nwod,nxwell)/2
      A = area(nwod)
      l = A/w
      R = RVWO*l/w
    ]
    //TRACE PROPERTY R(MT) w w 0
    //TRACE PROPERTY R(MT) l l 0
    TRACE PROPERTY R(WO) R R 0
  #ELSE
    DEVICE R(WO) nwod nxwell nxwell [
      property R
      w = perimeter_coincide(nwod,nxwell)/2
      A = area(nwod)
      l = A/w
      R = RVWO*l/w
    ]
    TRACE PROPERTY R(WO) R R 0
  #ENDIF
#ELSE
  DEVICE R(WO) nwod nxwell nxwell [RVWO]
    TRACE PROPERTY R(WO) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(WR) nwsti nxwell nxwell netlist model rnwsti netlist element "X" [
      property w,l,R
      w = perimeter_coincide(nwsti,nxwell)/2
      A = area(nwsti)
      l = A/w
      R = RVWR*l/w
    ]
    //TRACE PROPERTY R(MT) w w 0
    //TRACE PROPERTY R(MT) l l 0
    TRACE PROPERTY R(WR) R R 0
  #ELSE
    DEVICE R(WR) nwsti nxwell nxwell [
      property R
      w = perimeter_coincide(nwsti,nxwell)/2
      A = area(nwsti)
      l = A/w
      R = RVWR*l/w
    ]
    TRACE PROPERTY R(WR) R R 0
  #ENDIF
#ELSE
  DEVICE R(WR) nwsti nxwell nxwell [RVWR]
    TRACE PROPERTY R(WR) R R 0
#ENDIF

//

//

//


MOM_field1 = M1 AND MOMDMY1
MOM_field2 = M2 AND MOMDMY2
MOM_field3 = M3 AND MOMDMY3
MOM_field4 = M4 AND MOMDMY4
MOM_field5 = M5 AND MOMDMY5

F_reg1a = EXT MOM_field1 < 0.565 OPPOSITE REGION
F_reg1  = ( F_reg1a AND MOMDMY1 ) NOT M1
F_reg2a = EXT MOM_field2 < 0.565 OPPOSITE REGION
F_reg2  = ( F_reg2a AND MOMDMY2 ) NOT M2
F_reg3a = EXT MOM_field3 < 0.565 OPPOSITE REGION
F_reg3  = ( F_reg3a AND MOMDMY3 ) NOT M3
F_reg4a = EXT MOM_field4 < 0.565 OPPOSITE REGION
F_reg4  = ( F_reg4a AND MOMDMY4 ) NOT M4
F_reg5a = EXT MOM_field5 < 0.565 OPPOSITE REGION
F_reg5  = ( F_reg5a AND MOMDMY5 ) NOT M5



mom13_1 = MOMDMY3 INTERACT MOM_field1

mom13_2 = mom13_1 INTERACT MOM_field2

mom13_3 = mom13_2 INTERACT MOM_field3


mom13_idt = MOM_field3 NOT MOM_field2

mom13_4 = mom13_3 NOT INTERACT MOM_field4
mom13_5 = mom13_4 NOT INTERACT MOM_field5

mom13_reg1 = mom13_5 NOT INTERACT RFDUMMY
mom13_reg0 = mom13_reg1 NOT RFDUMMY1
mom13_reg = mom13_reg0 INTERACT mom13_idt
mom13_reg_rf0 = mom13_reg1 AND RFDUMMY1
mom13_reg_rf = mom13_reg_rf0 INTERACT mom13_idt





fmom13_reg1     = mom13_5 NOT INTERACT RFDUMMY
fmom13_reg2     = fmom13_reg1 NOT INTERACT RFDUMMY1
fmom13_reg3     = fmom13_reg2 NOT INTERACT mom13_idt
fmom13_reg4     = fmom13_reg3 INTERACT MOMDMY100
fmom13_reg5     = fmom13_reg4 NOT INTERACT MOMDMY22
fmom13_reg      = fmom13_reg5 INTERACT NIMP

fmom13_rf_reg1  = mom13_5 INTERACT RFDUMMY1
fmom13_rf_reg2  = fmom13_rf_reg1 NOT INTERACT mom13_idt
fmom13_rf_reg3  = fmom13_rf_reg2 INTERACT MOMDMY100
fmom13_rf_reg4  = fmom13_rf_reg3 NOT INTERACT MOMDMY22
fmom13_rf_reg   = fmom13_rf_reg4 INTERACT NIMP

fmom13_mx_reg1  = MOMDMY22 INTERACT mom13_5
fmom13_mx_reg2  = fmom13_mx_reg1 NOT INTERACT mom13_idt
fmom13_mx_reg3  = fmom13_mx_reg2 INTERACT MOMDMY100
fmom13_mx_reg   = fmom13_mx_reg3 INTERACT NIMP
mom13_mx_aux   = mom13_5 AND MOMDMY22


DEVICE crtmom mom13_reg metal3(PLUS) metal3(MINUS) crt_poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w  = perimeter_coincide(MOM_field2,mom13_reg)/ nh
    s  = ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 3
] 


DEVICE cfmom fmom13_reg metal3(PLUS) metal3(MINUS) crt_poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field1)
    w =  perimeter_coincide(MOM_field1,fmom13_reg)/ nr
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nr-1)
    lr = (perimeter_coincide(F_reg1,MOM_field1)/2)/(nr-1)
    stm = 1
    spm = 3
]

DEVICE cfmom_rf fmom13_rf_reg metal3(PLUS) metal3(MINUS) crt_poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field1)
    w =  perimeter_coincide(MOM_field1,fmom13_rf_reg)/ nr
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nr-1)
    lr = (perimeter_coincide(F_reg1,MOM_field1)/2)/(nr-1)
    stm = 1
    spm = 3
]

DEVICE cfmom_mx fmom13_mx_reg mom3p1(PLUS1) mom3m1(MINUS1) mom3p2(PLUS2) mom3m2(MINUS2) crt_poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom13_mx_aux> <metal3> [
     property w,s,nr,lr,stm,spm
     mf1 = count(metal3)-2
     mf = mf1/2
     nr = count(MOM_field1)/mf1
     w =  perimeter_coincide(MOM_field2,mom13_mx_aux)/ (nr*mf1)
     s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nr-1))
     lr = (perimeter_coincide(F_reg1,MOM_field1)/2)/(mf1*(nr-1))
     stm = 1
     spm = 3
]


mom14_1 = MOMDMY4 INTERACT MOM_field1

mom14_2 = mom14_1 INTERACT MOM_field2

mom14_3 = mom14_2 INTERACT MOM_field3

mom14_4 = mom14_3 INTERACT MOM_field4


mom14_idt = MOM_field4 NOT MOM_field3

mom14_5 = mom14_4 NOT INTERACT MOM_field5

mom14_reg1 = mom14_5 NOT INTERACT RFDUMMY
mom14_reg0 = mom14_reg1 NOT RFDUMMY1
mom14_reg = mom14_reg0 INTERACT mom14_idt
mom14_reg_rf0 = mom14_reg1 AND RFDUMMY1
mom14_reg_rf = mom14_reg_rf0 INTERACT mom14_idt





fmom14_reg1     = mom14_5 NOT INTERACT RFDUMMY
fmom14_reg2     = fmom14_reg1 NOT INTERACT RFDUMMY1
fmom14_reg3     = fmom14_reg2 NOT INTERACT mom14_idt
fmom14_reg4     = fmom14_reg3 INTERACT MOMDMY100
fmom14_reg5     = fmom14_reg4 NOT INTERACT MOMDMY22
fmom14_reg      = fmom14_reg5 INTERACT NIMP

fmom14_rf_reg1  = mom14_5 INTERACT RFDUMMY1
fmom14_rf_reg2  = fmom14_rf_reg1 NOT INTERACT mom14_idt
fmom14_rf_reg3  = fmom14_rf_reg2 INTERACT MOMDMY100
fmom14_rf_reg4  = fmom14_rf_reg3 NOT INTERACT MOMDMY22
fmom14_rf_reg   = fmom14_rf_reg4 INTERACT NIMP

fmom14_mx_reg1  = MOMDMY22 INTERACT mom14_5
fmom14_mx_reg2  = fmom14_mx_reg1 NOT INTERACT mom14_idt
fmom14_mx_reg3  = fmom14_mx_reg2 INTERACT MOMDMY100
fmom14_mx_reg   = fmom14_mx_reg3 INTERACT NIMP
mom14_mx_aux   = mom14_5 AND MOMDMY22


DEVICE crtmom mom14_reg metal4(PLUS) metal4(MINUS) crt_poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w  = perimeter_coincide(MOM_field2,mom14_reg)/ nh
    s  = ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 4
] 


DEVICE cfmom fmom14_reg metal4(PLUS) metal4(MINUS) crt_poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field1)
    w =  perimeter_coincide(MOM_field1,fmom14_reg)/ nr
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nr-1)
    lr = (perimeter_coincide(F_reg1,MOM_field1)/2)/(nr-1)
    stm = 1
    spm = 4
]

DEVICE cfmom_rf fmom14_rf_reg metal4(PLUS) metal4(MINUS) crt_poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field1)
    w =  perimeter_coincide(MOM_field1,fmom14_rf_reg)/ nr
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nr-1)
    lr = (perimeter_coincide(F_reg1,MOM_field1)/2)/(nr-1)
    stm = 1
    spm = 4
]

DEVICE cfmom_mx fmom14_mx_reg mom4p1(PLUS1) mom4m1(MINUS1) mom4p2(PLUS2) mom4m2(MINUS2) crt_poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom14_mx_aux> <metal4> [
     property w,s,nr,lr,stm,spm
     mf1 = count(metal4)-2
     mf = mf1/2
     nr = count(MOM_field1)/mf1
     w =  perimeter_coincide(MOM_field2,mom14_mx_aux)/ (nr*mf1)
     s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nr-1))
     lr = (perimeter_coincide(F_reg1,MOM_field1)/2)/(mf1*(nr-1))
     stm = 1
     spm = 4
]


mom15_1 = MOMDMY5 INTERACT MOM_field1

mom15_2 = mom15_1 INTERACT MOM_field2

mom15_3 = mom15_2 INTERACT MOM_field3

mom15_4 = mom15_3 INTERACT MOM_field4

mom15_5 = mom15_4 INTERACT MOM_field5


mom15_idt = MOM_field5 NOT MOM_field4


mom15_reg1 = mom15_5 NOT INTERACT RFDUMMY
mom15_reg0 = mom15_reg1 NOT RFDUMMY1
mom15_reg = mom15_reg0 INTERACT mom15_idt
mom15_reg_rf0 = mom15_reg1 AND RFDUMMY1
mom15_reg_rf = mom15_reg_rf0 INTERACT mom15_idt





fmom15_reg1     = mom15_5 NOT INTERACT RFDUMMY
fmom15_reg2     = fmom15_reg1 NOT INTERACT RFDUMMY1
fmom15_reg3     = fmom15_reg2 NOT INTERACT mom15_idt
fmom15_reg4     = fmom15_reg3 INTERACT MOMDMY100
fmom15_reg5     = fmom15_reg4 NOT INTERACT MOMDMY22
fmom15_reg      = fmom15_reg5 INTERACT NIMP

fmom15_rf_reg1  = mom15_5 INTERACT RFDUMMY1
fmom15_rf_reg2  = fmom15_rf_reg1 NOT INTERACT mom15_idt
fmom15_rf_reg3  = fmom15_rf_reg2 INTERACT MOMDMY100
fmom15_rf_reg4  = fmom15_rf_reg3 NOT INTERACT MOMDMY22
fmom15_rf_reg   = fmom15_rf_reg4 INTERACT NIMP

fmom15_mx_reg1  = MOMDMY22 INTERACT mom15_5
fmom15_mx_reg2  = fmom15_mx_reg1 NOT INTERACT mom15_idt
fmom15_mx_reg3  = fmom15_mx_reg2 INTERACT MOMDMY100
fmom15_mx_reg   = fmom15_mx_reg3 INTERACT NIMP
mom15_mx_aux   = mom15_5 AND MOMDMY22


DEVICE crtmom mom15_reg metal5(PLUS) metal5(MINUS) crt_poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w  = perimeter_coincide(MOM_field2,mom15_reg)/ nh
    s  = ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 5
] 


DEVICE cfmom fmom15_reg metal5(PLUS) metal5(MINUS) crt_poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field1)
    w =  perimeter_coincide(MOM_field1,fmom15_reg)/ nr
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nr-1)
    lr = (perimeter_coincide(F_reg1,MOM_field1)/2)/(nr-1)
    stm = 1
    spm = 5
]

DEVICE cfmom_rf fmom15_rf_reg metal5(PLUS) metal5(MINUS) crt_poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field1)
    w =  perimeter_coincide(MOM_field1,fmom15_rf_reg)/ nr
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nr-1)
    lr = (perimeter_coincide(F_reg1,MOM_field1)/2)/(nr-1)
    stm = 1
    spm = 5
]

DEVICE cfmom_mx fmom15_mx_reg mom5p1(PLUS1) mom5m1(MINUS1) mom5p2(PLUS2) mom5m2(MINUS2) crt_poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom15_mx_aux> <metal5> [
     property w,s,nr,lr,stm,spm
     mf1 = count(metal5)-2
     mf = mf1/2
     nr = count(MOM_field1)/mf1
     w =  perimeter_coincide(MOM_field2,mom15_mx_aux)/ (nr*mf1)
     s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nr-1))
     lr = (perimeter_coincide(F_reg1,MOM_field1)/2)/(mf1*(nr-1))
     stm = 1
     spm = 5
]


mom24_1 = MOMDMY4 NOT INTERACT MOM_field1   


mom24_2 = mom24_1 INTERACT MOM_field2

mom24_3 = mom24_2 INTERACT MOM_field3

mom24_4 = mom24_3 INTERACT MOM_field4


mom24_idt = MOM_field4 NOT MOM_field3

mom24_5 = mom24_4 NOT INTERACT MOM_field5

mom24_reg1 = mom24_5 NOT INTERACT RFDUMMY
mom24_reg0 = mom24_reg1 NOT RFDUMMY1
mom24_reg = mom24_reg0 INTERACT mom24_idt
mom24_reg_rf0 = mom24_reg1 AND RFDUMMY1
mom24_reg_rf = mom24_reg_rf0 INTERACT mom24_idt





fmom24_reg1     = mom24_5 NOT INTERACT RFDUMMY
fmom24_reg2     = fmom24_reg1 NOT INTERACT RFDUMMY1
fmom24_reg3     = fmom24_reg2 NOT INTERACT mom24_idt
fmom24_reg4     = fmom24_reg3 INTERACT MOMDMY100
fmom24_reg5     = fmom24_reg4 NOT INTERACT MOMDMY22
fmom24_reg      = fmom24_reg5 INTERACT NIMP

fmom24_rf_reg1  = mom24_5 INTERACT RFDUMMY1
fmom24_rf_reg2  = fmom24_rf_reg1 NOT INTERACT mom24_idt
fmom24_rf_reg3  = fmom24_rf_reg2 INTERACT MOMDMY100
fmom24_rf_reg4  = fmom24_rf_reg3 NOT INTERACT MOMDMY22
fmom24_rf_reg   = fmom24_rf_reg4 INTERACT NIMP

fmom24_mx_reg1  = MOMDMY22 INTERACT mom24_5
fmom24_mx_reg2  = fmom24_mx_reg1 NOT INTERACT mom24_idt
fmom24_mx_reg3  = fmom24_mx_reg2 INTERACT MOMDMY100
fmom24_mx_reg   = fmom24_mx_reg3 INTERACT NIMP
mom24_mx_aux   = mom24_5 AND MOMDMY22


DEVICE crtmom mom24_reg metal4(PLUS) metal4(MINUS) crt_poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w  = perimeter_coincide(MOM_field2,mom24_reg)/ nh
    s  = ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 4
] 


DEVICE cfmom fmom24_reg metal4(PLUS) metal4(MINUS) crt_poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field3)
    w =  perimeter_coincide(MOM_field3,fmom24_reg)/ nr
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nr-1)
    lr = (perimeter_coincide(F_reg2,MOM_field2)/2)/(nr-1)
    stm = 2
    spm = 4
]

DEVICE cfmom_rf fmom24_rf_reg metal4(PLUS) metal4(MINUS) crt_poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field3)
    w =  perimeter_coincide(MOM_field3,fmom24_rf_reg)/ nr
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nr-1)
    lr = (perimeter_coincide(F_reg2,MOM_field2)/2)/(nr-1)
    stm = 2
    spm = 4
]

DEVICE cfmom_mx fmom24_mx_reg mom4p1(PLUS1) mom4m1(MINUS1) mom4p2(PLUS2) mom4m2(MINUS2) crt_poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> <mom24_mx_aux> <metal4> [
     property w,s,nr,lr,stm,spm
     mf1 = count(metal4)-2
     mf = mf1/2
     nr = count(MOM_field3)/mf1
     w =  perimeter_coincide(MOM_field2,mom24_mx_aux)/ (nr*mf1)
     s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(mf1*(nr-1))
     lr = (perimeter_coincide(F_reg2,MOM_field3)/2)/(mf1*(nr-1))
     stm = 2
     spm = 4
]

mom25_1 = MOMDMY5 NOT INTERACT MOM_field1   


mom25_2 = mom25_1 INTERACT MOM_field2

mom25_3 = mom25_2 INTERACT MOM_field3

mom25_4 = mom25_3 INTERACT MOM_field4

mom25_5 = mom25_4 INTERACT MOM_field5


mom25_idt = MOM_field5 NOT MOM_field4


mom25_reg1 = mom25_5 NOT INTERACT RFDUMMY
mom25_reg0 = mom25_reg1 NOT RFDUMMY1
mom25_reg = mom25_reg0 INTERACT mom25_idt
mom25_reg_rf0 = mom25_reg1 AND RFDUMMY1
mom25_reg_rf = mom25_reg_rf0 INTERACT mom25_idt





fmom25_reg1     = mom25_5 NOT INTERACT RFDUMMY
fmom25_reg2     = fmom25_reg1 NOT INTERACT RFDUMMY1
fmom25_reg3     = fmom25_reg2 NOT INTERACT mom25_idt
fmom25_reg4     = fmom25_reg3 INTERACT MOMDMY100
fmom25_reg5     = fmom25_reg4 NOT INTERACT MOMDMY22
fmom25_reg      = fmom25_reg5 INTERACT NIMP

fmom25_rf_reg1  = mom25_5 INTERACT RFDUMMY1
fmom25_rf_reg2  = fmom25_rf_reg1 NOT INTERACT mom25_idt
fmom25_rf_reg3  = fmom25_rf_reg2 INTERACT MOMDMY100
fmom25_rf_reg4  = fmom25_rf_reg3 NOT INTERACT MOMDMY22
fmom25_rf_reg   = fmom25_rf_reg4 INTERACT NIMP

fmom25_mx_reg1  = MOMDMY22 INTERACT mom25_5
fmom25_mx_reg2  = fmom25_mx_reg1 NOT INTERACT mom25_idt
fmom25_mx_reg3  = fmom25_mx_reg2 INTERACT MOMDMY100
fmom25_mx_reg   = fmom25_mx_reg3 INTERACT NIMP
mom25_mx_aux   = mom25_5 AND MOMDMY22


DEVICE crtmom mom25_reg metal5(PLUS) metal5(MINUS) crt_poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w  = perimeter_coincide(MOM_field2,mom25_reg)/ nh
    s  = ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 5
] 


DEVICE cfmom fmom25_reg metal5(PLUS) metal5(MINUS) crt_poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field3)
    w =  perimeter_coincide(MOM_field3,fmom25_reg)/ nr
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nr-1)
    lr = (perimeter_coincide(F_reg2,MOM_field2)/2)/(nr-1)
    stm = 2
    spm = 5
]

DEVICE cfmom_rf fmom25_rf_reg metal5(PLUS) metal5(MINUS) crt_poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field3)
    w =  perimeter_coincide(MOM_field3,fmom25_rf_reg)/ nr
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nr-1)
    lr = (perimeter_coincide(F_reg2,MOM_field2)/2)/(nr-1)
    stm = 2
    spm = 5
]

DEVICE cfmom_mx fmom25_mx_reg mom5p1(PLUS1) mom5m1(MINUS1) mom5p2(PLUS2) mom5m2(MINUS2) crt_poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> <mom25_mx_aux> <metal5> [
     property w,s,nr,lr,stm,spm
     mf1 = count(metal5)-2
     mf = mf1/2
     nr = count(MOM_field3)/mf1
     w =  perimeter_coincide(MOM_field2,mom25_mx_aux)/ (nr*mf1)
     s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(mf1*(nr-1))
     lr = (perimeter_coincide(F_reg2,MOM_field3)/2)/(mf1*(nr-1))
     stm = 2
     spm = 5
]


mom35_1 = MOMDMY5 NOT INTERACT MOM_field1   
mom35_2 = mom35_1 NOT INTERACT MOM_field2   


mom35_3 = mom35_2 INTERACT MOM_field3

mom35_4 = mom35_3 INTERACT MOM_field4

mom35_5 = mom35_4 INTERACT MOM_field5


mom35_idt = MOM_field5 NOT MOM_field4


mom35_reg1 = mom35_5 NOT INTERACT RFDUMMY
mom35_reg0 = mom35_reg1 NOT RFDUMMY1
mom35_reg = mom35_reg0 INTERACT mom35_idt
mom35_reg_rf0 = mom35_reg1 AND RFDUMMY1
mom35_reg_rf = mom35_reg_rf0 INTERACT mom35_idt





fmom35_reg1     = mom35_5 NOT INTERACT RFDUMMY
fmom35_reg2     = fmom35_reg1 NOT INTERACT RFDUMMY1
fmom35_reg3     = fmom35_reg2 NOT INTERACT mom35_idt
fmom35_reg4     = fmom35_reg3 INTERACT MOMDMY100
fmom35_reg5     = fmom35_reg4 NOT INTERACT MOMDMY22
fmom35_reg      = fmom35_reg5 INTERACT NIMP

fmom35_rf_reg1  = mom35_5 INTERACT RFDUMMY1
fmom35_rf_reg2  = fmom35_rf_reg1 NOT INTERACT mom35_idt
fmom35_rf_reg3  = fmom35_rf_reg2 INTERACT MOMDMY100
fmom35_rf_reg4  = fmom35_rf_reg3 NOT INTERACT MOMDMY22
fmom35_rf_reg   = fmom35_rf_reg4 INTERACT NIMP

fmom35_mx_reg1  = MOMDMY22 INTERACT mom35_5
fmom35_mx_reg2  = fmom35_mx_reg1 NOT INTERACT mom35_idt
fmom35_mx_reg3  = fmom35_mx_reg2 INTERACT MOMDMY100
fmom35_mx_reg   = fmom35_mx_reg3 INTERACT NIMP
mom35_mx_aux   = mom35_5 AND MOMDMY22


DEVICE crtmom mom35_reg metal5(PLUS) metal5(MINUS) crt_poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field4)
    w  = perimeter_coincide(MOM_field4,mom35_reg)/ nh
    s  = ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nv-1)
    stm = 3
    spm = 5
] 


DEVICE cfmom fmom35_reg metal5(PLUS) metal5(MINUS) crt_poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field3)
    w =  perimeter_coincide(MOM_field3,fmom35_reg)/ nr
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nr-1)
    lr = (perimeter_coincide(F_reg3,MOM_field3)/2)/(nr-1)
    stm = 3
    spm = 5
]

DEVICE cfmom_rf fmom35_rf_reg metal5(PLUS) metal5(MINUS) crt_poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field3)
    w =  perimeter_coincide(MOM_field3,fmom35_rf_reg)/ nr
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nr-1)
    lr = (perimeter_coincide(F_reg3,MOM_field3)/2)/(nr-1)
    stm = 3
    spm = 5
]

DEVICE cfmom_mx fmom35_mx_reg mom5p1(PLUS1) mom5m1(MINUS1) mom5p2(PLUS2) mom5m2(MINUS2) crt_poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> <mom35_mx_aux> <metal5> [
     property w,s,nr,lr,stm,spm
     mf1 = count(metal5)-2
     mf = mf1/2
     nr = count(MOM_field3)/mf1
     w =  perimeter_coincide(MOM_field4,mom35_mx_aux)/ (nr*mf1)
     s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(mf1*(nr-1))
     lr = (perimeter_coincide(F_reg3,MOM_field3)/2)/(mf1*(nr-1))
     stm = 3
     spm = 5
]


TRACE PROPERTY crtmom nv nv 0 
TRACE PROPERTY crtmom nh nh 0 
TRACE PROPERTY crtmom s  s 0 
TRACE PROPERTY crtmom w  w 0
TRACE PROPERTY crtmom stm stm 0
TRACE PROPERTY crtmom spm spm 0


TRACE PROPERTY cfmom nr nr   0 
TRACE PROPERTY cfmom s  s    0
TRACE PROPERTY cfmom w  w    0
TRACE PROPERTY cfmom lr  lr  0
TRACE PROPERTY cfmom stm stm 0
TRACE PROPERTY cfmom spm spm 0

TRACE PROPERTY cfmom_rf nr nr   0 
TRACE PROPERTY cfmom_rf s  s    0
TRACE PROPERTY cfmom_rf w  w    0
TRACE PROPERTY cfmom_rf lr  lr  0
TRACE PROPERTY cfmom_rf stm stm 0
TRACE PROPERTY cfmom_rf spm spm 0

TRACE PROPERTY cfmom_mx nr nr   0 
TRACE PROPERTY cfmom_mx s  s    0
TRACE PROPERTY cfmom_mx w  w    0
TRACE PROPERTY cfmom_mx lr  lr  0
TRACE PROPERTY cfmom_mx stm stm 0
TRACE PROPERTY cfmom_mx spm spm 0

#IFDEF extract_dnwdio
DEVICE D(dnwpsub) dnwdio psub_term DNW [
    PROPERTY A
    A = area(DNW)
]
    TRACE PROPERTY D(dnwpsub) A A 0
#ENDIF

sbd_w = EXT schottky_p schottky_n < 0.49 OPPOSITE REGION

//
DEVICE lcesd1_rf lcesd1_rl lcesdp(PLUS) lcesdm(MINUS)

//
DEVICE lcesd2_rf lcesd2_rl lcesdp(PLUS) lcesdm(MINUS)

#IFNDEF CAP_2P0
DEVICE mimcap_1p0_sin capm5_1p0 ctm(TOP) metal5(BOT) netlist element "X"[
  property WT,LT
  a_cap = area(capm5_1p0)
  p_cap = perimeter(capm5_1p0)
  p_2_cap = p_cap * p_cap
  ac4 = a_cap * 16
  kkk = p_2_cap-ac4
  if(kkk<0) {
    kkk=0
  }
  sq = sqrt(kkk)
  LT = (p_cap+sq)/4
  WT = (p_cap-sq)/4
]
DEVICE mimcap_1p0_sin capm5_1p0_ud ctm(TOP) metal5(BOT) netlist element "X"[
  property WT,LT
  a_cap = area(capm5_1p0_ud)
  p_cap = perimeter(capm5_1p0_ud)
  p_2_cap = p_cap * p_cap
  ac4 = a_cap * 16
  kkk = p_2_cap-ac4
  if(kkk<0) {
    kkk=0
  }
  sq = sqrt(kkk)
  LT = (p_cap+sq)/4
  WT = (p_cap-sq)/4
]
TRACE PROPERTY mimcap_1p0_sin LT LT 0
TRACE PROPERTY mimcap_1p0_sin WT WT 0  
#ENDIF

#IFNDEF CAP_2P0
DEVICE mimcap_1p0_sin_3t capm5_1p0_3t ctm(PLUS) metal5(MINUS) psub(BULK) netlist element "X"[
  property LT,WT,LAY
  PJ = perimeter(capm5_1p0_3t)
  A = area(capm5_1p0_3t)
  det = PJ * PJ - 16 * A
  IF (det < 0) 
  {
  LT = PJ / 4 
  WT = A / LT
  }
  else { 
  root = sqrt(det)
  LT = (PJ + root)/4
  WT = A/ LT
  }
  LAY = 6
]

TRACE PROPERTY mimcap_1p0_sin_3t LT LT 0
TRACE PROPERTY mimcap_1p0_sin_3t WT WT 0
TRACE PROPERTY mimcap_1p0_sin_3t LAY LAY 0
#ENDIF

#IFDEF CAP_2P0
DEVICE mimcap_2p0_shield capm5_rf3t_shield_m4_2p0 ctm(PLUS) metal5(MINUS) metal4(BULK) <metal6>[
  property LT,WT,LAY
  PJ=perimeter(capm5_rf3t_shield_m4_2p0)
  A=area(capm5_rf3t_shield_m4_2p0)
  L1 = perimeter_coincide(capm5_rf3t_shield_m4_2p0,metal6)
  LT  = PJ-L1
  WT = A/LT
  LAY = 6
]
DEVICE mimcap_2p0_shield capm5_rf3t_shield_m4_2p0_ud ctm(PLUS) metal5(MINUS) metal4(BULK) <metal6>[
  property LT,WT,LAY
  PJ=perimeter(capm5_rf3t_shield_m4_2p0_ud)
  A=area(capm5_rf3t_shield_m4_2p0_ud)
  L1 = perimeter_coincide(capm5_rf3t_shield_m4_2p0_ud,metal6)
  LT  = PJ-L1
  WT = A/LT
  LAY = 6
]
TRACE PROPERTY mimcap_2p0_shield LT LT 0
TRACE PROPERTY mimcap_2p0_shield WT WT 0
TRACE PROPERTY mimcap_2p0_shield LAY LAY  0
#ENDIF

#IFDEF CAP_2P0
DEVICE mimcap_2p0_sin capm5_2p0 ctm(TOP) metal5(BOT) netlist element "X"[
  property WT,LT
  a_cap = area(capm5_2p0)
  p_cap = perimeter(capm5_2p0)
  p_2_cap = p_cap * p_cap
  ac4 = a_cap * 16
  kkk = p_2_cap-ac4
  if(kkk<0) {
    kkk=0
  }
  sq = sqrt(kkk)
  LT = (p_cap+sq)/4
  WT = (p_cap-sq)/4
]
DEVICE mimcap_2p0_sin capm5_2p0_ud ctm(TOP) metal5(BOT) netlist element "X"[
  property WT,LT
  a_cap = area(capm5_2p0_ud)
  p_cap = perimeter(capm5_2p0_ud)
  p_2_cap = p_cap * p_cap
  ac4 = a_cap * 16
  kkk = p_2_cap-ac4
  if(kkk<0) {
    kkk=0
  }
  sq = sqrt(kkk)
  LT = (p_cap+sq)/4
  WT = (p_cap-sq)/4
]
TRACE PROPERTY mimcap_2p0_sin LT LT 0
TRACE PROPERTY mimcap_2p0_sin WT WT 0  
#ENDIF

#IFDEF CAP_2P0
DEVICE mimcap_2p0_sin_3t capm5_2p0_3t ctm(PLUS) metal5(MINUS) psub(BULK) netlist element "X"[
  property LT,WT,LAY
  PJ = perimeter(capm5_2p0_3t)
  A = area(capm5_2p0_3t)
  det = PJ * PJ - 16 * A
  IF (det < 0) 
  {
  LT = PJ / 4 
  WT = A / LT
  }
  else { 
  root = sqrt(det)
  LT = (PJ + root)/4
  WT = A/ LT
  }
  LAY = 6
]

TRACE PROPERTY mimcap_2p0_sin_3t LT LT 0
TRACE PROPERTY mimcap_2p0_sin_3t WT WT 0
TRACE PROPERTY mimcap_2p0_sin_3t LAY LAY 0
#ENDIF 

#IFDEF CAP_2P0
DEVICE mimcap_2p0_wos capm5_rf3t_2p0 ctm(PLUS) metal5(MINUS) dnw(BULK) <metal6> [
  property LT,WT,LAY
  PJ=perimeter(capm5_rf3t_2p0)
  A=area(capm5_rf3t_2p0)
  L1 = perimeter_coincide(capm5_rf3t_2p0,metal6)
  LT  = PJ-L1
  WT = A/LT
  LAY = 6
]
TRACE PROPERTY mimcap_2p0_wos LT LT  0
TRACE PROPERTY mimcap_2p0_wos WT WT 0
TRACE PROPERTY mimcap_2p0_wos LAY LAY  0
#ENDIF

DEVICE moscap_rf varnwmc_rf_dnw poly(PLUS) tndiff(MINUS) psub(BULK) <vargt3_rf> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(vargt3_rf)/gr
  wr = (perimeter_coincide(vargt3_rf,tndiff)/2)/(br*gr)
  lr = (area(vargt3_rf)/wr)/(br*gr)
]
TRACE PROPERTY moscap_rf lr lr 0
TRACE PROPERTY moscap_rf wr wr 0
TRACE PROPERTY moscap_rf br br 0
TRACE PROPERTY moscap_rf gr gr 0

DEVICE moscap_rf33 varnwmi_rf_dnw poly(PLUS) tndiff(MINUS) psub(BULK) <bvargt3_rf> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(bvargt3_rf)/gr
  wr = (perimeter_coincide(bvargt3_rf,tndiff)/2)/(br*gr)
  lr = (area(bvargt3_rf)/wr)/(br*gr)
]
TRACE PROPERTY moscap_rf33 lr lr 0
TRACE PROPERTY moscap_rf33 wr wr 0
TRACE PROPERTY moscap_rf33 br br 0
TRACE PROPERTY moscap_rf33 gr gr 0

DEVICE moscap_rf33_nw varnwmi_rf_nw poly(PLUS) tndiff(MINUS) psub(BULK) <bvargt3_rf> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(bvargt3_rf)/gr
  wr = (perimeter_coincide(bvargt3_rf,tndiff)/2)/(br*gr)
  lr = (area(bvargt3_rf)/wr)/(br*gr)
]
TRACE PROPERTY moscap_rf33_nw lr lr 0
TRACE PROPERTY moscap_rf33_nw wr wr 0
TRACE PROPERTY moscap_rf33_nw br br 0
TRACE PROPERTY moscap_rf33_nw gr gr 0

DEVICE moscap_rf_nw varnwmc_rf_nw poly(PLUS) tndiff(MINUS) psub(BULK) <vargt3_rf> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(vargt3_rf)/gr
  wr = (perimeter_coincide(vargt3_rf,tndiff)/2)/(br*gr)
  lr = (area(vargt3_rf)/wr)/(br*gr)
]
TRACE PROPERTY moscap_rf_nw lr lr 0
TRACE PROPERTY moscap_rf_nw wr wr 0
TRACE PROPERTY moscap_rf_nw br br 0
TRACE PROPERTY moscap_rf_nw gr gr 0

DEVICE nmos_rf nrgate_4t_nthin d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <nrgate_rf4t> [
  property WR,LR,NR
  NR = count(nrgate_rf4t)
  WR = ((perimeter_coincide(nrgate_rf4t,d_tndiff) + perimeter_coincide(nrgate_rf4t,s_tndiff))/2)/NR
  LR = (area(nrgate_rf4t)/WR)/NR
]
TRACE PROPERTY nmos_rf LR LR 0
TRACE PROPERTY nmos_rf WR WR 0
TRACE PROPERTY nmos_rf NR NR 0

DEVICE nmos_rf33 bnrgate_4t_nthin d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <bnrgate_rf4t> [
  property WR,LR,NR
  NR = count(bnrgate_rf4t)
  WR = ((perimeter_coincide(bnrgate_rf4t,d_tndiff) + perimeter_coincide(bnrgate_rf4t,s_tndiff))/2)/NR
  LR = (area(bnrgate_rf4t)/WR)/NR
]
TRACE PROPERTY nmos_rf33 LR LR 0
TRACE PROPERTY nmos_rf33 WR WR 0
TRACE PROPERTY nmos_rf33 NR NR 0

DEVICE nmos_rf33_6t bnrgate_6t_nthin d_tndiff(D) poly_rf(G) s_tndiff(S) rw(B) DNW(NG) RFDUMMY6T(PG) <bnrgate_rf4t> netlist model nmos_rf33_6t [
   property lr,wr,nr
   nr = count(bnrgate_rf4t)
   wr = ((perimeter_coincide(bnrgate_rf4t,s_tndiff)+ perimeter_coincide(bnrgate_rf4t,d_tndiff))/2)/nr
   lr = (area(bnrgate_rf4t)/wr)/nr
]
TRACE PROPERTY nmos_rf33_6t wr wr 0 
TRACE PROPERTY nmos_rf33_6t lr lr 0
TRACE PROPERTY nmos_rf33_6t nr nr 0

DEVICE nmos_rf_6t nrgate_6t_nthin d_tndiff(D) poly_rf(G) s_tndiff(S) rw(B) DNW(NG) RFDUMMY6T(PG) <nrgate_rf4t> netlist model nmos_rf_6t [
   property lr,wr,nr
   nr = count(nrgate_rf4t)
   wr = ((perimeter_coincide(nrgate_rf4t,s_tndiff)+ perimeter_coincide(nrgate_rf4t,d_tndiff))/2)/nr
   lr = (area(nrgate_rf4t)/wr)/nr
]
TRACE PROPERTY nmos_rf_6t wr wr 0 
TRACE PROPERTY nmos_rf_6t lr lr 0
TRACE PROPERTY nmos_rf_6t nr nr 0

DEVICE nmoscap nthin_var poly(PLUS) tndiff(MINUS) <vargt> [
  property lr,wr,mr
  mr = count(vargt)
  lr = (perimeter_coincide(vargt,nthin_var)/mr)/2
  A  = area(vargt)/mr
  wr = A/lr
]
TRACE PROPERTY nmoscap lr lr 0
TRACE PROPERTY nmoscap wr wr 0
TRACE PROPERTY nmoscap mr mr 0

DEVICE nmoscap_33 nthin_bvar poly(PLUS) tndiff(MINUS) <bvargt> [
  property lr,wr,mr
  mr = count(bvargt)
  lr = (perimeter_coincide(bvargt,nthin_bvar)/mr)/2
  A  = area(bvargt)/mr
  wr = A/lr
]
TRACE PROPERTY nmoscap_33 lr lr 0
TRACE PROPERTY nmoscap_33 wr wr 0
TRACE PROPERTY nmoscap_33 mr mr 0

DEVICE pmos_rf pgate_4t_pthin d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rf4t> [
  property WR,LR,NR
  NR = count(pgate_rf4t)
  WR = ((perimeter_coincide(pgate_rf4t,d_tpdiff) + perimeter_coincide(pgate_rf4t,s_tpdiff))/2)/NR
  LR = (area(pgate_rf4t)/WR)/NR
]
TRACE PROPERTY pmos_rf LR LR 0
TRACE PROPERTY pmos_rf WR WR 0
TRACE PROPERTY pmos_rf NR NR 0

DEVICE pmos_rf33 bpgate_4t_pthin d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <bpgate_rf4t> [
  property WR,LR,NR
  NR = count(bpgate_rf4t)
  WR = ((perimeter_coincide(bpgate_rf4t,d_tpdiff) + perimeter_coincide(bpgate_rf4t,s_tpdiff))/2)/NR
  LR = (area(bpgate_rf4t)/WR)/NR
]
TRACE PROPERTY pmos_rf33 LR LR 0
TRACE PROPERTY pmos_rf33 WR WR 0
TRACE PROPERTY pmos_rf33 NR NR 0

DEVICE pmos_rf33_5t bpgate_5t_pthin d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) RFDUMMY5T(PG) <bpgate_rf4t> netlist model pmos_rf33_5t [
   property lr,wr,nr
   nr = count(bpgate_rf4t)
   wr = ((perimeter_coincide(bpgate_rf4t,s_tpdiff)+ perimeter_coincide(bpgate_rf4t,d_tpdiff))/2)/nr
   lr = (area(bpgate_rf4t)/wr)/nr
]
TRACE PROPERTY pmos_rf33_5t wr wr 0 
TRACE PROPERTY pmos_rf33_5t lr lr 0
TRACE PROPERTY pmos_rf33_5t nr nr 0

DEVICE pmos_rf33_nw bpgate_4t_pthin_nw d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <bpgate_rf4t_nw> [
  property WR,LR,NR
  NR = count(bpgate_rf4t_nw)
  WR = ((perimeter_coincide(bpgate_rf4t_nw,d_tpdiff) + perimeter_coincide(bpgate_rf4t_nw,s_tpdiff))/2)/NR
  LR = (area(bpgate_rf4t_nw)/WR)/NR
]
TRACE PROPERTY pmos_rf33_nw LR LR 0
TRACE PROPERTY pmos_rf33_nw WR WR 0
TRACE PROPERTY pmos_rf33_nw NR NR 0

DEVICE pmos_rf33_nw_5t bpgate_5t_pthin_nw d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) RFDUMMY5T(PG) <bpgate_rf4t_nw> netlist model pmos_rf33_nw_5t [
   property lr,wr,nr
   nr = count(bpgate_rf4t_nw)
   wr = ((perimeter_coincide(bpgate_rf4t_nw,s_tpdiff)+ perimeter_coincide(bpgate_rf4t_nw,d_tpdiff))/2)/nr
   lr = (area(bpgate_rf4t_nw)/wr)/nr
]
TRACE PROPERTY pmos_rf33_nw_5t wr wr 0 
TRACE PROPERTY pmos_rf33_nw_5t lr lr 0
TRACE PROPERTY pmos_rf33_nw_5t nr nr 0

DEVICE pmos_rf_5t pgate_5t_pthin d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) RFDUMMY5T(PG) <pgate_rf4t> netlist model pmos_rf_5t [
   property lr,wr,nr
   nr = count(pgate_rf4t)
   wr = ((perimeter_coincide(pgate_rf4t,s_tpdiff)+ perimeter_coincide(pgate_rf4t,d_tpdiff))/2)/nr
   lr = (area(pgate_rf4t)/wr)/nr
]
TRACE PROPERTY pmos_rf_5t wr wr 0 
TRACE PROPERTY pmos_rf_5t lr lr 0
TRACE PROPERTY pmos_rf_5t nr nr 0

DEVICE pmos_rf_nw pgate_4t_pthin_nw d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rf4t_nw> [
  property WR,LR,NR
  NR = count(pgate_rf4t_nw)
  WR = ((perimeter_coincide(pgate_rf4t_nw,d_tpdiff) + perimeter_coincide(pgate_rf4t_nw,s_tpdiff))/2)/NR
  LR = (area(pgate_rf4t_nw)/WR)/NR
]
TRACE PROPERTY pmos_rf_nw LR LR 0
TRACE PROPERTY pmos_rf_nw WR WR 0
TRACE PROPERTY pmos_rf_nw NR NR 0

DEVICE pmos_rf_nw_5t pgate_5t_pthin_nw d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) RFDUMMY5T(PG) <pgate_rf4t_nw> netlist model pmos_rf_nw_5t [
   property lr,wr,nr
   nr = count(pgate_rf4t_nw)
   wr = ((perimeter_coincide(pgate_rf4t_nw,s_tpdiff)+ perimeter_coincide(pgate_rf4t_nw,d_tpdiff))/2)/nr
   lr = (area(pgate_rf4t_nw)/wr)/nr
]
TRACE PROPERTY pmos_rf_nw_5t wr wr 0 
TRACE PROPERTY pmos_rf_nw_5t lr lr 0
TRACE PROPERTY pmos_rf_nw_5t nr nr 0

#IFDEF extract_dnwdio
DEVICE D(pwdnw) rwdio psub DNW
    TRACE PROPERTY D(pwdnw) A A 0
#ENDIF

DEVICE rnod_m l_rnodl_3t tndiff(PLUS) tndiff(MINUS) psub(B) (PLUS MINUS) [
	property wr,lr
	wr = perimeter_coincide(l_rnodl_3t,tndiff)/2
	lr = area(l_rnodl_3t)/wr
]

TRACE PROPERTY rnod_m wr wr  0
TRACE PROPERTY rnod_m lr lr  0

LVS REDUCE rnod_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)

]
LVS REDUCE rnod_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]

DEVICE rnodrpo_m t_nrdop tndiff(PLUS) tndiff(MINUS) psub(B) (PLUS MINUS) [
	property wr,lr
	wr = perimeter_coincide(t_nrdop,tndiff)/2
	lr = area(t_nrdop)/wr
]

TRACE PROPERTY rnodrpo_m wr wr  0
TRACE PROPERTY rnodrpo_m lr lr  0

LVS REDUCE rnodrpo_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)

]
LVS REDUCE rnodrpo_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]

DEVICE rnodw_m s_rnods_3t tndiff(PLUS) tndiff(MINUS) psub(B) (PLUS MINUS) [
	property wr,lr
	wr = perimeter_coincide(s_rnods_3t,tndiff)/2
	lr = area(s_rnods_3t)/wr
]

TRACE PROPERTY rnodw_m wr wr  0
TRACE PROPERTY rnodw_m lr lr  0

LVS REDUCE rnodw_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)

]
LVS REDUCE rnodw_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]

DEVICE rnpo1_dis rnpolyl_r_3t poly(PLUS) poly(MINUS) poly_term(B) (PLUS MINUS) [
  property lr,wr
  wr = perimeter_coincide(rnpolyl_r_3t,poly)/2
  lr = area(rnpolyl_r_3t)/wr
]

TRACE PROPERTY rnpo1_dis wr wr  0
TRACE PROPERTY rnpo1_dis lr lr  0

LVS REDUCE rnpo1_dis PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rnpo1_dis SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]

DEVICE rnpo1rpo_dis nrpop_3t poly(PLUS) poly(MINUS) poly_term(B) (PLUS MINUS) [
  property lr,wr
  wr = perimeter_coincide(nrpop_3t,poly)/2
  lr = area(nrpop_3t)/wr
]

TRACE PROPERTY rnpo1rpo_dis wr wr  0
TRACE PROPERTY rnpo1rpo_dis lr lr  0

LVS REDUCE rnpo1rpo_dis PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rnpo1rpo_dis SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]

DEVICE rnpo1w_dis rnpolys_r_3t poly(PLUS) poly(MINUS) poly_term(B) (PLUS MINUS) [
  property lr,wr
  wr = perimeter_coincide(rnpolys_r_3t,poly)/2
  lr = area(rnpolys_r_3t)/wr
]

TRACE PROPERTY rnpo1w_dis wr wr  0
TRACE PROPERTY rnpo1w_dis lr lr  0

LVS REDUCE rnpo1w_dis PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rnpo1w_dis SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]

DEVICE rnwod_m nwoda nxwell(PLUS) nxwell(MINUS) psub(B) (PLUS MINUS) [
	property wr,lr
	wr = perimeter_coincide(nwoda,nxwell)/2
	lr = area(nwoda)/wr
]

TRACE PROPERTY rnwod_m wr wr  0
TRACE PROPERTY rnwod_m lr lr  0

LVS REDUCE rnwod_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)

]
LVS REDUCE rnwod_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]

DEVICE rnwsti_m nwstia nxwell(PLUS) nxwell(MINUS) psub(B) (PLUS MINUS) [
	property wr,lr
	wr = perimeter_coincide(nwstia,nxwell)/2
	lr = area(nwstia)/wr
]

TRACE PROPERTY rnwsti_m wr wr  0
TRACE PROPERTY rnwsti_m lr lr  0

LVS REDUCE rnwsti_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)

]
LVS REDUCE rnwsti_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]

DEVICE rpod_m l_rpodl_3t tpdiff(PLUS) tpdiff(MINUS) nxwell(B) (PLUS MINUS) [
	property wr,lr
	wr = perimeter_coincide(l_rpodl_3t,tpdiff)/2
	lr = area(l_rpodl_3t)/wr
]

TRACE PROPERTY rpod_m wr wr  0
TRACE PROPERTY rpod_m lr lr  0

LVS REDUCE rpod_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)

]
LVS REDUCE rpod_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]

DEVICE rpodrpo_m t_prdop tpdiff(PLUS) tpdiff(MINUS) nxwell(B) (PLUS MINUS) [
	property wr,lr
	wr = perimeter_coincide(t_prdop,tpdiff)/2
	lr = area(t_prdop)/wr
]

TRACE PROPERTY rpodrpo_m wr wr  0
TRACE PROPERTY rpodrpo_m lr lr  0

LVS REDUCE rpodrpo_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)

]
LVS REDUCE rpodrpo_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]

DEVICE rpodw_m s_rpods_3t tpdiff(PLUS) tpdiff(MINUS) nxwell(B) (PLUS MINUS) [
	property wr,lr
	wr = perimeter_coincide(s_rpods_3t,tpdiff)/2
	lr = area(s_rpods_3t)/wr
]

TRACE PROPERTY rpodw_m wr wr  0
TRACE PROPERTY rpodw_m lr lr  0

LVS REDUCE rpodw_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)

]
LVS REDUCE rpodw_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]

DEVICE rppo1_dis rppolyl_r_3t poly(PLUS) poly(MINUS) poly_term(B) (PLUS MINUS) [
  property lr,wr
  wr = perimeter_coincide(rppolyl_r_3t,poly)/2
  lr = area(rppolyl_r_3t)/wr
]

TRACE PROPERTY rppo1_dis wr wr  0
TRACE PROPERTY rppo1_dis lr lr  0

LVS REDUCE rppo1_dis PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rppo1_dis SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]

DEVICE rppo1rpo_dis prpop_3t poly(PLUS) poly(MINUS) poly_term(B) (PLUS MINUS) [
  property lr,wr
  wr = perimeter_coincide(prpop_3t,poly)/2
  lr = area(prpop_3t)/wr
]

TRACE PROPERTY rppo1rpo_dis wr wr  0
TRACE PROPERTY rppo1rpo_dis lr lr  0

LVS REDUCE rppo1rpo_dis PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rppo1rpo_dis SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]

DEVICE rppo1w_dis rppolys_r_3t poly(PLUS) poly(MINUS) poly_term(B) (PLUS MINUS) [
  property lr,wr
  wr = perimeter_coincide(rppolys_r_3t,poly)/2
  lr = area(rppolys_r_3t)/wr
]

TRACE PROPERTY rppo1w_dis wr wr  0
TRACE PROPERTY rppo1w_dis lr lr  0

LVS REDUCE rppo1w_dis PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rppo1w_dis SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]

DEVICE rppolyhri_dis lrpop_3t poly(PLUS) poly(MINUS) poly_term(B) (PLUS MINUS) [
  property lr,wr
  wr = perimeter_coincide(lrpop_3t,poly)/2
  lr = area(lrpop_3t)/wr
]

TRACE PROPERTY rppolyhri_dis wr wr  0
TRACE PROPERTY rppolyhri_dis lr lr  0

LVS REDUCE rppolyhri_dis PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rppolyhri_dis SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]

DEVICE rppolyhri_rf lrpop_rf ppoly(PLUS) ppoly(MINUS) DNW(BULK) (PLUS MINUS) [
  property W,L
  W=(perimeter_coincide(lrpop_rf, ppoly ) + perimeter_inside(lrpop_rf, ppoly)) / 2
  L=area(lrpop_rf) / W
]
TRACE PROPERTY rppolyhri_rf  W W 0
TRACE PROPERTY rppolyhri_rf  L L 0

DEVICE rppolyl_rf rppolyl_rf_3t poly(PLUS) poly(MINUS) DNW(BULK) (PLUS MINUS) [
  property W,L
  W=(perimeter_coincide(rppolyl_rf_3t,poly )) / 2
  L=area(rppolyl_rf_3t) / W
]
TRACE PROPERTY rppolyl_rf W W 0
TRACE PROPERTY rppolyl_rf L L 0

DEVICE rppolys_rf rppolys_rf_3t poly(PLUS) poly(MINUS) DNW(BULK) (PLUS MINUS) [
  property W,L
  W=(perimeter_coincide(rppolys_rf_3t,poly )) / 2
  L=area(rppolys_rf_3t) / W
]
TRACE PROPERTY rppolys_rf W W 0
TRACE PROPERTY rppolys_rf L L 0

DEVICE rppolywo_rf prpop_rf3t poly(PLUS)  poly(MINUS) DNW(BULK) (PLUS MINUS) [
  property W,L
  W=(perimeter_coincide(prpop_rf3t, poly ) + perimeter_inside(prpop_rf3t, poly)) / 2
  L=area(prpop_rf3t) / W
]
TRACE PROPERTY rppolywo_rf W W 0
TRACE PROPERTY rppolywo_rf L L 0

DEVICE sbd_rf sbd_rf schottky_p(PLUS) schottky_n(MINUS) psub(BULK) <sbd_w> [
  property l,w,nf
  nf = count(schottky_p)
  w = perimeter_coincide(schottky_p,sbd_w)/2/nf
  l = area(schottky_p)/(w*nf)
 
]
TRACE PROPERTY sbd_rf nf nf 0
TRACE PROPERTY sbd_rf w w 0
TRACE PROPERTY sbd_rf l l 0

DEVICE sbd_rf_nw sbd_rf_nw schottky_p(PLUS) schottky_n(MINUS) psub(BULK) <sbd_w> [
  property l,w,nf
  nf = count(schottky_p)
  w = perimeter_coincide(schottky_p,sbd_w)/2/nf
  l = area(schottky_p)/(w*nf)
 
]
TRACE PROPERTY sbd_rf_nw nf nf 0
TRACE PROPERTY sbd_rf_nw w w 0
TRACE PROPERTY sbd_rf_nw l l 0

DEVICE spiral_std_mu_x_20k std_mu_x_20k_ind indm6p(PLUS) indm6m(MINUS) psub(BULK) <IND_RAD> <IND_NR> <IND_GDIS> <IND_W> <IND_S> netlist model spiral_std_mu_x_20k [
   PROPERTY w,spacing,nr,rad,lay,gdis
   lay = 6
   nnr = ( perimeter(IND_NR) - 5e-9*2 ) / 2
   nr = ( nnr / 1e-8 ) * 0.25
   rad = ( perimeter(IND_RAD) - 5e-7*2 ) / 2
   gdis = ( perimeter(IND_GDIS) - 5e-7*2 ) / 2
   w = ( perimeter(IND_W) - 5e-7*2 ) / 2
   spacing = ( perimeter(IND_S) - 5e-7*2 ) / 2
]
  TRACE PROPERTY spiral_std_mu_x_20k lay lay 0
  TRACE PROPERTY spiral_std_mu_x_20k w w 0
  TRACE PROPERTY spiral_std_mu_x_20k spacing spacing 0
  TRACE PROPERTY spiral_std_mu_x_20k nr nr 0
  TRACE PROPERTY spiral_std_mu_x_20k rad rad 0
  TRACE PROPERTY spiral_std_mu_x_20k gdis gdis 0

DEVICE spiral_sym_ct_mu_x_20k sym_ct_mu_x_20k_ind indm6p(PLUS) indm6m(MINUS) psub(BULK) indm4c(CTAP) <IND_RAD> <IND_NR> <IND_GDIS> <IND_W> <IND_S> netlist model spiral_sym_ct_mu_x_20k [
   PROPERTY w,spacing,nr,rad,lay,gdis
   lay = 6
   nnr = ( perimeter(IND_NR) - 5e-9*2 ) / 2
   nr = ( nnr / 1e-8 ) * 0.25
   rad = ( perimeter(IND_RAD) - 5e-7*2 ) / 2
   gdis = ( perimeter(IND_GDIS) - 5e-7*2 ) / 2
   w = ( perimeter(IND_W) - 5e-7*2 ) / 2
   spacing = ( perimeter(IND_S) - 5e-7*2 ) / 2
]
  TRACE PROPERTY spiral_sym_ct_mu_x_20k lay lay 0
  TRACE PROPERTY spiral_sym_ct_mu_x_20k w w 0
  TRACE PROPERTY spiral_sym_ct_mu_x_20k spacing spacing 0
  TRACE PROPERTY spiral_sym_ct_mu_x_20k nr nr 0
  TRACE PROPERTY spiral_sym_ct_mu_x_20k rad rad 0
  TRACE PROPERTY spiral_sym_ct_mu_x_20k gdis gdis 0 

DEVICE spiral_sym_mu_x_20k sym_mu_x_20k_ind indm6p(PLUS) indm6m(MINUS) psub(BULK) <IND_RAD> <IND_NR> <IND_GDIS> <IND_W> <IND_S> netlist model spiral_sym_mu_x_20k [
   PROPERTY w,spacing,nr,rad,lay,gdis
   lay = 6
   nnr = ( perimeter(IND_NR) - 5e-9*2 ) / 2
   nr = ( nnr / 1e-8 ) * 0.25
   rad = ( perimeter(IND_RAD) - 5e-7*2 ) / 2
   gdis = ( perimeter(IND_GDIS) - 5e-7*2 ) / 2
   w = ( perimeter(IND_W) - 5e-7*2 ) / 2
   spacing = ( perimeter(IND_S) - 5e-7*2 ) / 2
]
  TRACE PROPERTY spiral_sym_mu_x_20k lay lay 0
  TRACE PROPERTY spiral_sym_mu_x_20k w w 0
  TRACE PROPERTY spiral_sym_mu_x_20k spacing spacing 0
  TRACE PROPERTY spiral_sym_mu_x_20k nr nr 0
  TRACE PROPERTY spiral_sym_mu_x_20k rad rad 0
  TRACE PROPERTY spiral_sym_mu_x_20k gdis gdis 0

DEVICE xjvar_nr36 jvar_nr tpdiff(PLUS) tndiff(MINUS) psub(BULK) <jvarp_rf> <w_fac> [
  property NR,W
  NR=count(jvarp_rf)
  W = (perimeter_coincide(jvarp_rf,w_fac)/NR)/2
]
TRACE PROPERTY xjvar_nr36 NR NR 0
TRACE PROPERTY xjvar_nr36 W W 0

jvar_nr = jvar_rf3t ENCLOSE jvarp_rf == 36
jvar_ws = jvar_rf3t ENCLOSE jvarp_rf != 36
w_fac   = EXT jvarp_rf jvarn_rf < 0.29 OPPOSITE REGION
DEVICE xjvar_w40 jvar_ws tpdiff(PLUS) tndiff(MINUS) psub(BULK) <jvarp_rf> <w_fac> [
  property NR,W
  NR=count(jvarp_rf)
  W = (perimeter_coincide(jvarp_rf,w_fac)/NR)/2
]
TRACE PROPERTY xjvar_w40 NR NR 0
TRACE PROPERTY xjvar_w40 W W 0

TVF FUNCTION device_function [/*

    package require CalibreLVS_DEVICE_DFM
    namespace import device::*
    proc catching_expr { arg } {
      	#puts "called catching_expr"
      	set rtval 0.0
      	if { [ catch {
            set rtval [ expr $arg ]
      	} result ] } {
            global errorCode
            set tmpError $errorCode
            #puts $result
            if { [ string match "ARITH UNDERFLOW *" $errorCode ] } {
            	#puts "$errorCode error caught during expr"
            	set rtval 0.0
            } elseif { [ string match "ARITH OVERFLOW *" $errorCode ] } {
	    	#puts "$errorCode error caught during expr"
            	set rtval 1e200
            } else {
            	#puts "error propagated during expr"
            	error $result $tmpError
            }
      	}
      	return $rtval
    }

    proc calc_sca { SCH SCV W L LR_EXT TOP_EXT BOT_EXT SCALE } {
  	set sca_sum1 0.0
  	set sca_sum2 0.0
  	set SCref 1.0
  	set slice_count1 [ $SCH slice_count ]
  	set slice_count2 [ $SCV slice_count ]

  	for { set i 0 } { $i < $slice_count1} { incr i } {
       	    set sca_sum1 [ expr { $sca_sum1 + ( ([$SCALE]*[$SCH w $i]) * ( ($SCref * $SCref/([$SCALE]*([$SCH a $i]+[$LR_EXT]))) - ($SCref * $SCref/([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))) +  ($SCref * $SCref/([$SCALE]*([$SCH b $i]+[$LR_EXT]))) - ($SCref * $SCref/([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))))) }]
       	}

  	for { set i 0 } { $i < $slice_count2} { incr i } {
            set sca_sum2 [ expr { $sca_sum2 + ( ([$SCALE]*[$SCV w $i]) * ( ($SCref * $SCref/([$SCALE]*([$SCV a $i]+[$BOT_EXT]))) - ($SCref * $SCref/([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))) + ($SCref * $SCref/([$SCALE]*([$SCV b $i]+[$TOP_EXT]))) - ($SCref * $SCref/([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))))) }]
       	}

  	return [ expr { ($sca_sum1 + $sca_sum2) / ( (([$SCALE]*[$W]) * ([$SCALE]*[$L])) * 1e12) }]
    }

    proc calc_scb {  SCH SCV W  L LR_EXT TOP_EXT BOT_EXT SCALE } {
  	set scb_sum1 0.0
	set scb_sum2 0.0
  	set SCref 1.0
  	set slice_count1 [ $SCH slice_count ]
  	set slice_count2 [ $SCV slice_count ]
  	for { set i 0 } { $i < $slice_count1} { incr i } {
  	    set exp_term1 [ catching_expr " exp(-10*([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6/$SCref) " ]
  	    set exp_term2 [ catching_expr " exp(-10*([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6/$SCref) " ]
  	    set exp_term3 [ catching_expr " exp(-10*([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
    	    set exp_term4 [ catching_expr " exp(-10*([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
   	    set exp_term5 [ catching_expr " exp(-10*([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6/$SCref) " ]
  	    set exp_term6 [ catching_expr " exp(-10*([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term7 [ catching_expr " exp(-10*([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term8 [ catching_expr " exp(-10*([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set scb_sum1 [ expr { $scb_sum1 + ( ([$SCALE]*[ $SCH w $i ])*1e6 * (   (([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6*( $exp_term1/10)) +   ($SCref*($exp_term2/100)) - (([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6*($exp_term3/10)) - (($SCref*($exp_term4/100))) + (([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6*( $exp_term5/10)) +   ($SCref*($exp_term6/100)) - (([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6*($exp_term7/10)) - ($SCref*($exp_term8/100))       )) } ]
     	}
   	for { set i 0 } { $i < $slice_count2} { incr i } {
	    set exp_term1 [ catching_expr " exp(-10*([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term2 [ catching_expr " exp(-10*([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term3 [ catching_expr " exp(-10*([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term4 [ catching_expr " exp(-10*([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term5 [ catching_expr " exp(-10*([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term6 [ catching_expr " exp(-10*([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term7 [ catching_expr " exp(-10*([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term8 [ catching_expr " exp(-10*([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set scb_sum2 [ expr { $scb_sum2 + ( ([$SCALE]*[$SCV w $i])*1e6 * (   (([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6*( $exp_term1/10)) +   ($SCref*($exp_term2/100)) - (([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6*($exp_term3/10)) - ($SCref*($exp_term4/100)) + (([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6*( $exp_term5/10)) +   ($SCref*($exp_term6/100)) - (([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6*($exp_term7/10)) - ($SCref*($exp_term8/100))       )) } ]
     	}
	return [ expr { ( $scb_sum1 + $scb_sum2)  / ( (([$SCALE]*[$W]) * ([$SCALE]*[$L])) *1e12) }]
    }

    proc calc_scc { SCH SCV W L LR_EXT TOP_EXT BOT_EXT SCALE } {
  	set scc_sum1 0.0
	set scc_sum2 0.0
	set SCref 1.0
	set slice_count1 [ $SCH slice_count ]
	set slice_count2 [ $SCV slice_count ]
	for { set i 0 } { $i < $slice_count1} { incr i } { 
	    set exp_term1 [ catching_expr " exp(-20*([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term2 [ catching_expr " exp(-20*([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term3 [ catching_expr " exp(-20*([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term4 [ catching_expr " exp(-20*([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term5 [ catching_expr " exp(-20*([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term6 [ catching_expr " exp(-20*([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term7 [ catching_expr " exp(-20*([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term8 [ catching_expr " exp(-20*([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set scc_sum1 [ expr { $scc_sum1 + ( ([$SCALE]*[$SCH w $i])*1e6 * (   (([$SCALE]*([$SCH a $i]+ [$LR_EXT]))*1e6*( $exp_term1/20)) +   ($SCref*($exp_term2/400)) - (([$SCALE]*([$SCH a $i]+[$L]+ [$LR_EXT]))*1e6*($exp_term3/20)) - ($SCref*($exp_term4/400)) + (([$SCALE]*([$SCH b $i]+ [$LR_EXT]))*1e6*( $exp_term5/20)) +   ($SCref*($exp_term6/400)) - (([$SCALE]*([$SCH b $i]+[$L]+ [$LR_EXT]))*1e6*($exp_term7/20)) - ($SCref*($exp_term8/400))       )) } ]
	}
	for { set i 0 } { $i < $slice_count2} { incr i } {
	    set exp_term1 [ catching_expr " exp(-20*([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term2 [ catching_expr " exp(-20*([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term3 [ catching_expr " exp(-20*([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term4 [ catching_expr " exp(-20*([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term5 [ catching_expr " exp(-20*([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term6 [ catching_expr " exp(-20*([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term7 [ catching_expr " exp(-20*([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term8 [ catching_expr " exp(-20*([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set scc_sum2 [ expr { $scc_sum2 + ( ([$SCALE]*[$SCV w $i])*1e6 * (   (([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6*( $exp_term1/20)) +   ($SCref*($exp_term2/400)) - (([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6*($exp_term3/20)) - ($SCref*($exp_term4/400)) + (([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6*( $exp_term5/20)) +   ($SCref*($exp_term6/400)) - (([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6*($exp_term7/20)) - ($SCref*($exp_term8/400))       )) } ]
	}
	return [ expr { ( $scc_sum1 + $scc_sum2)  / ( (([$SCALE]*[$W]) * ([$SCALE]*[$L])) *1e12) }]
    }
*/]
// Serve X-resistor as an built-in resistor (for PATHCHK)
LVS DEVICE TYPE RESISTOR rnod_m rnodrpo_m rnodw_m rnpo1_dis rnpo1rpo_dis rnpo1w_dis rnwod_m rnwsti_m rpod_m rpodrpo_m rpodw_m rppo1_dis rppo1rpo_dis rppo1w_dis rppolyhri_dis rppolyhri_rf rppolyl_rf rppolys_rf rppolywo_rf [POS=PLUS NEG=MINUS]
LVS REDUCE rppolyhri_rf PARALLEL NO
LVS REDUCE rppolyhri_rf SERIES PLUS MINUS NO
LVS REDUCE rppolyl_rf PARALLEL NO
LVS REDUCE rppolyl_rf SERIES PLUS MINUS NO
LVS REDUCE rppolys_rf PARALLEL NO
LVS REDUCE rppolys_rf SERIES PLUS MINUS NO
LVS REDUCE rppolywo_rf PARALLEL NO
LVS REDUCE rppolywo_rf SERIES PLUS MINUS NO

#IFDEF RC_DECK
//=============================
//======= Setup for PEX =======
//=============================
MASK SVDB DIRECTORY "svdb" XRC
PEX MAGNIFY 1.0
//PEX DELAY                      none   //PENFIELD 0.7 MASK DIRECT
PEX EXCLUDE DISTRIBUTED        "VDD" "AVDD" "VD33" "VDDSA" "VDDPST" "VDD5V" MASK DIRECT
PEX EXCLUDE LUMPED             "VDD" "AVDD" "VD33" "VDDSA" "VDDPST" "VDD5V" MASK DIRECT
PEX NETLIST DISTRIBUTED        "net.dist" HSPICE LAYOUT GROUND VSS MASK DIRECT LOCATION RCNAMED
PEX NETLIST LUMPED             "temp.spi" HSPICE LAYOUT GROUND VSS MASK DIRECT LOCATION RCNAMED
PEX NETLIST SIMPLE             "net.simple" HSPICE LAYOUT MASK DIRECT LOCATION RCNAMED
//Back-annotation xcalibre flow
//PEX NETLIST DISTRIBUTED        "net.dist" HSPICE SOURCE GROUND VSS MASK DIRECT LOCATION RCNAMED
//PEX NETLIST LUMPED             "temp.spi" HSPICE SOURCE GROUND VSS MASK DIRECT LOCATION RCNAMED
//PEX NETLIST SIMPLE             "net.simple" HSPICE SOURCE MASK DIRECT LOCATION RCNAMED

PEX REPORT DISTRIBUTED         none  //"report.dist" ASCII LAYOUT MASK DIRECT
PEX REPORT LUMPED              none  //"report.lump" LAYOUT MASK DIRECT
//PEX RESISTANCE LUMPED          YES MASK DIRECT
//PEX REDUCE LUMPED C            < 10000000
PEX IDEAL XCELL                YES

// xcalibre capacitance and resistance file 
UNIT CAPACITANCE ff
UNIT RESISTANCE OHM
include ./rules


#ELSE

//#############################################
//# ERC CHECK                                 #
//#############################################
// Reports regions on a DNW layer that connect to more than one node.
LVS SOFTCHK DNW CONTACT
// Reports regions on a poly_term layer that connect to more than one node.
LVS SOFTCHK poly_term CONTACT
// Reports regions on a poly_term layer that connect to more than one node.
LVS SOFTCHK poly_term CONTACT
// Reports regions on a rfdmy56 layer that connect to more than one node.
LVS SOFTCHK rfdmy56 CONTACT
// Reports regions on a nxwell layer that connect to more than one node.
LVS SOFTCHK nxwell CONTACT
// Reports regions on a RFDUMMY5T layer that connect to more than one node.
LVS SOFTCHK RFDUMMY5T CONTACT
// Reports regions on a RFDUMMY6T layer that connect to more than one node.
LVS SOFTCHK RFDUMMY6T CONTACT
// Reports regions on a coll layer that connect to more than one node.
LVS SOFTCHK coll CONTACT
// Reports regions on a coll_od2 layer that connect to more than one node.
LVS SOFTCHK coll_od2 CONTACT
// Reports regions on a n_psub layer that connect to more than one node.
#IFNDEF NW_RING
	LVS SOFTCHK n_psub CONTACT
#ENDIF
// Reports regions on a psub layer that connect to more than one node.
LVS SOFTCHK psub CONTACT
// Reports regions on a psub_term layer that connect to more than one node.
LVS SOFTCHK psub_term CONTACT
// Reports regions on a rw layer that connect to more than one node.
LVS SOFTCHK rw CONTACT
#IFDEF FLOATING_GATE_CHECK
GROUP ERC_FLOATING_GATE_CHECK  floating
ERC SELECT CHECK ERC_FLOATING_GATE_CHECK
#ENDIF

#IFDEF WELL_TO_PG_CHECK
GROUP ERC_WELL_TO_PG_CHECK  npvss49 ppvdd49
ERC SELECT CHECK ERC_WELL_TO_PG_CHECK
#ENDIF

#IFDEF GATE_TO_PG_CHECK
GROUP ERC_GATE_TO_PG_CHECK  npvss150 ppvdd150
ERC SELECT CHECK ERC_GATE_TO_PG_CHECK
#ENDIF

#IFDEF DS_TO_PG_CHECK
GROUP ERC_DS_TO_PG_CHECK  mnpg mppg
ERC SELECT CHECK ERC_DS_TO_PG_CHECK
#ENDIF

#IFDEF FLOATING_WELL_CHECK
GROUP ERC_FLOATING_WELL_CHECK  floating.nxwell_float floating.psub
ERC SELECT CHECK ERC_FLOATING_WELL_CHECK
#ENDIF

//MOS erc_nmos_gates S/D connect to POWER&GROUND --mnpg*/
N1tndiff = NET tndiff POWER_NAME
T1tndiff = erc_nmos_gates TOUCH N1tndiff
N2tndiff = NET tndiff GROUND_NAME
T2tndiff = erc_nmos_gates TOUCH N2tndiff

#IFDEF DS_TO_PG_CHECK
mnpg { @ MOS connected to both power and ground
  T1tndiff AND T2tndiff
}
#ENDIF

//MOS erc_pmos_gates S/D connect to POWER&GROUND --mppg*/
N1tpdiff = NET tpdiff POWER_NAME
T1tpdiff = erc_pmos_gates TOUCH N1tpdiff
N2tpdiff = NET tpdiff GROUND_NAME
T2tpdiff = erc_pmos_gates TOUCH N2tpdiff

#IFDEF DS_TO_PG_CHECK
mppg { @ MOS connected to both power and ground
  T1tpdiff AND T2tpdiff
}
#ENDIF

#IFDEF FLOATING_GATE_CHECK
// Floating gate no any CONT interact with the POLY1.
floating { @ Please check the floating gate
  POLY1_no_CONT = POLY1 NOT INTERACT CONT
  gate_no_co = POLY1_no_CONT AND diff
  gate_no_co1 = gate_no_co NOT RFDUMMY1
  POLY1_no_CONT INTERACT gate_no_co1
}
#ENDIF

#IFDEF FLOATING_WELL_CHECK
SCONNECT tndiff nxwell_float by ntap
floating.nxwell_float { @ Floating nxwell_float is not allowed
  PATHCHK !POWER nxwell_float PORTS ALSO
}
#ENDIF

#IFDEF FLOATING_WELL_CHECK
floating.psub { @ Floating psub is not allowed
  PATHCHK !GROUND psub PORTS ALSO
}
#ENDIF
gate1_not_IO1_GND = NET gate1_not_IO1_not_IO1 GROUND_NAME

#IFDEF GATE_TO_PG_CHECK
// gate1_not_IO1 connect to ground 
npvss150 { @ gate1_not_IO1 connected to GROUND
  gate1_not_IO1_GND1 = gate1_not_IO1_GND INTERACT N2tndiff == 2
  gate1_not_IO1_GND NOT gate1_not_IO1_GND1
}
#ENDIF

#IFDEF WELL_TO_PG_CHECK
// ntap connect to ground 
npvss49 { @ ntap connected to GROUND
  ntap_not_var = ntap NOT ( ( ( VARDMYX OR VARG3 ) OR VARG6 ) OR JVARD )
  NET ntap_not_var GROUND_NAME
}
#ENDIF

#IFDEF PATH_CHECK
// Nodes with a path to ground but not power 
ERC PATHCHK GROUND && !POWER
#ENDIF

#IFDEF PATH_CHECK
// Nodes with a path to power but not ground 
ERC PATHCHK POWER && !GROUND
#ENDIF

#IFDEF PATH_CHECK
// Nodes without a path to power and ground 
ERC PATHCHK !POWER && !GROUND NOFLOAT
#ENDIF

#IFDEF PATH_CHECK
ERC PATHCHK !LABELED NOFLOAT
#ENDIF
gate1_not_IO1_not_IO1 = gate1_not_IO1 NOT OD2
CONNECT gate1_not_IO1_not_IO1 poly
gate1_not_IO1_PWR = NET gate1_not_IO1_not_IO1 POWER_NAME

#IFDEF GATE_TO_PG_CHECK
// gate1_not_IO1 connect to power 
ppvdd150 { @ gate1_not_IO1 connected to POWER
  gate1_not_IO1_PWR1 = gate1_not_IO1_PWR INTERACT N1tpdiff == 2
  gate1_not_IO1_PWR NOT gate1_not_IO1_PWR1
}
#ENDIF

#IFDEF WELL_TO_PG_CHECK
// ptap connect to power 
ppvdd49 { @ ptap connected to POWER
  NET ptap POWER_NAME
}
#ENDIF

#ENDIF
