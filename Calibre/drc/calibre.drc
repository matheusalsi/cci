// *****************************************************************************
// * 0.18um/0.16um Calibre DRC COMMAND FILE - CLM18_LM16_6M.28a 06/25/2009 *
// * FOR TSMC 0.18UM CMOS LOGIC/MS/RF AND 0.16UM CMOS LOGIC/MS 1P6M PROCESS DESIGN RULE*
// *          (CL018G/LV/LP, CM018, CR018 CL016G, CM016)                       *
// * (DESIGN RULE DOCUMENT: T-018-LO-DR-001 Rev2.8)                            *
// * (DRC COMMAND FILE DOCUMENT: T-018-LO-DR-001-C1 Rev 2.8a)          	       *
// *****************************************************************************
//

//	TSMC has developed this deck using Mentor Graphics proprietary SVRF and TVF formats.
//	The deck is to be used  only in Calibre tools
//
//
//  DISCLAIMER
//
//  The information contained herein is provided by TSMC on an "AS IS" basis
//  without any warranty, and TSMC has no obligation to support or otherwise
//  maintain the information.  TSMC disclaims any representation that the
//  information does not infringe any intellectual property rights or proprietary
//  rights of any third parties.  There are no other warranties given by TSMC,
//  whether express, implied or statutory, including, without limitation, implied
//  warranties of merchantability and fitness for a particular purpose.
//
//  STATEMENT OF USE
//
//  This information contains confidential and proprietary information of TSMC.
//  No part of this information may be reproduced, transmitted, transcribed,
//  stored in a retrieval system, or translated into any human or computer
//  language, in any form or by any means, electronic, mechanical, magnetic,
//  optical, chemical, manual, or otherwise, without the prior written permission
//  of TSMC.  This information was prepared for informational purpose and is for
//  use by TSMC's customers only.  TSMC reserves the right to make changes in the
//  information at any time and without notice.
//
//-------------------------------------------------------------------------------------------
//
//  NOTICE: (Read Me First!)
//
//  1. If the input GDS file does not include all the layers in the
//     INPUT LAYER BLOCK, for example, they are generated by logic
//     operations, please make sure the consistence with original
//     layer definition.
//
//  2. The runset is tested and developed on Calibre v2008.4_28.20 (Jan. 2009), please use 
//     this or newer TSMC qualified version of Calibre to execute this runset.
//

//----------------------------------------------------------------------------------------
//
// REVISION:
// 
// 2.0a 04/27/00 T.C.Chiang
//	1) add NW resistor space to NW
//	2) PO.R.1 modofied
//	3) combine implant check such like N2V.C.4/N2V.E.5 -> N2V.C.4
//	4) CO.S.2 relax to be applied larger than 3x3
//	5) CO.C.2  0.21 -> 0.20
//	6) IO ESD guideline  ESD.4/ESD.5
//	7) ESD.S.2/ESD.C.1/ESD.C.4
//	8) Add RPO.C.6
//	9) Add fuse rule
//	10) remove CB rules - only check basic CB rule
// 2.0b 06/20/00 T.C.Chiang
//	1) modify N2V/P2V/N3V/P3V as drawn layers
//	2) revise wide metal check Mx.S.2
//	3) rename input layer names as document T-018-LO-LE-003
//	4) revise PO.R.1B
//	5) revise N2V.C.1/N3V.C.1/P2V.C.1/P3V.C.1/NP.C.1/PP.C.1
//	6) add option to set different grid check
//	7) NTAP definition exclude well resistor OD
// 2.0c 08/04/00 T.C.Chiang
//	1) revise N3V.E.1
//	2) remove undefined check N3V.E.2
//	3) revise ESD.C.4
//	4) rename NT_N.E.2 to NT_N.PO.1
//	5) revise PO.R.2 check
// 2.1a 09/28/00 Kevin Liu
//      Rule Changed: NWR.C.2/OD.W.3/PO.R.2/FUSE.M/LAT.2/ESD.5/ESD.9
//      Layer Removed: N2V/N3V/P2V/P3V
//      Revise Checked:
//	1) LAT.3P/LAT.3N
//	2) OD2.E.2
//	3) IO ESD rules
//	4) nwel space check by connectivity
//      Added Check: metal slot rule
// 2.1b 10/17/00 Kevin Liu
//	Check Added: FUSE.J
// 2.1c 11/15/00 Kevin Liu
// 	Check revised: ESD.5.WARN.2 / LAT.3P / LAT.3N / ESD.6 / RPO.C.3
//	Revise Layer: DMN2V   184
// 2.1d 02/12/01 Kevin Liu
//	Revise check: AM.W.1.Mx_AM.W.2.Mx, MxHOB Logic operation
// 2.1e 04/12/01 C.W.Wei
//	Revise check: AM.W.3.Mx (x = 1~6)
//      Revised PP.E.3..4/PP.E.3..4 to avoid false errors caused by EXCL layer
//      Revised CO.S.2 rule checks
//	Revised check: AM.L.1.Mx (x = 1~6) 
// 2.1f 05/07/01 C.W.Wei
//	Revise check: AM.W.3.Mx (x = 1~6)
// 2.2a 05/28/01 Kevin Liu
//	1) Remove all layers V-Notches check.
//	2) Change layers NWELL/NP/PP/Metal2~Metal6/VIA2~VIA5 methodology to solve SRAM
//	   using NOT INSIDE EXCL
//	3) Rule change: NP.E.6/PP.E.6 added (RPO AND POLY) NOT IMP
//	4) FUSE rules are removed by this deck
//	5) Dummy Pad & Power Line remove Contact check
//	6) LAT.3N & LAT.3P methodology change
// 2.2b 08/14/2001 Kevin Liu
//	1) Adding layer FWI(235); LWI(63;2)
//	2) Revise derived layer RNGX = PMDMY NOT ( CB OR FW OR LW)
//	3) Revise metal density report file Mx_DENSITY.log (x=1~6)
//	4) " DRC MAXIMUM RESULTS ALL "
// 2.3a 10/05/2001 C.S.Yang 
//	Revise check : latch-up rule
// 2.3b 01/31/2002 Brad Pu
//	check revised:
//	1) NT_N.E.1: Using the definition of SIZE to check maximum and minimum.
//	2) ADP.W.3: width 80um is a good pattern.
//	3) Modify the resolution value of environment setup to 5
//	4) Remove LAYER RESOLUTION
//	5) Add two layers CBDi(169) and MDi(168), and related metal slot uncheck features.
//	6) ESD.6 check to EGTE not poly
// 2.3c 11/11/2002 - G.S.Chang
//	1) Revise Mx.S.2, employ OPPOSITE metrics to the spacing check of the small metal
//	   piece with length less than 1um and connected to wide metal.
//	2) Modify LAT.2 to check the whole active area inside SDI region 
//	3) Recognize each ESD devices for ESD rules with dummy layers instead of connections
//	4) Modify PP.E.3/PP.E.4/PP.C.2/PP.C.3/PP.E.1 (same as NP) to highlight the butted edge
//	   of OD and PP(NP) but without coincident with NP(PP).
//	5) Change the method to pickup bent poly in rule NTN.I.4
//	6) Create metal slot and chip-corner rules for RDL layers (MD). 
//	7) Create options of HIGH_VOLTAGE and CORE_VOLTAGE for slections of different core or I/O
//	   voltages and execute DRC with proper rules.
//	8) Add checks for warning if there is not any option for HIGH_VOLTAGE and CORE_VOLTAGE specified.
//	9) Apply new option INNER EMPTY in metal slot checks.
// 2.3d 03/11/2003 - G.S.Chang
//	1) Revise Mx.S.2, correct false errors between branches of wide metals.
//	2) Add 5V HIGH_VOLTAGE option for concatenation of 5V DRC module.
// 2.4a 07/01/2003 - Yating Chuang
//	1) Revise PO.R.2, fix false error from sizing step.
//	2) Relax butted edges between active and pickup for OD2.E.1.
//	3) Use NWELL to define active and pick-up od instead of PWELL.
//	4) Revise NWR.O.1, remove inside NWELL. Add check overlap of RPO to NP.
//	5) Add NWR.E.3, consider extension of NP beyond NPOD in NW resistor under STI.
//	6) Modified the definition of RDL pad area for metal slot exclusion.
//	7) Revise LAT.3P/N with more precisely sizing stepping.   
// 2.4b 12/16/2003 - Yating Chuang
//	1) Revise PO.R.2, fix missing error from definition of long poly.    
// 2.5a 03/04/2004 - C.T.Yao, Yating Chuang
//	1) Add option "#DEFINF CUP" for choosing wire bond structure.
//	2) Modify mslot and via rule to check circuit under CUP.
//	3) Revise connection layer in NW rule.     
//	4) Revise all metal slot dimension rules as guidelines and add AMS.DN.1.Mx. 
//	5) Refine ESD rules, add ESD.11, relax ESD.5B,ESD.5H,ESD.5I. 
//	6) Relax NT_N.W.1: 0.86um -> 0.74um.
//	7) Add ADP.R.0C, VIA1,3,5 and VIA2,4,6 should not overlap in dummy pad structure.  
//	8) Add ADP.R.0D, VIA1,3,5 and VIA2,4,6 should not overlap in power line structure. 
// 2.5b 07/05/2004 - C.T.Yao
//	1) Create switch CHECK_SRAM_EXCL to check M2 and upward layers inside layer EXCL also. 
//	2) Add HRI.WARN to check RLPPDMY interact OD.
//	3) Modify the checking methodology of the rule Mx.S.2 for checking exactly.
//	4) Replace OVERLAP, INSIDE ALSO, OUTSIDE ALSO options with AND, NOT, CUT operations.
//	5) Relax AM.W.1.Mx, at least one branch width >= 10um.
//	6) Revise ESD.5H, ESD.5I to be ">=", not "==" 0.25um, enhance ESD.6. 
// 2.5c 02/14/2005 - H.M.Tseng
//	1) Add "TRUNCATE" option to fix false error in "SIZE UNDEROVER".
//	2) Add "ENCLOSE RECTANGLE" to fix false error in seeking wide metal.
//	3) Remove the the switch of CUP and add WBDMY (183) layer for seperating CUP and NON-CUP.
// 2.5d 04/12/2005 - J.Y.Li
//	1) Fix false error in ESD.11: exclude pick-up not between diffusion of ESD.       
//	2) Enhance LAT.3P LAT.3N to ignore filler cell violation.
// 2.6a 04/26/2006 - Allen Tsai
//	1) Add NP.R.3, PP.R.3.
//	2) Refine RPO.C.4, RPO.C.5.
//	3) Modify PO.R.3.
//	4) Refine OD.W.3 and NT_N.I.3:Follow DRM revision.
//	5) Refine NT_N.E.1: Modify checking region from OD to NPOD.
// 2.6a 05/04/2006 - Y.J. Chuang
//	6) Revise Mx.S.2 for wide metal space check.
//	7) Add MD and VIAD rules follow MT and VIAT.
// 2.6b.pre 08/25/2006 - Harry Yeh
//	1) Revise OD2.E.1/OD2.C.1, modify check region from {Active OD} to {Active OD or GATE}.
//	2) Revise OD2.E.2, check source/drain direction only.
//	3) Add an option "CHECK_DUMMY_ODPO" to switch dummy OD&PO rule check.
// 2.7a.pre 04/15/2008 - Y.M. Zhang
//      Merge the following design rules into T-018-LO-DR-001.
//             C018G Logic 1.8/5V design rule (T-018-LO-DR-011)
//             C018LV Logic 1.5/3.3V design rule (T-018-LO-DR-003)
//             C018LV Logic 1.5/2.5V design rule (T-018-LO-DR-008)
//             C018LP Logic 1.8/3.3V design rule (T-018-LO-DR-009)
//             C018LP Logic 1.8/5V design rule (T-018-CL-DR-001)
//             C018 MM_RF design rule (T-018-MM-DR-001)
//             C016 Logic/MM design rule (T-016-CL-DR-001) 
//      1) Add LOGO rules        
//      2) Add 40KA UTM rules for 0.18um 1.8V/3.3V MM/RF process only
//      3) Add 2fF MIMCAP device for 0.18um 1.8V/3.3V process only and add A.R.MIM.5 for it in antenna part 
//      4) Add VTM_P.R.3 with design rule
//      5) Remove AM.W.1 with design rule.
//      6) Remove RES.8 with design rule.
//      7) Remove native device rule in mixed signal section due to duplicate with logic section 4.5.3.
//                The extra rule NT_N.I.6 in mixed signal can be covered by NT_N.I.4 & NT_N.E.1.
//      8) Rename rules for DNW.I.X, VTM_N.I.X, VTM_P.I.X,RES.X, CTM.E.3
//            From DNW.I.X(X=5,6,7) to DNW.R.X(X=3,4,5);From VTM_N.I.X, VTM_P.I.X(X=195) to VTM_N.R.X, VTM_P.R.X(X=195) 
//            PO.W.1 to PO.W.1_HRI and RES.x to RES.HRI.x,MIM_Mx.E.3 to CTM.E.3,RPO.O.1 to RPO.O.1_HRI for HRI only   
//      10) Remove rules for NT_N.I.6, VIAx.0, VIAx.C.1, VIAn.C.1.
//      11) Refine ESD guideline and remove old 1.8V high voltage tolerant device.
//      12) Refine and re-structure latch-up guideline rules 
//      13) Modify DNW.C.1. check DNW to NWEL with DNW.  
//      14) Modify HRI.E.1.
// 2.7a.pre 04/16/2008 - Y.M. Zhang
//      1) Add logo ruls check.
//      2) Add ESD implant rules check for 5V process 
// 2.7a.pre 04/21/2008 - Y.M. Zhang
//      1) Modify NT_N.W.2 to check CL018G too 
//      2) Add ADP.C.1 and change ADP.S.4 to ADP.S.1_PL
// 2.7a 04/21/2008 - Y.M. Zhang
//      Official release.
// 2.7b 07/23/08 - Y.M. Zhang
//      1) Remove DRC UNSELECT CHECK.  
//      2) Modify PO.W.1_HR to enable check more exactly.  
//      3) Change ADP.C.3 to ADP.C.1 and ADP.C.2 to align design rule. 
//      4) Modify some rule name to align design rule.
//                Change VTMP.X.X to VTM_P.X.X,
//                Change VTMN.X.X to VTM_N.X.X,
//                Change NT_N.W.3 to NTN.W.3 in C016 process.
//      5) Modify CURRENT STATUS part.
// 2.7c 12/23/2008 - M.Feng
//	1) Change the rule name from NT_N.W.2 to NT_N.W.2_LV
//	2) Change the rule writing of the ESD.24g, ESD.28g
//	3) Change the rule check of LUP.5.4 according to design rule owner's comment.
//	4) Change the rule check of MIMVIA.S.1 and MIMVIA.S.2 according to design rule owner's comment.
// 2.8a 06/25/2009 - M.Feng
//	1) Change the rule writing of rule NT_N.I.4, NP.R.3, PP.R.3,PP.O.1,PP.E.1,RPO.C.3,CO.W.1,CO.E.3,VIAx.W.1,
//	   VIAn.W.1,DNW.E.1,CTM.W.4,ESD.20g,ESD.21g,LOGO.R.1 according to the DRM
//	2) Add the new rules NWR.R.3,NWR.R.4,NWR.R.5,NWR.R.6,RES.9,RES.10,RES.11,DNW.S.2,IMD crack rules,ESD.35g
//	   SBD rules according to the DRM.
//	3) Delete the rules VTM_N.R.1,VTM_P.R.1,DNW.C.2,DNW.C.3 according to the DRM
//	4) Change the layer definition of the EXCL for LOGO.R.2.
//	5) Change the recognition method for I/O device according to the advance process.
//	6) Change the rule name from ESD.8 to ESD.8g,ADP.S.2 to ADP.S.2g, ADP.W.3 to ADP.W.3g, ADP.W.4 to ADP.W.4g
//	   LUP rules according to the DRM.
//	7) Put the VIAD rules and the M6/MD density rules into the normal top metal option. 
//	8) Add the warning for the ESD implant (ESD.WARN.3) according to the DRM owner's comment.
//	9) Change the UTM20K.C.1, UTM40K.C.1 to recomendation rules according to the design rule change.
//-------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------
//
// DUMMY LAYER REQUIRED:
//
//  1) HOTWL   - Hot N-Well
//               N-Well not connected to the most positive voltage Vdd is defined as Hot N-Well. 
//               It must follow different width and space rules from the N-Well connected to 
//               Vdd (Cold N-Well). Use "HOTWL" layer to exactly cover the Hot N-Well area for 
//               correct N-Well DRC.
//
//  2) EXCL    - UN-DRC area
//               If there's any area with different rules and not to be checked in this run, 
//               use the "EXCL" layer to exactly cover the area to be excluded.
//
//  3) SDI     - I/O ESD Protection Circuit
//               For I/O guidance rule checking, use "SDI" layer to designate the ESD area to 
//               checked. The whole ESD devices should be covered by "SDI".
//
//  4) DPDMY   - Dummy Pad area
//               For chip corner dummy pad, use "DPDUMMY" layer to cover dummy pad area.
//
//  5) PLDMY   - Power Line
//               For chip corner power line, use "PLDUMMY" layer to cover whole power line area.
//
//  6) RWDMY   - NWell Resistor
//               The N-Well region covered by both RWDMY and RPO is the NW within OD resistor.
//               The N-Well region covered by only RWDMY is the NW under STI resistor.
//
//  7) DRCDMY  - TSMC reserved layer.
// 
//  8) ESD1DMY - IO ESD region dummy layer, RPO must enclose whole gate.
//     ESD2DMY - RPO enclose gate 0.05 for 3.3V.
//
//  9) DMN2V   - Dummy layer to ensure N2V in N+ poly/od resistor.
//     DMP2V   - Dummy layer to ensure P2V in P+ poly/od resistor.
//
// 10) RLPPDMY - LPP high resistance poly resistor
//               Use "RLPPDMY" to exactly cover LPP high resistance poly resistor area.
//
// 11) WBDMY   - Dummy layer to cover the CUP pad.
//
// 12) CTMDMY  - Capacitor bottom plate
//               Use "CTMDMY" to cover capacitor bottom plate in mixed-signal process.
// 13) INDDMY  - Dummy layer for inductor recognition in mixed-signal process.
//
// 14) LUPWDMY - DRC dummy layer to waive Latch-Up rules for verified IP. 
//
// 15) SBDDMY   - dummy layer to fully cover schottky barrier diode.
//
// 16) VSSDMY   - dummy layer to cover VSS PAD
//
// 17) VDDDMY   - dummy layer to cover VDD PAD
//-------------------------------------------------------------------------------------------
//
//                      CURRENT STATUS
//
//  RULES NOT IMPLEMENTED:
//
//  The following rules are not coded in this rule file:
//
//  rule                      description/explanation/alternate file
//  ------------------------  ----------------------------------------------------
//  Part I recommendations    Not coded (page 3 of spec.)
//
//  Antenna rules             Please refer to Antenna DRC deck.
//
//  Passivation rules         Please refer to Bond PAD DRC deck.
//
//  Metal Fuse rules          Please refer to Metal Fuse DRC deck.
//
//  Seal Ring rules           Not coded.
//
//  SRAM rules                Not coded.
//
//  Chip Corner Power Line    Only ADP.1/ADP.S.1/ADP.C.1/ADP.C.2/ADP.E.1
//  and Dummy PAD             /ADP.W.1/ADP.W.2/ADP.E.2 
//                            rules are coded.
//
//  Un-Checkable rules        DNW.R.3(R), RES.8(R),RES.HRI.6(R),MIMVIA.S.1/S.2(R), MIMVIA.R.1/R.2(R),CTM.R.4,DNW.R.6
//
//  * Guidelines implemented :
//
//    1) Partial I/O ESD GuideLines are implemented: 6,8,18~34,35,36,37.
//       Others are not implemented because of guideline.
//
//    2) Partial LatchUp GuideLines are implemented: 1,2,3,4,5,6
//       Others are not implemented because of guideline.
//
//    3) Dummy PAD Guidlines implemented: ADP.S.2 ADP.W.3 ADP.W.4
//
//    4) Seal Ring rules are not implemented: SR.S.1 SR.E.1 
// 
//    5) Metal stress relief guideline rules are not implemented.
//

//-------------------------------------------------------------------------------------------
//	
//  * To correctly use this DRC deck, the following settings are very important in
//    this DRC command file:
//	
//  (0) Calibre v2008.4_28.20 (Jan. 2009) is used to develop and QA this command file. 
//	Please execute the DRC with this or newer TSMC qualified version of Calibre.
//
//==================================================================================================================
//
//
//  Pay attention to!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
//     
//     Pls turn on switch (#DEFINE C016) if you use 0.16um process, Otherwise, It will cause a big risk.        
//
//
//
//
//******************************************************************************************************************
//  This drc deck can be used to do check for C018 and C016 process as below:
//     
//       a. For 0.18um process
// 
//             1) C018 logic 1.8V/3.3V process (general purpose)     
//             2) C018 logic 1.8V/3.3V process (low power)           
//             3) C018 logic 1.8V/5V process   (general purpose)     
//             4) C018 logic 1.8V/5V process   (low power)           
//             5) C018 logic 1.5V/3.3V process (low voltage)         
//             6) C018 logic 1.5V/2.5V process (low voltage)         
//             7) C018 Mixed-Singal/RF 1.8V/3.V process              
//	       8) C018 RF SBD 1.8V/3.V process
//
//       b. For 0.16um process
// 
//             1) C016 logic/Mixed-Singal 1.8V/3.3V process          
//
//     Note: The default of this DRC command file is for 0.18um logic 1.8V/3.3V(general purpose) design rule
//           you can turn on/off relted switch correctly if other process are used,.
//                  
//                    turn on in calibre drc  means remove "//" in the front of "#DEFINE XXXX"
//                    turn off in calibre drc means add "//" in the front of "#DEFINE XXXX"  
//
//********************************************************************************************************************
//  
//  There are some MUST switchs and OPTIONAL switchs in this drc deck. You must keep MUST switch turn on or trun off correctly.
//  Otherwise, you could not check drc correctly. As to OPTIONAL switch, you can turn on/off according to you requirement.
//  The default of this DRC command file is for 0.18um logic 1.8V/3.3V(general purpose) design rule
//  
//
//   MUST switch: 
//              
//     #DEFINE 3.3V 	    // turn on only when HIGH_VOLTAGE = 3.3V,otherwise please turn off it.
//   //#DEFINE 2.5V 	    // turn on only when HIGH_VOLTAGE = 2.5V,otherwise please turn off it
//   //#DEFINE 5V 	    // turn on only when HIGH_VOLTAGE = 5V  ,otherwise please turn off it
//     
//     #DEFINE 1.8V         // turn on only when CORE_VOLTAGE = 1.8V,otherwise please turn off it
//   //#DEFINE 1.5V 	    // turn on only when CORE_VOLTAGE = 1.5V,otherwise please turn off it
//
//   //#DEFINE LP           // turn on only when you use Low Power process,otherwise please turn off it 
//   //#DEFINE C016         // turn on only when you use 0.16um process,otherwise please turn off it
//   //#DEFINE MIX_MODE     // turn on only when you use Mixed-Singal/RF process,otherwise please turn off it
//                 
//   //#DEFINE THICK_40K    // turn on only when 40KA Thick Top Metal is used.otherwise please turn off it
//   //#DEFINE THICK_20K    // turn on only when 20KA Thick Top Metal is used.otherwise please turn off it           
//                          
// OPTIONAL switch:
//
//   //#DEFINE CHECK_SRAM_EXCL  // turn on  when M2 and upward layers in SRAM region covered by EXCL are checked.
//     #DEFINE CHECK_ALRDL      // turn off when MD&VIAD rules are not checked.
//     #DEFINE CHECK_DUMMY_ODPO // turn off when Dummy OD&PO are not checked.
//   //#DEFINE Recommend        // turn on  when Recommended rules are checked.
//     #DEFINE GUIDELINE_LUP    // turn off when you don't want check latchup guideline rules.   
//     #DEFINE GUIDELINE_ESD    // turn off when you don't want check ESD guideline rules.
//   //#DEFINE CHECK_LATCHUP_BY_TEXT        	// Turn on to recognize IO PAD by following text
//     #DEFINE CHECK_LATCHUP_BY_PAD_CONNECTION	//Turn on to recognize recognize the MOS connected to I/O by connection
//
// For example:
//  
//    1) If your design use 0.18um Mixed-Singal/RF 1.8V/3.3V process.
// 
// Please turn on MUST switchs (#DEFINE 3.3V ; #DEFINE 1.8V; #DEFINE MIX_MODE; #DEFINE THICK_40K or #DEFINE THICK_20K) 
//    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement.
//    
//    2) If your design use 0.18um logic 1.8V/5V Low Power process.
// 
// Please turn on MUST switchs (#DEFINE 5V; #DEFINE 1.8V; #DEFINE LP ) 
//    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement.
//
//    3) If your design use 0.18um logic 1.5V/3.3V low voltage process.
// 
// Please turn on MUST switchs (#DEFINE 1.5V; #DEFINE 3.3V ). 
//    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement
//
//    
//    4) If your design use 0.16um logic 1.8V/3.3V process.
// 
// Please turn on MUST switchs (#DEFINE 3.3V ; #DEFINE 1.8V; #DEFINE C016 ) 
//    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement.
//
//    5) If your design use 0.16um Mixed-Singal 1.8V/3.3V process.
// 
// Please turn on MUST switchs (#DEFINE 3.3V ; #DEFINE 1.8V; #DEFINE C016; #DEFINE MIX_MODE ) 
//    and turn off other MUST switchs. and turn on/off OPTIONAL switchs according to you requirement.
//    
//    
//********************************************************************************************************************
//
//  (1) Process selection:
//      
//      The default of this DRC command file is for 0.18um logic 1.8V/3.3V(general purpose) design rule(T-018-LO-DR-001)
//      If other process are used, Pls turn on you use process switch and turn off other process switch.
//
//              //#DEFINE LP       // turn on only when you use Low Power process,otherwise please turn off it  
//              //#DEFINE C016     // turn on only when you use 0.16um process,otherwise please turn off it

//  (2) Variable for High Voltage:
//
//	The default of this DRC command file assumes 3.3V is used as high (I/O) voltage.
//	If other high voltages are used, please DEFINE other variables. For example,
//	if 2.5V is used as high voltage, then the settings should be:
//
//		//#DEFINE 3.3V 	// when HIGH_VOLTAGE = 3.3V
//		#DEFINE 2.5V 	// when HIGH_VOLTAGE = 2.5V
//		//#DEFINE 5V 	// when HIGH_VOLTAGE = 5V
//	
//
//  (3) Variable for Core Voltage:
//
//	The default of this DRC command file assumes 1.8V is used as core voltage.
//	If other core voltages are used, please DEFINE other variables. For example,
//	if 1.5V is used as core voltage, then the settings should be:
//
//		#DEFINE 1.8V 	// when CORE_VOLTAGE = 1.8V
//		//#DEFINE 1.5V 	// when CORE_VOLTAGE = 1.5V
//
//  (4) Variable for High Voltage & Core Voltage:
//
//	Please choose proper voltages for the core and I/O devices in the logic section.
//	The setting should be:
//
//		#DEFINE 3.3V 	// when HIGH_VOLTAGE = 3.3V
//		//#DEFINE 2.5V 	// when HIGH_VOLTAGE = 2.5V
//		//#DEFINE 5V 	// when HIGH_VOLTAGE = 5V
//		#DEFINE 1.8V 	// when CORE_VOLTAGE = 1.8V
//		//#DEFINE 1.5V 	// when CORE_VOLTAGE = 1.5V
//
//	To execute the runset with I/O voltage equals 3.3V and core voltage as 1.8V.
//
//  (5) Variable for check SRAM inside layer EXCL:
//
//	By default, we exclude DRC check inside SRAM region covered by exclude layer "EXCL(55)".
//	However, customers could enable this option to check M2 and upward layers inside EXCL
//	in order to check logic rules inside SRAM.
//	Please notice that turn on this option will also disable the waiving function of EXCL, 
//	and the region covered by EXCL will be examined with M2 and upward layers' rules.
//	Please remove // to enable this function:
//
//		#DEFINE CHECK_SRAM_EXCL
//
//  (6) Variable for MD&VIAD rule checking:
//
//	By default, MD&VIAD rules are checked in this deck. If MD&VIAD rules are not required
//	to check, please add // to disable this option:
//
//		//#DEFINE CHECK_ALRDL
//
//  (7) Variable for dummy OD&PO rule checking:
//
//	By default, dummy OD&PO are checked by rules in this deck. But some unnecessary rule 
//	checks may induce false alarm. If dummy OD&PO are not required to check, please
//	add // to disable this option:
//
//		//#DEFINE CHECK_DUMMY_ODPO
//
//	Note: If this option is disabled, please make sure the LVS result is correct after 
//	      dummy insertion to prevent from dummy pattern induced layout circuit short.
//
//  (8) Variable for Mixed-Signal/RF circuit design:
//
//	By default, this DRC deck is used for Mixed-Signal/RF process. When this DRC deck is
//	used for general Logic process, please add // to disable this option:
//
//		//#DEFINE MIX_MODE
//
//  (9) Variable for Thick Top Metal check:
//
//	By default, the Top Metal is Normal Top Metal. If customer uses 20KA or 40KA Thick Top 
//	Metal, please remove // to the option 'THICK_40K' or 'THICK_20K',But only one should be turn on every time.
//
//	For 20k Top metal:
//		//#DEFINE THICK_40K
//		#DEFINE THICK_20K
//
//	For 40k Top metal:
//		#DEFINE THICK_40K
//		//#DEFINE THICK_20K

//  (10) Variable for recommended rule check:
//
//	By default, recommended rules are not checked, but it is suggested to remove // to 
//	enable this option from the point of view of noise isolation and SPICE model accuracy.
//	The recommended rule check includes DNW.E.1, DNW.S.2 and RES rules.
//
//		#DEFINE Recommend
//
//  (11) Latch-up guideline check:
//
//	By default, This command file will check Latch-up guideline rules,
//	please add // if you don't want check these rules:
//
//		//#DEFINE GUIDELINE_LUP
//
//  (12) ESD guideline check:
//
//	By default, This command file will check ESD guideline rules,
//	please add // if you don't want check these rules:
//
//      	//#DEFINE GUIDELINE_ESD
//
//  (13) CHECK_LATCHUP_BY_TEXT: (default is off) 
//       DRC uses CB/CBD/CB2/UBM layer to recognize PAD, and uses the connection
//       of well strap to distinguish IO PAD and VDD/VSS PAD. So latch-up rules can not be
//       checked in cell level if no CB/CBD/CB2/UBM layer exists. Also,if VDD/VSS pad is not
//       connected to strap, it will be falsely recognized as IO pad. 
//       You can turn on this option to solve these inconveniences. Assign the PAD/VDD/VSS pin name in
//       Variables (PAD_TEXT/VDD_TEXT/VSS_TEXT). Notice that only text by metal pin layer in top cell
//       is used for latch-up check.
//	 If you don not want to recognize VDD/VSS/PAD by pin name, you could turn off this switch.
//
//  (14) CHECK_LATCHUP_BY_PAD_CONNECTION: (default is on)
//      DRC use following two methods to recognize the ACTIVE which needs to check latch-up rules. 
//      1. Active are covered by SDI dummy layer
//      2. Active connects to the IO pad directly.
//      If you don't want to use pad connection (method 2) to check latch-up rules, please turn off this option.
//      Then only ACTIVE covered by SDI layer will be checked. 
// 
//-------------------------------------------------------------------------------------------

//#DEFINE CHECK_SRAM_EXCL // turn on only when you want check M2 and upward layers in SRAM region covered by EXCL. otherwise please turn off it
#DEFINE CHECK_ALRDL       // turn on only when you want check MD&VIAD rules. otherwise please turn off it
#DEFINE CHECK_DUMMY_ODPO  // turn on only when you want check Dummy OD&PO. otherwise please turn off it
#DEFINE GUIDELINE_LUP     // turn on only when you want check latchup guideline rules. otherwise please turn off it
#DEFINE GUIDELINE_ESD     // turn on only when you want check ESD guideline rules. otherwise please turn off it
//#DEFINE Recommend       // turn on only when you want to check Recommended rules. otherwise please turn off it
#DEFINE MIX_MODE          // turn on only when you use Mixed-Singal/RF process. otherwise please turn off it

//#DEFINE THICK_40K       // turn on only when 40KA Thick Top Metal is used. otherwise please turn off it
#DEFINE THICK_20K       // turn on only when 20KA Thick Top Metal is used. otherwise please turn off it

//#DEFINE LP          // turn on only when you use Low Power process. otherwise please turn off it 
//#DEFINE C016        // turn on only when you use 0.16um process. otherwise please turn off it

#DEFINE 3.3V 	// turn on only when HIGH_VOLTAGE = 3.3V. otherwise please turn off it
//#DEFINE 5V 	// turn on only when HIGH_VOLTAGE = 5V. otherwise please turn off it
//#DEFINE 2.5V 	// turn on only when HIGH_VOLTAGE = 2.5V. otherwise please turn off it

#DEFINE 1.8V 	// turn on only when CORE_VOLTAGE = 1.8V. otherwise please turn off it
//#DEFINE 1.5V 	// turn on only when CORE_VOLTAGE = 1.5V. otherwise please turn off it


//#DEFINE CHECK_LATCHUP_BY_TEXT       // Turn on to recognize IO PAD by following text  
VARIABLE PAD_TEXT  "?"       // pin name of PAD
VARIABLE VDD_TEXT  "AVDDBG" "AVDDR" "AVDWELL" "VDWELL" "VD33APST" "VDD5V" "TAVD33" "VD33PST" "AVDD" "TAVDD" "TAVD33PST" "TAVDDPST" "AVD33B" "VDD" "AVD33G" "DVDD" "AVDDG" "AVDDB" "VDDG" "VDDPST" "VD33REF" "VD33" "AVD33R" "VDDSA"    // pin name of VDD
VARIABLE VSS_TEXT  "VSSPST" "AVS33R" "AVSSUB" "VSSREF" "VSSAPST" "VS33APST" "DVSS" "AVS33G" "AVSSBG" "TAVSS" "AVS33B" "AVSSB" "GND" "VSSG" "VSSUB" "VSS" "AVSS" "TAVSSPST" "AGND" "AVSSR" "AVSSG"    // pin name of VSS 

#DEFINE CHECK_LATCHUP_BY_PAD_CONNECTION	//Turn on to recognize recognize the MOS connected to I/O by connection


//
// ENVIRONMENT SETUP
//------------------
PRECISION    1000
RESOLUTION     5   //Set layout grid  check to 0.005

LAYOUT SYSTEM GDSII
LAYOUT PATH "GDSFILENAME"
LAYOUT PRIMARY "TOPCELLNAME"

DRC RESULTS DATABASE "DRC_RES.db"
DRC SUMMARY REPORT "DRC.rep" 
DRC CHECK TEXT ALL
DRC MAXIMUM RESULTS ALL
//DRC INCREMENTAL CONNECT YES

FLAG OFFGRID YES     // For layout grid check. default grid value is resolution size
FLAG ACUTE YES
FLAG SKEW YES
FLAG NONSIMPLE YES

LAYOUT PROCESS BOX RECORD YES



// DRAWN LAYER DEFINITIONS
//------------------------
LAYER NWELi	2	// Nwell technology
LAYER DIFFi	3	// Active areas
LAYER DOD	1340	// Dummy OD (DIFF)
LAYER MAP 3   DATATYPE 1 1340	// Mapping (3;1) to 1340 for dummy OD
LAYER ODBLK	1350	// DOD blocking for insertion
LAYER MAP 150 DATATYPE 20 1350
LAYER PDIFFi	11	// Active areas
LAYER NDIFFi	12	// Active areas
LAYER OD2i	4	// Define thick gate oxides
LAYER POLYi	13	// Polysilicon gates, interconnect
LAYER DPO	1342	// Dummy Poly
LAYER MAP 13  DATATYPE 1 1342	// Mapping (13;1) to 1342 for dummy PO
LAYER POBLK	1351	// DPO blocking for insertion
LAYER MAP 150 DATATYPE 21 1351
LAYER PPi	7	// P+ S/D imlant
LAYER NPi	8	// N+ S/D imlant
LAYER BJTDUMMY	49	// BJT dummy layer
LAYER DIODUMMY	56	// Diode dummy layer
LAYER COi	15	// Define connection from M1 to S/D and Gate
LAYER M1i	16	// First Metal layer
LAYER VIA1i	17	// Define connection from M2 to M1
LAYER M2i	18	// Second Metal layer
LAYER VIA2i	27	// Define connection from M3 to M2
LAYER M3i	28	// Third Metal layer
LAYER VIA3i	29	// Define connection from M4 to M3
LAYER M4i	31	// Fourth Metal layer
LAYER VIA4i	32	// Define connection from M5 to M4
LAYER M5i	33	// Fifth Metal layer
LAYER VIA5i	39	// Define connection from M6 to M5
LAYER M6i	38	// Sixth Metal layer  
LAYER VIADi	167	// Define connect from MD to Top Metal
LAYER MDi	168	// RDL Metal layer above Top Metal
LAYER CBi	19	// Passivation opening for Bond Pad
LAYER CBDi	169	// Definition of passivation window for bump
LAYER UBMi	170	// Bond Pad definition for RDL
LAYER PPIi	189	// Post Passivation RDL
LAYER RPOi	34	// Salicided Block Layer
LAYER NTNi	129	// Native NMOS blocked implantation
LAYER PLMIDEi	89	// Polymide (if drawn)
//LAYER  FUSEi	235	// Fuse window
LAYER DNWi	82	// Deep N-WELL
LAYER VTMPi	23	// Blocking region of PMOS VT implantation
LAYER VTMNi	24	// Blocking region of NMOS VT implantation
LAYER PV_P	71	// PV_P pmos varactor p+ implant layer
LAYER PV_N	72	// PV_N pmos varactor n+ blocking layer
LAYER HRIi	48	// High Resistor implant


// Dummy Metal layers
//-------------------
LAYER MAP 16  DATATYPE 1 316
LAYER M1DMY	316	// Metal1 dummy (if drawn)
LAYER MAP 18  DATATYPE 1 318
LAYER M2DMY	318	// Metal2 dummy (if drawn)
LAYER MAP 28  DATATYPE 1 329
LAYER M3DMY	329	// Metal3 dummy (if drawn)
LAYER MAP 31  DATATYPE 1 331
LAYER M4DMY	331	// Metal4 dummy (if drawn)
LAYER MAP 33  DATATYPE 1 333
LAYER M5DMY	333	// Metal5 dummy (if drawn)
LAYER MAP 38  DATATYPE 1 338
LAYER M6DMY	338	// Metal6 dummy (if drawn)
LAYER MAP 168 DATATYPE 1 340
LAYER MDDMY	340    	// MD dummy (if drawn)

// Metal Slot layers
//------------------
LAYER MAP 16  DATATYPE 2 321
LAYER M1SLOTi	321	// Metal1 slot (if drawn)
LAYER MAP 18  DATATYPE 2 322
LAYER M2SLOTi	322	// Metal2 slot (if drawn)
LAYER MAP 28  DATATYPE 2 323
LAYER M3SLOTi	323	// Metal3 slot (if drawn)
LAYER MAP 31  DATATYPE 2 324
LAYER M4SLOTi	324	// Metal4 slot (if drawn)
LAYER MAP 33  DATATYPE 2 325
LAYER M5SLOTi	325	// Metal5 slot (if drawn)
LAYER MAP 38  DATATYPE 2 326
LAYER M6SLOTi	326	// Metal6 slot (if drawn)
LAYER MAP 168 DATATYPE 2 328
LAYER MDSLOTi	328	// MD slot (if drawn)

// Capacitor Top Metal Layers
//---------------------------
LAYER MAP 67  DATATYPE 2 257
LAYER CTM2i	257	// Capacitor Top Metal-2
LAYER MAP 67  DATATYPE 3 258
LAYER CTM3i	258	// Capacitor Top Metal-3
LAYER MAP 67  DATATYPE 4 259
LAYER CTM4i	259	// Capacitor Top Metal-4
LAYER MAP 67  DATATYPE 5 260
LAYER CTM5i	260	// Capacitor Top Metal-5

// Dummy Layers
//-------------
LAYER HOTWL	51	// Hot N-Well (SEE README HOT_NWEL NOTES)
LAYER EXCLi	55	// Exclude layer
LAYER DRCDMY	60	// DRC I/O waiver
LAYER RWDMY	52	// NWEL Resistor dummy layer
LAYER DPDMY	65	// Dummy Pad area dummy layer
LAYER PLDMY	66	// Power Line area dummy layer
LAYER SDI	58	// IO ESD region dummy layer
LAYER ESD1DMY	136	// IO ESD region dummy layer, RPO must enclose whole gate
LAYER ESD2DMY	137	// IO ESD region dummy layer, RPO enclose gate 0.05 for 3.3V
LAYER ESD3DMY	234
LAYER CTMDMY	131	// Cover metal as a capacitor bottom plate
LAYER RLPPDMY	134	// HRI high Poly resistor dummy layer
LAYER DMN2V	184	// Dummy layer to ensure N2V in N+ poly/OD resistor
LAYER DMP2V	149	// Dummy layer to ensure P2V in P+ poly/OD resistor
LAYER VARDMY	138	// Dummy layer to cover varactor device
LAYER PMDMY	236	// Dummy layer to cover fuse window and protection ring structur
LAYER FWI	235	// Fuse window when x, (x+1) = 3 
LAYER LMARK	263	// L target window for bump process
LAYER MAP 63  DATATYPE 1 263
LAYER LWI	363	// L target window for bump process
LAYER MAP 63  DATATYPE 2 363
LAYER WBDMY	183	// Dummy layer to cover the CUP pad
LAYER ESDi	30	// For 0.18um 1.8V/5V on i/o esd's implant only.
LAYER INDDMY	364	// Dummy layer to define inductor
LAYER MAP 139 DATATYPE 0 364
LAYER SEALRING	126	// SEAL-RING Layer used for SR.S.1 check
LAYER LOGO	178	// Dummy layer for product labels and LOGO
LAYER LUPWDMY     2551     // DRC dummy layer to waive Latch-Up rules for verified IP.
LAYER MAP 255 DATATYPE 1 2551
LAYER SBDDMY     1440 //A layer for DRC,LVS and creating mask logic operation Use "SBDDMY" to fully cover schottky barrier diode.
LAYER MAP 144 DATATYPE 0 1440
LAYER RFDUMMY     1601    // recognize RF dummy layer for LVS purpose.
LAYER MAP 160 DATATYPE 1 1601



LAYER MAP 189 DATATYPE 101 1891 
LAYER MAP 255 DATATYPE 4   2554
LAYER	VDDDMY 2554
LAYER MAP 255 DATATYPE 5   2555
LAYER	VSSDMY 2555




LAYOUT TOP LAYER M1i VIA1i M1SLOTi M1DMY
LAYOUT TOP LAYER M2i VIA2i M2SLOTi M2DMY
LAYOUT TOP LAYER M3i VIA3i M3SLOTi M3DMY
LAYOUT TOP LAYER M4i VIA4i M4SLOTi M4DMY
LAYOUT TOP LAYER M5i VIA5i M5SLOTi M5DMY
LAYOUT TOP LAYER MDi VIADi MDSLOTi MDDMY M6i M6SLOTi M6DMY CBi 



M1xd = (M1i OR M1DMY) NOT M1SLOTi
M1x  = M1i NOT M1SLOTi
LAYER DM1EXCL	371
LAYER MAP 150 DATATYPE 1 371
M2xd = (M2i OR M2DMY) NOT M2SLOTi
M2x  = M2i NOT M2SLOTi
LAYER DM2EXCL	372
LAYER MAP 150 DATATYPE 2 372
M3xd = (M3i OR M3DMY) NOT M3SLOTi
M3x  = M3i NOT M3SLOTi
LAYER DM3EXCL	373
LAYER MAP 150 DATATYPE 3 373
M4xd = (M4i OR M4DMY) NOT M4SLOTi
M4x  = M4i NOT M4SLOTi
LAYER DM4EXCL	374
LAYER MAP 150 DATATYPE 4 374
M5xd = (M5i OR M5DMY) NOT M5SLOTi
M5x  = M5i NOT M5SLOTi
LAYER DM5EXCL	375
LAYER MAP 150 DATATYPE 5 375
M6xd = (M6i OR M6DMY) NOT M6SLOTi
M6x  = M6i NOT M6SLOTi
LAYER DM6EXCL	376
LAYER MAP 150 DATATYPE 6 376
MDxd = (MDi OR MDDMY) NOT MDSLOTi
Mdx  = MDi NOT MDSLOTi
LAYER DMDEXCL	380
LAYER MAP 150 DATATYPE 15 380

/////////////////////////////////////////////////////////////////////////////////

// EXCLUDE UNCHECKED REGIONS
//--------------------------
CHIP         = EXTENT

BULK	= SIZE CHIP BY 1.0
EXCL = EXCLi NOT LOGO
#IFDEF CHECK_SRAM_EXCL
EXCL_S	= CHIP NOT BULK	// Use an empty layer to disable the usage of EXCL
#ELSE
EXCL_S	= COPY EXCL	// EXCL_S = EXCL
#ENDIF

// Front-End Layer
//----------------
PWELi	= BULK	NOT NWELi
ODi	= (DIFFi OR NDIFFi) OR PDIFFi
PWEL	= PWELi	NOT EXCL
NWEL	= NWELi	NOT INSIDE EXCL
DNW	= DNWi	NOT EXCL
VTMP	= VTMPi	NOT EXCL
VTMN	= VTMNi	NOT EXCL
#IFDEF CHECK_DUMMY_ODPO
OD	= (ODi	OR  DOD) NOT EXCL
POLY	= (POLYi OR DPO) NOT EXCL
#ELSE
OD	= ODi	NOT EXCL
POLY	= POLYi	NOT EXCL
#ENDIF
OD2	= OD2i	NOT EXCL
PP	= PPi	NOT INSIDE EXCL
NP	= NPi	NOT INSIDE EXCL
CO	= COi	NOT EXCL
// Back-End Layer
//---------------
M1	= M1xd	NOT EXCL
M1_A	= M1xd  NOT INSIDE EXCL
VIA1	= VIA1i	NOT EXCL
M2	= M2xd	NOT INSIDE EXCL_S
VIA2	= VIA2i	NOT INSIDE EXCL_S
M3	= M3xd	NOT INSIDE EXCL_S
VIA3	= VIA3i	NOT INSIDE EXCL_S
M4	= M4xd	NOT INSIDE EXCL_S
VIA4	= VIA4i	NOT INSIDE EXCL_S
M5	= M5xd	NOT INSIDE EXCL_S
VIA5	= VIA5i	NOT INSIDE EXCL_S
M6	= M6xd	NOT INSIDE EXCL_S
VIAD	= VIADi	NOT INSIDE EXCL_S
MD	= MDxd	NOT INSIDE EXCL_S
CB	= CBi	NOT EXCL_S
CBD	= CBDi	NOT EXCL_S
RPO	= RPOi	NOT EXCL
NTN	= NTNi	NOT EXCL
PLMIDE	= PLMIDEi NOT EXCL_S
//FUSE	= FUSEi	NOT EXCL
FW	= FWI	NOT EXCL_S
LW	= LWI	NOT EXCL_S
HRI	= HRIi	NOT EXCL
ESD	= ESDi	NOT EXCL_S

CTM2	= CTM2i	NOT EXCL_S
CTM3	= CTM3i	NOT EXCL_S
CTM4	= CTM4i	NOT EXCL_S
CTM5	= CTM5i	NOT EXCL_S




// GLOBAL DERIVED LAYERS FOR RULE CHECKS 
//--------------------------------------

NRODi	= ODi	NOT RPOi
NPODi	= NPi	AND NRODi
PPODi	= PPi	AND NRODi
NONWRi	= NWELi	NOT INTERACT RWDMY	// NWEL - NWR(OD) - NWR(STI)
NTAPi	= NPODi	AND NONWRi	// NWEL Pick-Up
NACTi	= NPODi	NOT NWELi	// NMOS Device
PTAPi	= PPODi	NOT NWELi	// Substrate(PWEL) Pick-Up
PACTi	= PPODi	AND NONWRi	// PMOS Device 
PSDi	= PACTi	NOT POLYi	// PMOS source/drain,separated
NSDi	= NACTi	NOT POLYi	// NMOS source/drain,separated  
ILP1i	= POLYi	NOT RPOi	// Interconnection poly

NPOD	= NP	AND OD		// N+ OD region
PPOD	= PP	AND OD		// P+ OD region
RNWEL	= NWEL	INTERACT RWDMY	// NWEL resistor (UNDER OD & STI)
NONWR	= NWEL	NOT RNWEL	// NWEL - NWR(OD) - NWR(STI)
NTAP	= NPOD	AND NONWR	// NWEL Pick-Up
NACT	= NPOD	NOT NWEL	// NMOS Device
PTAP	= PPOD	NOT NWEL	// Substrate(PWEL) Pick-Up
PACT	= PPOD	AND NWEL	// PMOS Device

DACT	= NACT OR PACT		// NMOS and PMOS Device
DSTP	= NTAP OR PTAP		// NWEL and PWEL Pick-Up
IMP	= PP OR NP		// N+ and P+ implant 
ALL_GATE = POLY AND OD		// Gate regions for NMOS and PMOS
POLY_ISO = POLY NOT OD		// Interconnect POLY
LVGT	= ALL_GATE NOT OD2	// 1.8V gate
HVGT	= ALL_GATE AND OD2	// 3.3V gate
GATE_W	= POLY INSIDE EDGE OD	// Gate width
GATE_L	= OD INSIDE EDGE POLY	// Channel length
GATE_NP	= ALL_GATE AND NP	// N+ Gate
GATE_PP	= ALL_GATE AND PP	// P+ Gate

FPO1	= COPY POLY_ISO		// Field poly
RPO_NOT_SDI = RPO NOT SDI
PORES	= FPO1 AND RPO_NOT_SDI	// POLY resistor region
ILP1	= POLY_ISO NOT RPO	// Interconnection poly
FFOD	= (OD OUTSIDE RWDMY) OUTSIDE ALL_GATE
ODRES	= FFOD AND RPO_NOT_SDI	// OD resistor region
HRDMY	= (DMP2V OR DMN2V) OR RLPPDMY	// High resistance poly resistor dummy layer for DRC
HREP	= PORES AND HRDMY		// High precision and resistacne poly resistor

HVN_GOX    = NPOD AND OD2	// Device n-type diffusion for thick gate NMOS
HVP_GOX    = PPOD AND OD2	// Device p-type diffusion for thick gate PMOS
HV_NGATE_W = GATE_W INSIDE EDGE HVN_GOX	// 3.3V NMOS gate edges
HV_PGATE_W = GATE_W INSIDE EDGE HVP_GOX	// 3.3V PMOS gate edges

BUTT_NTAP  = NTAP TOUCH PACT		// NWEL Tap butting p-type active diffusion
NONB_NTAP  = NTAP NOT TOUCH PACT	// Non-butting ntap
BUTT_PTAP  = PTAP TOUCH NACT		// PWEL Tap butting n-type active diffusion
NONB_PTAP  = PTAP NOT TOUCH NACT	// Non-butting ptap 
PP_BEDGE   = BUTT_PTAP COIN EDGE NACT	// PP edge to form butted tap
NP_BEDGE   = BUTT_NTAP COIN EDGE PACT	// NP edge to form butted tap
OD2_BEDGE  = OD2 INSIDE EDGE OD

ACT_OD	= OD INTERACT POLY
PNSD	= ACT_OD NOT ALL_GATE
SDPO2	= PNSD INTERACT POLY == 2	// S/D between two Poly gate

CO_DIFF	= CO OUTSIDE POLY_ISO		// Diffusion contacts + floating contacts
CO_POLY	= CO NOT OUTSIDE POLY_ISO	// POLY contacts
ASD1	= PNSD ENCLOSE CO_DIFF

// For checks such as PP.C.4/C.5, NP.C.4/C.5.
EXGATE_NP  = SIZE ((SIZE GATE_NP BY 0.03) AND POLY) BY 0.32
EXGATE_PP  = SIZE ((SIZE GATE_PP BY 0.03) AND POLY) BY 0.32
FUSE_LMARK = (CB OR FW) OR LW
RNGX       = PMDMY NOT FUSE_LMARK

CHIP_CORE = SIZE CHIP BY -10
PADH      = HOLES CB
SCORE     = CHIP_CORE INSIDE PADH
SR_CHIP   = CHIP INTERACT SCORE
SR = SR_CHIP NOT (SIZE SR_CHIP BY -10)
SR_CB = CB AND SR
SR_CO     = CO AND SR
SR_VIA1     = VIA1 AND SR
SR_VIA2     = VIA2 AND SR
SR_VIA3     = VIA3 AND SR
SR_VIA4     = VIA4 AND SR
SR_VIA5     = VIA5 AND SR
SR_VIAD     = VIAD AND SR

SBDOD    = ( OD AND SBDDMY ) AND NWEL

NW_SBD   = NWEL INTERACT SBDOD
DNW_SBD   = DNW INTERACT SBDOD

PP_SBD   = PP INTERACT SBDOD 
PP_SBD_HOLE = HOLES PP_SBD INNER
PP_SBD_ALL = PP_SBD OR PP_SBD_HOLE

PP_NSBD = PP NOT PP_SBD

PPOD_SBD = SBDOD INTERACT PP
NPOD_SBD = SBDOD AND NP

PPOD_SBD_GAP = EXPAND EDGE PPOD_SBD OUTSIDE BY 0.48
PPOD_SBD_G   = PPOD_SBD_GAP TOUCH NPOD_SBD
NPOD_SBD_GAP = EXPAND EDGE NPOD_SBD OUTSIDE BY 0.48
NPOD_SBD_G   = NPOD_SBD_GAP TOUCH PPOD_SBD

SBDOD_ALL = ( PPOD_SBD OR NPOD_SBD ) OR PPOD_SBD_G 

PPOD_SBD_W = PPOD_SBD TOUCH OUTSIDE EDGE NPOD_SBD_G
PPOD_SBD_L = PPOD_SBD NOT TOUCH OUTSIDE EDGE NPOD_SBD_G
NPOD_SBD_W = NPOD_SBD TOUCH OUTSIDE EDGE PPOD_SBD_G

CHIPx        = MERGE CHIP
VARIABLE  GRID      0.005
// BUILD CONNECTION FOR RULE CHECKS 
//---------------------------------
CONNECT	NTAPi NWELi
CONNECT	NTAPi PSDi
CONNECT	PTAPi NSDi
CONNECT	M1xd ILP1i NTAPi PTAPi PSDi NSDi BY COi
CONNECT	M1xd M2xd BY VIA1i
CONNECT	M2xd M3xd BY VIA2i
CONNECT	M3xd M4xd BY VIA3i
CONNECT	M4xd M5xd BY VIA4i
VIAt	= VIA5i NOT INTERACT CTM5i
VIAc	= VIA5i AND CTM5i
CONNECT	M5xd  M6xd BY VIAt 
CONNECT	CTM5i M6xd BY VIAc
CONNECT	M6xd  MDxd BY VIADi



HRI.WARN { @ RLPPDMY overlap OD is not allowed
  RLPPDMY AND OD   
}


//************************************************************************************* 
//
//  warning messages to check whether some switchs are used corretly or not. 
//
//*************************************************************************************
//======================================================================================
// 1. Process selection warning.
//======================================================================================
#IFNDEF MIX_MODE
WARN.PROCESS_1 { @ MIX_MODE switch should be turned on for Mixed Singal/RF process

    MM_LAYERS = (((( CTM5i OR INDDMY ) OR  HRIi ) OR DNWi ) OR VTMPi ) OR VTMNi
    CHIPx INTERACT MM_LAYERS 
}
#ENDIF

#IFDEF MIX_MODE
#IFNDEF 1.8V
WARN.PROCESS_2 { @ Pls turn on (#DEFINE 1.8V) switch if you use Mixed Singal/RF process
     COPY CHIPx 
}
#ENDIF
#IFNDEF 3.3V
WARN.PROCESS_3 { @ Pls turn on (#DEFINE 3.3V) switch if you use Mixed Singal/RF process
     COPY CHIPx 
}
#ENDIF
#IFDEF LP
WARN.PROCESS_4 { @ Pls turn off (#DEFINE LP) switch if you use Mixed Singal/RF process. 
                 @ Low power is not supported in Mixed Signal process 
     COPY CHIPx 
}
#ENDIF
#IFDEF 1.5V
WARN.PROCESS_5 { @ Pls turn off (#DEFINE 1.5V) switch if you use Mixed Singal/RF process
                 @ Low voltage is not supported in Mixed Signal process
     COPY CHIPx 
}
#ENDIF
#IFDEF 5V
WARN.PROCESS_6 { @ Pls turn off (#DEFINE 5V) switch if you use Mixed Singal/RF process
                 @ 1.8V/5V is not supported in Mixed Signal process
     COPY CHIPx 
}
#ENDIF
#ENDIF

#IFDEF C016
#IFDEF 5V
WARN.PROCESS_7 { @ Pls turn off (#DEFINE 5V) switch if you use 0.16um process
                 @ 1.8V/5V is not supported in 0.16um process
     COPY CHIPx 
}
#ENDIF
#IFDEF 1.5V
WARN.PROCESS_8 { @ Pls turn off (#DEFINE 1.5V) switch if you use 0.16um process
                 @  Low voltage is not supported in 0.16um process
     COPY CHIPx 
}
#ENDIF
#IFDEF LP
WARN.PROCESS_9 { @ Pls turn off (#DEFINE LP) switch if you use 0.16um process
                 @  Low power is not supported in 0.16um process
     COPY CHIPx 
}
#ENDIF
#ENDIF

#IFDEF LP
#IFDEF 1.5V
WARN.PROCESS_10 { @ Pls turn off (#DEFINE 1.5V) switch if you use 0.18um Low power process
     COPY CHIPx 
}
#ENDIF
#ENDIF

//======================================================================================
// 2. Voltage selection warning.
//======================================================================================

#IFNDEF 3.3V
#IFNDEF 2.5V
#IFNDEF 5V
WARN.VOLTAGE_1 { @ There must be specified an option of HIGH_VOLTAGE
  COPY CHIPx
}
#ENDIF
#ENDIF
#ENDIF

#IFNDEF 1.8V
#IFNDEF 1.5V
WARN.VOLTAGE_2 { @ There must be specified an option of CORE_VOLTAGE
  COPY CHIPx
}
#ENDIF
#ENDIF

#IFDEF 3.3V
#IFDEF 2.5V
WARN.VOLTAGE_3 { @ Only one HIGH_VOLTAGE can be specified every time. 
  COPY CHIPx
}
#ENDIF
#IFDEF 5V
WARN.VOLTAGE_4 { @ Only one HIGH_VOLTAGE can be specified every time.
  COPY CHIPx
}
#ENDIF
#ENDIF


#IFDEF 1.8V
#IFDEF 1.5V
WARN.VOLTAGE_5 { @ Only one CORE_VOLTAGE can be specified every time.
  COPY CHIPx
}
#ENDIF
#ENDIF

#IFDEF 1.8V
#IFDEF 2.5V
WARN.VOLTAGE_6 { @ 1.8V and 2.5V can not be specified at the same time.
  COPY CHIPx
}
#ENDIF
#ENDIF

#IFDEF 1.5V
#IFDEF 5V
WARN.VOLTAGE_7 { @ 1.5V and 5V can not be specified at the same time.
  COPY CHIPx
}
#ENDIF
#ENDIF


//======================================================================================
// 3. Thick top metal selection warning
//======================================================================================
#IFNDEF MIX_MODE
#IFDEF THICK_40K
WARN.THICK_TOP_METAL_1 { @ 20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process, 
                         @ Other processes are not provided in this design rule.
  COPY CHIPx 
}
#ENDIF
#IFDEF THICK_20K
WARN.THICK_TOP_METAL_2 { @ 20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process, 
                         @ Other processes are not provided in this design rule.
  COPY CHIPx 
}
#ENDIF
#ENDIF

#IFDEF C016
#IFDEF THICK_40K
WARN.THICK_TOP_METAL_3 { @ 20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process, 
                         @ Other processes are not provided in this design rule.
  COPY CHIPx 
}
#ENDIF
#IFDEF THICK_20K
WARN.THICK_TOP_METAL_4 { @ 20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process, 
                         @ Other processes are not provided in this design rule.
  COPY CHIPx 
}
#ENDIF
#ENDIF

#IFDEF THICK_40K
#IFDEF THICK_20K
WARN.THICK_TOP_METAL_5 { @ 20KA and 40KA UTM only provide for 0.18um 1.8V/3.3V MM/RF process, 
                         @ and 20KA and 40KA should not be placed in the same chip.
  COPY CHIPx 
}
#ENDIF
#ENDIF
//======================================================================================
// 4. DNW warning
//======================================================================================

#IFNDEF MIX_MODE
WARN.DNW { @ DNW only provide for MM/RF process
  COPY DNWi 
}
#ENDIF

//======================================================================================
// 5. NTN warning
//======================================================================================

#IFDEF 5V
WARN.NTN_1 { @ NTN devices don't provide for 0.18um 1.8V/5V General purpose,Low Power and 
             @ 1.8V/3.3V Low Power process 
  COPY NTNi 
}
#ENDIF

#IFDEF LP
#IFDEF 3.3V
WARN.NTN_2 { @ NTN devices don't provide for 0.18um 1.8V/5V General purpose,Low Power and 
               @ 1.8V/3.3V Low Power process 
  COPY NTNi 
}
#ENDIF
#ENDIF


//======================================================================================
// 6. HRI warning
//======================================================================================

#IFDEF C016 
WARN.HRI { @ HRI only provide for 0.18um MM/RF process
  COPY HRIi 
}
#ENDIF



// NWEL CHECKS
//=============
HOT_NWEL = (NWEL AND HOTWL) OR RNWEL

NW.W.1 { @ Min. NWEL width < 0.86
  INT NWEL < 0.86 ABUT < 90 SINGULAR REGION
}
NW.W.2 { @ Min. HOT_NWEL width < 2.10
  INT HOT_NWEL < 2.10 ABUT < 90 SINGULAR REGION
}
NW.S.1 { @ Min. different potential NWEL space < 1.40
  NWEL_NODAL = STAMP NWEL BY NWELi
  EXT NWEL_NODAL < 1.40 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT RNWEL NWEL < 1.40 ABUT < 90 SINGULAR REGION
  EXT RNWEL < 1.40 ABUT < 90 SINGULAR REGION
}
NW.S.2 { @ Min. same potential NWEL space < 0.6
  EXT NWEL < 0.60 ABUT < 90 SINGULAR REGION
}



// NWEL (within OD) RESISTOR CHECKS
//====================================

NWRES = RNWEL INTERACT RPO      // NWEL resistor (UNDER OD)
ODWR  = OD INTERACT NWRES       // OD area of NW resistor
NPWR  = NP INTERACT NWRES       // N+ implant on NW resistor terminals
COWR  = CO_DIFF INTERACT NWRES  // Contact on NW resistor terminals
RHWR  = ODWR NOT RPO            // Non-Salicided area of NW resistor
RPONWR_H =  HOLES RPO INNER

NWR.E.1 {@ Min. OD enclose NWEL resistor < 1.0
  ENC NWRES ODWR < 1.0 ABUT < 90 SINGULAR REGION
  NWRES CUT ODWR    
}
NWR.E.2 {@ Min. NWEL resistor enclose CO < 0.3
  ENC COWR NWRES < 0.3 ABUT < 90 SINGULAR REGION
  COWR CUT NWRES    
}
NWR.C.1 {@ Min. RPO hole enclose NWEL < 0.3
  ENC NWRES RHWR < 0.3 ABUT < 90 SINGULAR REGION
}
NWR.C.2 {@ Min. RPO enclose OD (with NWEL resistor) < 0.22
  ENC ODWR RPO < 0.22 ABUT < 90 SINGULAR REGION
}
NWR.C.3 {@ Min. RPO hole enclose NWEL resistor CO < 0.3
  ENC COWR RHWR < 0.3 ABUT < 90 SINGULAR REGION
  COWR CUT RHWR    
}
NWR.O.1 {@ Min. RPO overlap NP < 0.4
  INT NPWR RPO < 0.4 ABUT < 90 SINGULAR REGION
  X = RPO INTERACT NWRES
  H = HOLES X INNER
  H NOT NPWR
}
NWR.R.1 {@ NW resistor doped by implants not allowed.
  RWDMY AND NPOD
  RWDMY AND PPOD
}
//NWEL under STI
NWRES_STI = RNWEL NOT INTERACT RPO	// NWEL resistor (UNDER STI)
ODWR_STI  = OD INTERACT NWRES_STI
NPWR_STI  = NP INTERACT NWRES_STI
NWR.E.3 { @ Min. extension of NP to OD (NWEL resistor under STI) 0.18 um
  ENC ODWR_STI NPWR_STI < 0.18 ABUT < 90 SINGULAR REGION
  ODWR_STI NOT NPWR_STI
}

NWR.R.3{@ Only one NW inside NWROD is allowed in one OD.
   A = ODWR INTERACT (NWRES AND ODWR)>1
   NWRES INTERACT A
}  

NWR.R.4{@ Only two NPS in NWROD is allowed in one od.
 C = ODWR INTERACT (NP INTERACT NWRES) != 2
 NP INTERACT C
 ODWR NOT INTERACT ( NP INTERACT NWRES)
}

NWR.R.5 { @ ONLY TWO RPO HOLES IN NWROD ARE ALLOWED.
   A = ODWR INTERACT RPONWR_H != 2
   D = ODWR NOT INTERACT RPONWR_H
   RPONWR_H INTERACT (A OR D)
}  

NWR.R.6 { @ For U-shape or S-shape NWROD, both OD and NW must be U-shape or S-shape and the OD edge must be 
    	  @ parallel to the NW edge. DRC can only flag the pattern without OD space while 2 edges of NW 
	  @ [NW space or notch <= 5 um] parallel length > 0 um
  A = (EXT NWRES < 5 OPPOSITE REGION NOTCH) NOT NWRES
  A INSIDE ODWR      
} 





#IFNDEF 5V
// NT_N
//======

NTN_OD = OD NOT OUTSIDE NTN
NTN_PO = POLY AND NTN
NTN_GATE_W = NTN_PO INSIDE EDGE NTN_OD
NTN_PO_W   = (NTN_PO INTERACT (CO OR OD)) COIN INSIDE EDGE POLY

NT_N.I.1 {@ NT_N interact DNW is not allowed. (Butted is allowed)
  NTN AND DNW
}
NT_N.I.2 {@ only one OD region allowed to be put in an NT_N region
  NTN ENCLOSE OD > 1
}
NT_N.I.3 {@ A P+GATE is not allowed to be put in an NT_N region
  NTN AND GATE_PP
}
NT_N.I.4 {@ A bent poly region is not allowed to put in an NT_N region
  EXT NTN_PO_W < 0.18 ABUT == 90 INTERSECTING ONLY
  INT NTN_PO_W < 0.18 ABUT == 90 INTERSECTING ONLY
  EXT NTN_PO_W < 0.18 ABUT == 135 INTERSECTING ONLY
  INT NTN_PO_W < 0.18 ABUT == 135 INTERSECTING ONLY
}
NT_N.W.1 {@ For CL018G 1.8V/3.3V & CL018LV 1.5V/2.5V,minimum dimension of a NT_N region <0.74
  INT NTN < 0.74 ABUT < 90 SINGULAR REGION
}
#IFDEF 1.5V
#IFDEF 3.3V
NT_N.W.1_1.5_3.3V {@ For CL018LV 1.5V/3.3V, minimum dimension of a NT_N region.<0.86
  INT NTN < 0.86 ABUT < 90 SINGULAR REGION
}
#ENDIF
#ENDIF

#IFDEF 1.8V
#IFDEF C016
NTN.W.2 {@ Minimum poly gate dimension(channel length) of a 1.8V blocked NT_N device < 0.55
  INT NTN_GATE_W < 0.55 ABUT < 90 REGION
}

#ENDIF
#IFNDEF C016
NT_N.W.2_LV {@ Minimum Poly gate dimension of a 1.8V blocked NT_N device < 0.5
  INT NTN_GATE_W < 0.5 ABUT < 90 REGION
}
#ENDIF
#ENDIF
#IFDEF 1.5V
NT_N.W.2.LV {@ For CL018G,CL018LV 1.5/2.5V & 1.5/3.3V, minimum Poly gate dimension of a 1.5V blocked NT_N device < 0.37
  INT NTN_GATE_W < 0.37 ABUT < 90 REGION
}
NT_N.W.2_HV   {@ For CL018G,CL018LV 1.5/2.5V & 1.5/3.3V, minimum Poly gate dimension of a {2.5V or 3.3V} blocked NT_N device < 1.2
  Z = NTN_GATE_W INSIDE EDGE OD2
  INT Z < 1.2 ABUT < 90 REGION
}
#ENDIF

#IFNDEF C016
#IFDEF 3.3V
NT_N.W.2_3.3V {@ For CL018G,CL018LV 1.5/2.5V & 1.5/3.3V, minimum Poly gate dimension of a {2.5V or 3.3V} blocked NT_N device < 1.2
  Z = NTN_GATE_W INSIDE EDGE OD2
  INT Z < 1.2 ABUT < 90 REGION
}
#ENDIF
#ENDIF

#IFDEF C016
NTN.W.2B {@ Minimum poly gate dimension (channel length) of a 3.3V blocked NT_N device < 1.32
  Z = NTN_GATE_W INSIDE EDGE OD2
  INT Z < 1.32 ABUT < 90 REGION
}
NTN.W.3 {@ Minimum OD width of 1.8V/3.3V blocked NT_N device < 0.245
  A = NTN_OD INTERACT NTN_PO 
  INT A < 0.245 ABUT < 90 REGION
}
#ENDIF

NT_N.S.1 {@ Minimum space between two NT_N regions < 0.86
  EXT NTN < 0.86 ABUT < 90 SINGULAR REGION
}

NT_N.E.1 {@ Maximum and Minimum extension from NT_N region beyond an NP OD region 0.26
  A = NTN INTERACT NPOD
  B = NPOD INTERACT NTN
  C = SIZE B BY 0.26
  D = SIZE A BY -0.26
  A XOR C
  B XOR D
}
#IFDEF 1.5V
NT_N.E.2.LV {@ For CL018LV 1.5V/2.5V & 1.5V/3.3V, minimum extension from OD2 edge to geomAnd {2.5V or 3.3V} 
             @ NT_N region inside OD2 < 0.86um
  ENC NTN OD2 < 0.86 ABUT < 90 SINGULAR REGION
  NTN CUT OD2
}
#ENDIF
NT_N.C.1 {@ MInimum clearance from NT_N to OD < 0.52
  EXT OD NTN < 0.52 ABUT < 90 SINGULAR REGION
  OD CUT NTN    
}
NT_N.C.2 {@ Minimum clearance frome a NT_N region to NWEL edge < 1.66
  EXT NTN NWEL < 1.66 ABUT < 90 SINGULAR REGION
  NTN AND NWEL    
}
#IFDEF 1.5V
NT_N.C.3.LV { @ For CL018LV 1.5/2.5V & 1.5/3.3V, minimum clearance from 1.5V
              @ NT_N region to OD2 edge < 0.86um
  EXT NTN OD2 < 0.86 ABUT < 90 SINGULAR REGION
}
#ENDIF
NT_N.PO.1 {@ Minimum overlap of a PO region extended into field oxide(endcap) < 0.35
  ENC NTN_OD POLY < 0.35 ABUT < 90 SINGULAR REGION
}
#ENDIF  //#IFNDEF or IFDEF 5V


// OD CHECKS
//==============
OD.W.1_OD.W.2 { @ Min. OD width for MOS and interconnect < 0.22
  INT OD < 0.22 ABUT < 90 SINGULAR REGION
}
OD.S.1 { @ Min. OD space < 0.28
  EXT OD < 0.28 ABUT < 90 SINGULAR REGION 
}
OD.C.1 { @ Min. NWEL olap NPOD tie down < 0.12
  ENC NPOD NONWR < 0.12 ABUT < 90 SINGULAR REGION
  NPOD CUT NONWR    
}
OD.C.2_OD.C.3 { @ Min. NWEL to NPOD space < 0.43
  A = NPOD NOT INSIDE NWEL
  X = A NOT ODWR
  EXT X NWEL < 0.43 ABUT < 90 SINGULAR REGION
  X CUT NWEL
}
OD.C.4 { @ NWEL overlap PPOD < 0.43
  ENC PPOD NWEL < 0.43 ABUT < 90 SINGULAR REGION
  PPOD CUT NWEL    
}
OD.C.5 { @ NWEL space PPOD outside NW < 0.12
  EXT PTAP NWEL < 0.12 ABUT < 90 SINGULAR REGION
}
// OD.C.6 is checked by PP.C.5 and NP.C.5
// OD.S.2 is not necessary to check
OD.W.3 { @ Length of active with width < 0.42, connected to butted strap > 0.8
  SD = (DACT INTERACT ALL_GATE) NOT ALL_GATE
  NP_PP_BTE = NPOD COIN OUTSIDE EDGE PPOD  
  BUTTED_EDGE = LENGTH NP_PP_BTE < 0.42
  CHECK_SD = SD WITH EDGE BUTTED_EDGE
  NARROW_SD = INT (CHECK_SD COIN INSIDE EDGE OD) < 0.42 ABUT < 90 OPPOSITE REGION 
  CHECK_OD = (NARROW_SD WITH EDGE BUTTED_EDGE) OR (NARROW_SD WITH EDGE GATE_W)
  PATH LENGTH (OD COIN INSIDE EDGE CHECK_OD) > 0.8
}
OD.A.1 { @ Min. area of stand-alone OD region < 0.202
  OD AREA < 0.202
}


#IFDEF 5V

// 5V OD CHECKS
//==============
OD.C.2.1_OD.C.3.1 { @ Minimum clearance from NWEL edge to N+OD which interacts OD2 < 0.6
  X = (NPOD NOT INSIDE NWEL) NOT ODWR
  Y = X INTERACT OD2
  EXT Y NWEL < 0.6 ABUT < 90 SINGULAR REGION
}
OD.C.4.1 { @ Minimum clearance from NWEL edge to P+OD which interacts OD2 < 0.8
  X = PPOD INTERACT OD2
  ENC X NWEL < 0.8 ABUT < 90 SINGULAR REGION
}

#ENDIF


// OD2 CHECKS
//===============
DACTG = DACT OR ALL_GATE
OD2.E.1 { @ Minimum extension of an OD2 region beyond an {active OD OR Gate} region>=0.32um
  CHECK_EDGE = ENC [DACTG] OD2 < 0.32 ABUT < 90 SINGULAR 
  CHECK_EDGE NOT COIN OUTSIDE EDGE DSTP 
  OD2 INSIDE DACTG		// OD2 totally inside OD
}
#IFNDEF 5V
#IFDEF 1.8V
OD2.S.1 { @ For two well process (1.8V/3.3V C018G), minimum space between two OD2
          @ regions. Merge if the space is less than 0.45um.>=0.45um
  EXT OD2 < 0.45 ABUT < 90 SINGULAR REGION
}
#ENDIF
#ENDIF
#IFDEF 1.5V
OD2.S.1.LV { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
        	@ C018LP, 1.8V/5.0V C018G/LP, minimum space between two OD2 regions.
                @ Merge if the space is less than 0.86um.
  EXT OD2 < 0.86 SINGULAR ABUT <90 REGION
}
#ENDIF
#IFDEF 5V
OD2.S.1.5V { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
        	@ C018LP, 1.8V/5.0V C018G/LP, minimum space between two OD2 regions.
                @ Merge if the space is less than 0.86um.
  EXT OD2 < 0.86 SINGULAR ABUT <90 REGION
}
#ENDIF
#IFDEF LP
OD2.S.1.LP { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
        	@ C018LP, 1.8V/5.0V C018G/LP, minimum space between two OD2 regions.
                @ Merge if the space is less than 0.86um.
  EXT OD2 < 0.86 SINGULAR ABUT <90 REGION
}
#ENDIF

OD2.C.1 { @ Minimum clearance between OD region and an OD2 region>=0.32um
  EXT OD2 NACT < 0.32 SINGULAR ABUT <90 REGION
  EXT OD2 PACT < 0.32 SINGULAR ABUT <90 REGION
}
OD2.C.2 { @ Minimum clearance between OD2 region and {1.5V or 1.8V} transistor gate
          @ poly>= 0.4um
  A = OD2 INSIDE EDGE DACT
  EXT A GATE_W < 0.40 ABUT <90 REGION
}
OD2.E.2 { @ Minimum extension of OD2 region beyond {2.5V or 3.3V or 5V} transistor
          @ gate poly in the source/drain OD direction OD2 cut poly GATE is not
          @ allowed. >=0.4um
  ENC GATE_W OD2_BEDGE < 0.40 ABUT < 90 REGION 
  ALL_GATE CUT OD2    
}
#IFDEF 1.5V
OD2.E.4.LV { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
             @ C018LP, 1.8V/5.0V C018G/LP, minimum extension of an OD2 region
             @ beyond an NW region>=0.86um. Align if space is less than 0.86um
  ENC NWEL OD2 < 0.86 ABUT>0<90 SINGULAR REGION
}
OD2.C.4.LV { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
             @ C018LP, 1.8V/5.0V C018G/LP>=0.86um, minimum clearance between an OD2 region
             @ and an NW region. Align if space is less than 0.86um
  EXT NWEL OD2 < 0.86 ABUT>0<90 SINGULAR REGION
  ENC OD2 NWEL < 0.86 ABUT>0<90 SINGULAR REGION
}
OD2.O.1.LV { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
             @ C018LP, 1.8V/5.0V C018G/LP>=0.86um minimum overlap between OD2 and NWEL >= 0.86um
  INT NWEL OD2 < 0.86 ABUT>0<90 SINGULAR MEASURE COINCIDENT REGION
}
#ENDIF

#IFDEF 5V
OD2.E.4.5V { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
             @ C018LP, 1.8V/5.0V C018G/LP, minimum extension of an OD2 region
             @ beyond an NW region>=0.86um. Align if space is less than 0.86um
  ENC NWEL OD2 < 0.86 ABUT>0<90 SINGULAR REGION
}
OD2.C.4.5V { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
             @ C018LP, 1.8V/5.0V C018G/LP>=0.86um, minimum clearance between an OD2 region
             @ and an NW region. Align if space is less than 0.86um
  EXT NWEL OD2 < 0.86 ABUT>0<90 SINGULAR REGION
  ENC OD2 NWEL < 0.86 ABUT>0<90 SINGULAR REGION
}
OD2.O.1.5V { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
             @ C018LP, 1.8V/5.0V C018G/LP>=0.86um minimum overlap between OD2 and NWEL >= 0.86um
  INT NWEL OD2 < 0.86 ABUT>0<90 SINGULAR MEASURE COINCIDENT REGION
}
#ENDIF

#IFDEF LP
OD2.E.4.LP { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
             @ C018LP, 1.8V/5.0V C018G/LP, minimum extension of an OD2 region
             @ beyond an NW region>=0.86um. Align if space is less than 0.86um
  ENC NWEL OD2 < 0.86 ABUT>0<90 SINGULAR REGION
}
OD2.C.4.LP { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
             @ C018LP, 1.8V/5.0V C018G/LP>=0.86um, minimum clearance between an OD2 region
             @ and an NW region. Align if space is less than 0.86um
  EXT NWEL OD2 < 0.86 ABUT>0<90 SINGULAR REGION
  ENC OD2 NWEL < 0.86 ABUT>0<90 SINGULAR REGION
}
OD2.O.1.LP { @ For four well process 1.5V/3.3V C018LV, 1.5V/2.5V C018LV, 1.8V/3.3V
             @ C018LP, 1.8V/5.0V C018G/LP>=0.86um minimum overlap between OD2 and NWEL >= 0.86um
  INT NWEL OD2 < 0.86 ABUT>0<90 SINGULAR MEASURE COINCIDENT REGION
}
#ENDIF



// POLY checks
//=============
//PO.W.1A is checked by PO.W.3
//PO.W.2A is checked by PO.W.3

PO.W.3 { @ Min. POLY width for interconnect, 1.8V NMOS, 1.8V PMOS < 0.18
  INT POLY < 0.18 ABUT < 90 SINGULAR REGION
}
#IFDEF 3.3V
PO.W.1_3.3V { @ Min. POLY gate length 3.3V pmos < 0.30
  INT HV_PGATE_W < 0.30 ABUT < 90 REGION
}
PO.W.2_3.3V { @ Min. POLY gate length 3.3v nmos < 0.35
  INT HV_NGATE_W < 0.35 ABUT < 90 REGION
}
#ENDIF
#IFDEF 2.5V
PO.W.1_2.5V { @ Min. POLY gate length 2.5V pmos < 0.26
  INT HV_PGATE_W < 0.26 ABUT < 90 REGION
}
PO.W.2_2.5V { @ Min. POLY gate length 2.5v nmos < 0.26
  INT HV_NGATE_W < 0.26 ABUT < 90 REGION
}
#ENDIF
#IFDEF 5V
PO.W.1_5V { @ Min. POLY gate length 5.0V pmos < 0.5
  INT HV_PGATE_W < 0.5 ABUT < 90 REGION
}
PO.W.2_5V { @ Min. POLY gate length 5.0v nmos < 0.6
  INT HV_NGATE_W < 0.6 ABUT < 90 REGION
}
#ENDIF
PO.S.1 { @ Min. POLY space on OD with contact < 0.375
  Y = ALL_GATE COINCIDENT OUTSIDE EDGE ASD1
  EXT Y < 0.375 ABUT < 90 REGION
}
PO.S.2_PO.S.3 { @ Min. POLY space: on OD w/o contact and interconnect < 0.25
  EXT POLY < 0.25 ABUT < 90  SINGULAR REGION
}
PO.C.1 { @ Min. POLY on field space to active < 0.1
  EXT POLY OD < 0.1 ABUT < 89.5 SINGULAR REGION
}
PO.C.2 { @ Min. OD overhang gate < 0.32
  ENC POLY OD < 0.32 ABUT < 89.5 SINGULAR REGION
}
PO.O.1 { @ Min. POLY overhang active < 0.22
  ENC OD POLY < 0.22 ABUT < 89.5 SINGULAR REGION
}
#IFNDEF MIX_MODE
PO.R.1A { @ 90 degree gate not allowed/L and U shape gate are not allowed
      // 0.18 value is arbitrary, note the angle
  EXT GATE_W < 0.18 ABUT == 90 INTERSECTING ONLY
  INT GATE_W < 0.18 ABUT == 90 INTERSECTING ONLY
}
#ENDIF

PO.R.1B { @ 45 degree 1.8V gate min. length < 0.21
  INT LVGT < 0.21 ANGLED == 2 OPPOSITE REGION
}
PO.R.2 { @ Max. POLY length between contacts when PO width less than 0.24um > 50.00
  LONG_PO = AREA ILP1 > 0.18*50
  CHECK_PO = LONG_PO INTERACT CO
  CHECK_CO = CO INTERACT CHECK_PO
  CO_A = SIZE CHECK_CO BY 50 / 2 INSIDE OF CHECK_PO STEP 0.25 
  PO_A = CHECK_PO INTERACT CO_A == 1
  PO_B = CHECK_PO INTERACT CO_A > 1
  CO_B = CO_A INTERACT PO_A
  CO_C = SIZE CO_B BY 50 / 2 INSIDE OF PO_A STEP 0.25 
  BAD = (PO_A NOT CO_C) OR (PO_B NOT CO_A)
  BAD_EDGE = BAD COIN INSIDE EDGE POLY
  ERROR = INT BAD_EDGE <= 0.24 ABUT < 90 REGION
  CHECK_PO INTERACT ERROR
}



// Poly/OD Resistor CHECK
//==========
#IFDEF Recommend
RES.2_PO {@ For poly resistor, it is strongly recommended that the poly resistor width >= 1.0um,
        @ length >= 5.0um, and the resistor square number Nsq >= 5,
	@ DRC will check the width and length 1um and 5um for poly resistor & 2um and 10um for OD resistor, 
	@ respectively. Nsq is un-checkable   
  PORESC = PORES NOT INTERACT RLPPDMY	  
  INT PORESC < 1.0 ABUT < 90 SINGULAR REGION
  RES_L = PORESC COIN INSIDE EDGE POLY
  X = PATH LENGTH RES_L < 5.0
  CHECK_RES = PORESC WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE RPO
  A = EXPAND EDGE RES_E INSIDE BY 0.005
  B = SIZE A BY ( 5.0/2 - 0.005*2 ) INSIDE OF PORESC STEP 0.175
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < 0.005*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}
RES.2_OD {@ For OD resistor, it is strongly recommended that the resistor width>=2.0 um and the resistor square number Nsq g 5.
	@ DRC will check the width and length 1um and 5um for poly resistor & 2um and 10um for OD resistor, 
	@ respectively. Nsq is un-checkable   
  ODRESC = ODRES NOT INTERACT RLPPDMY	  
  INT ODRESC < 2.0 ABUT < 90 SINGULAR REGION
  RES_L = ODRESC COIN INSIDE EDGE OD
  X = PATH LENGTH RES_L < 10.0
  CHECK_RES = ODRESC WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE RPO
  A = EXPAND EDGE RES_E INSIDE BY 0.005
  B = SIZE A BY ( 10.0/2 - 0.005*2 ) INSIDE OF ODRESC STEP 0.196
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < 0.005*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}
// For RES.2, "Nsq >= 5" can not be checked by DRC
DMPN2V = DMP2V OR DMN2V
RES.3_PO { @ The sheet resistance in SPICE model of non-salicided N+/P+ PO/OD resistors is
        @ resulted from N2V/NP and P2V/PP combinations, respectively. To obtain precise resistance,
	@ dummy layers (DMN2V & DMP2V) are required.N2V/P2V/N3V/P3V/N5V/P5V are derived from logical operation, 
	@ please ensure correct implants in caes the rsistor traverses NW/PW,1.8V/3.3V,1.8V/5V, 1.5V/3.3V or 1.5V/2.5V.
	@ Min. and Max. Extension of DMN2V/DMP2V to Poly resistor on field oxide should be == 0.22um.   
   (( PORES INTERACT PP ) NOT INTERACT HRIi) NOT DMP2V
   ( PORES INTERACT NP ) NOT DMN2V  
   ( DMP2V AND DMN2V ) AND PORES
   
   PORES_PO = POLY INTERACT PORES
   ENC PORES_PO DMP2V < 0.22 ABUT < 90 SINGULAR REGION
   ENC PORES_PO DMN2V < 0.22 ABUT < 90 SINGULAR REGION
   
   X = EXPAND EDGE ( DMPN2V INTERACT PORES) INSIDE BY 0.005 EXTEND BY - 0.005
   Y = EXPAND EDGE ( DMPN2V TOUCH EDGE ( X NOT INTERACT PORES_PO )) INSIDE BY 0.22
   Y NOT TOUCH PORES
}
RES.3_OD { @ The sheet resistance in SPICE model of non-salicided N+/P+ PO/OD resistors is
        @ resulted from N2V/NP and P2V/PP combinations, respectively. To obtain precise resistance,
	@ dummy layers (DMN2V & DMP2V) are required.N2V/P2V/N3V/P3V/N5V/P5V are derived from logical operation, 
	@ please ensure correct implants in caes the rsistor traverses NW/PW,1.8V/3.3V,1.8V/5V, 1.5V/3.3V or 1.5V/2.5V.
	@ Min. and Max. Extension of DMN2V/DMP2V to Poly resistor on field oxide should be == 0.22um.   
   ( ODRES INTERACT PP ) NOT DMP2V
   ( ODRES INTERACT NP ) NOT DMN2V  
   ( DMP2V AND DMN2V ) AND ODRES
   
   ODRES_OD = OD INTERACT ODRES
   ENC ODRES_OD DMP2V < 0.22 ABUT < 90 SINGULAR REGION
   ENC ODRES_OD DMN2V < 0.22 ABUT < 90 SINGULAR REGION
   
   X = EXPAND EDGE ( DMPN2V INTERACT ODRES) INSIDE BY 0.005 EXTEND BY - 0.005
   Y = EXPAND EDGE ( DMPN2V TOUCH EDGE ( X NOT INTERACT ODRES_OD )) INSIDE BY 0.22
   Y NOT TOUCH ODRES
}
RES.4_PO { @ Min. and Max. clearance from RPO to a contact on the poly resistor and OD resistor = 0.22um
  PO_RES = POLY INTERACT PORES
  CO_RES = CO INTERACT PO_RES
  RPO_E  = RPO INSIDE EDGE PO_RES
  RPO_EX = EXPAND EDGE RPO_E OUTSIDE BY 0.22
  RPO_EX AND CO_RES
  RPO_EX NOT INTERACT CO_RES
  CO_RES NOT INTERACT RPO_EX
}
RES.4_OD { @ Min. and Max. clearance from RPO to a contact on the poly resistor and OD resistor ==0.22um
  OD_RES = OD INTERACT ODRES
  CO_RES = CO INTERACT OD_RES
  RPO_E  = RPO INSIDE EDGE OD_RES
  RPO_EX = EXPAND EDGE RPO_E OUTSIDE BY 0.22
  RPO_EX AND CO_RES
  RPO_EX NOT INTERACT CO_RES
  CO_RES NOT INTERACT RPO_EX
}
RES.5_PO { @ Min. clearance from poly resistor and OD resistor to un-related NP, PP regions >= 0.26um
  EXT PORES IMP < 0.26 ABUT < 90 SINGULAR REGION MEASURE ALL
}
RES.5_OD { @ Min. clearance from poly resistor and OD resistor to un-related NP, PP regions >= 0.26um
  EXT ODRES IMP < 0.26 ABUT < 90 SINGULAR REGION MEASURE ALL
}
RES.6_PO { @ Minimum clearance from an un-related RPO to the POLY and OD  resistor>= 0.3um
  EXT PORES RPO < 0.3 ABUT < 90 SINGULAR REGION MEASURE ALL
}
RES.6_OD { @ Minimum clearance from an un-related RPO to the POLY and OD resistor>= 0.3um
  EXT ODRES RPO < 0.3 ABUT < 90 SINGULAR REGION MEASURE ALL
}
// RES.7 is checked by RES.4
// RES.8 is un-checkable by DRC
#ENDIF

RES.9 {@ DMN2V overlap DMP2V not allowed
  DMP2V AND DMN2V
}

RES.10 {@ Minimum clearence from DMN2V to GATE(overlap is not allowed) >=0.35um
    EXT DMN2V ALL_GATE <0.35 ABUT < 90 SINGULAR REGION 
    DMN2V AND ALL_GATE
}
RES.11 {@ Minimum clearence from DMP2V to GATE(overlap is not allowed) >=0.35um
    EXT DMP2V ALL_GATE <0.35 ABUT < 90 SINGULAR REGION 
    DMP2V AND ALL_GATE
}

#IFDEF MIX_MODE
#IFNDEF C016

#IFDEF Recommend
RES.HRI.1 { @ It is strongly recommended that the HRI poly resistor width e 1.0 um and resistor number of square Nsq e 2. 
            @ DRC will check the width and length 1um and 2um, respectively. Nsq is un-checkable
  INT HREP < 1.0 ABUT < 90 SINGULAR REGION
  RES_L = HREP COIN INSIDE EDGE POLY
  X = PATH LENGTH RES_L < 2.0
  CHECK_RES = HREP WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE RLPPDMY
  A = EXPAND EDGE RES_E INSIDE BY 0.005
  B = SIZE A BY ( 2.0/2 - 0.005*2 ) INSIDE OF HREP STEP 0.175
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < 0.005*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}
//For RES.HRI.1, "Nsq >= 2" can not be checked by DRC
//RES.HRI.2 is checked by RES.4_PO
//RES.HRI.3 is checked by RES.5_PO
//RES.HRI.4 is checked by RES.6_PO 
//RES.HRI.5 is checked by RES.4_PO
//RES.HRI.6 un-checkable by DRC

RES.HRI.7 { @ Min. clearance from RLPPDMY to the HRI poly resistor >= 0.26um
  PO_HREP = POLY INTERACT HREP
  ENC PO_HREP RLPPDMY < 0.26 ABUT < 90 SINGULAR REGION
}
#ENDIF
#ENDIF

#ENDIF


// PP CHECKS
//============
PPE4_NWELC = SIZE NWELi BY 0.43
PPE4_NWELS = SIZE PPE4_NWELC BY 0.18
PPE4_OD = PTAP AND PPE4_NWELS
PPE4_C1 = ENC PPE4_OD PP < 0.18 ABUT > 0 < 90 OPPOSITE REGION
PPE4_C2 = ENC PPE4_OD PP < 0.18 ABUT > 0 < 90 CORNER REGION
PPE4_C3 = ENC PPE4_OD PP < 0.18 ABUT > 0 < 90 PROJ==0 REGION
PPE4_C4 = (SIZE PPE4_C2 BY 0.005) NOT PPE4_OD
PPE4_ALL = (PPE4_C1 OR PPE4_C3) OR PPE4_C4
PPE4_CHECKOD = PPE4_ALL COIN OUTSIDE EDGE PPE4_OD

NPC3_C1 = EXT PPE4_OD NP < 0.18 ABUT > 0 < 90 OPPOSITE REGION
NPC3_C2 = EXT PPE4_OD NP < 0.18 ABUT > 0 < 90 CORNER REGION
NPC3_C3 = EXT PPE4_OD NP < 0.18 ABUT > 0 < 90 PROJ==0 REGION
NPC3_C4 = (SIZE NPC3_C2 BY 0.005) NOT PPE4_OD
NPC3_ALL = (NPC3_C1 OR NPC3_C3) OR NPC3_C4
NPC3_CHECKOD = NPC3_ALL COIN OUTSIDE EDGE PPE4_OD

NPE4_NWELC = SIZE NWELi BY -0.43
NPE4_NWELS = SIZE NPE4_NWELC BY -0.18
NPE4_OD = NTAP NOT NPE4_NWELS
NPE4_C1 = ENC NPE4_OD NP < 0.18 ABUT > 0 < 90 OPPOSITE REGION
NPE4_C2 = ENC NPE4_OD NP < 0.18 ABUT > 0 < 90 CORNER REGION
NPE4_C3 = ENC NPE4_OD NP < 0.18 ABUT > 0 < 90 PROJ==0 REGION
NPE4_C4 = (SIZE NPE4_C2 BY 0.005) NOT NPE4_OD
NPE4_ALL = (NPE4_C1 OR NPE4_C3) OR NPE4_C4
NPE4_CHECKOD = NPE4_ALL COIN OUTSIDE EDGE NPE4_OD

PPC3_C1 = EXT NPE4_OD PP < 0.18 ABUT > 0 < 90 OPPOSITE REGION
PPC3_C2 = EXT NPE4_OD PP < 0.18 ABUT > 0 < 90 CORNER REGION
PPC3_C3 = EXT NPE4_OD PP < 0.18 ABUT > 0 < 90 PROJ==0 REGION
PPC3_C4 = (SIZE PPC3_C2 BY 0.005) NOT NPE4_OD
PPC3_ALL = (PPC3_C1 OR PPC3_C3) OR PPC3_C4
PPC3_CHECKOD = PPC3_ALL COIN OUTSIDE EDGE NPE4_OD

PP.W.1 { @ PP width < 0.440
  INT PP < 0.440 ABUT < 90 SINGULAR REGION 
}
PP.S.1 { @ PP space < 0.440
  EXT PP < 0.440 ABUT < 90 SINGULAR REGION
}
PP.C.1 { @ PP space to n active in pwell < 0.260
  // N active in pwell can be butting or non-butting. 
  // The non-butting N active is not allowed to touch PP.
  EXT PP NACT < 0.260 ABUT > 0 < 90 SINGULAR REGION
  X = EXT PP [NACT] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT PPOD
}
PP.C.2 { @ PP space to non-butting NTAP < 0.1 with PWEL space >= 0.43
  EXT PP NTAP < 0.1 ABUT > 0 < 90 SINGULAR REGION
}
PP.C.3 { @ PP space to non-butting NTAP < 0.18 with PWEL space < 0.43
  PPC3_CHECKOD OUTSIDE EDGE NPE4_NWELC
}
// PP.C.4 is checked by NP.C.5 and PP.R.1
PP.C.5 { @ PP extension over (P gate) + (field poly within 0.35um) < 0.32um
  // This rule must extend out of gate in the direction of PO by 0.35um
  EXGATE_PP NOT PP
}
PP.O.1 { @ Minimum overlap from a PP edge to an OD region must >= 0.230um except SBD region 
    INT OD PP_NSBD < 0.230 ABUT > 0 < 90 SINGULAR REGION
}
PP.E.1 { @ Minimum extension of a PP region beyond a P+ active OD region must >=0.18um except SBD region
    ENC PACT PP_NSBD < 0.180 ABUT > 0 < 90 SINGULAR REGION
    Y = ENC [PACT] PP_NSBD < 0.001 ABUT == 0
    Z = EXPAND EDGE Y OUTSIDE BY 0.001
    Z NOT INTERACT NPOD
}

PP.E.1_NP.E.1 { @ Implant can not coincident OD edge except butted diffusion
  IMP COIN INSIDE EDGE OD
}  
PP.E.3 { @ Minimum enclosure of PTAP by PP < 0.02 with NWEL space >= 0.43
  ENC PTAP PP < 0.02 ABUT > 0 < 90 SINGULAR REGION
  X = ENC [PTAP] PP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT NPOD
}
PP.E.4 { @ Min. enc. of PTAP by PP < 0.18 with NWEL space < 0.43
  PPE4_CHECKOD INSIDE EDGE PPE4_NWELC
}
// PP.C.6 is not necessary to check
// PP.E.5 is not necessary to check
PP.A.1 { @ Minimum area of PP < 0.3844
  PP AREA < 0.3844
}
#IFNDEF MIX_MODE
PP.E.6 { @ Min enc of POLY resistor by PP < 0.18
  ENC PORES PP < 0.18 ABUT < 90 SINGULAR REGION
  (RPO AND POLY) NOT IMP
}
#ENDIF

PP.R.1_NP.R.1 { @ PP and NP not allowed to overlap
  PP AND NP
}

// PP.R.2 is not necessary to check
PP.R.3_NP.R.3 { @ OD must be fully covered by PP and NP ,except OD without interacting CO OR PO
   (((OD INTERACT POLYi )NOT ODWR)NOT SBDDMY) NOT IMP
   (((OD INTERACT COi )NOT ODWR)NOT SBDDMY) NOT IMP
}



// NP CHECKS
//============
 
NP.W.1 { @ NP width < 0.440
  INT NP < 0.440 ABUT < 90 SINGULAR REGION
}
NP.S.1 { @ NP space < 0.440
  EXT NP < 0.440 ABUT < 90 SINGULAR REGION
}
NP.C.1 { @ NP space to p active in NWEL < 0.260
  // P active in NWEL can be butting or non-butting.
  // The non-butting P active is not allowed to touch NP.
  EXT NP PACT < 0.260 ABUT > 0 < 90 SINGULAR REGION
  X = EXT NP [PACT] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT NPOD
}
NP.C.2 { @ NP space to non-butting ptap < 0.1 with NWEL space >= 0.43
  EXT NP PTAP < 0.1 ABUT > 0 < 90 SINGULAR REGION
}
NP.C.3 { @ NP space to non-butting ptap < 0.18 with NWEL space < 0.43
  NPC3_CHECKOD INSIDE EDGE PPE4_NWELC
}
// NP.C.4 is checked by PP.C.5 and NP.R.1
NP.C.5 { @ NP extension over (N gate) + (field poly within 0.35um) < 0.32um
  // This rule must extend out of gate in the direction of PO by 0.35um
  EXGATE_NP NOT NP
}
NP.O.1 { @ NP extends into n active < 0.230
  INT OD NP < 0.230 ABUT > 0 < 90 SINGULAR REGION 
}
NP.E.1 { @ NP olap OD < 0.180
  X = NACT NOT ODWR
  ENC X NP < 0.180 ABUT > 0 < 90 SINGULAR REGION
  Y = ENC [X] NP < 0.001 ABUT == 0
  Z  = EXPAND EDGE Y OUTSIDE BY 0.001
  Z NOT INTERACT PPOD
}
NP.E.3 { @ Minimum enclosure of NTAP by NP < 0.02 with PWEL space >= 0.43
  ENC NTAP NP < 0.02 ABUT > 0 < 90 SINGULAR REGION
  X = ENC [NTAP] NP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT PPOD
}
NP.E.4 { @ Min. enc. of NTAP by NP < 0.18 with PWEL space < 0.43
  NPE4_CHECKOD OUTSIDE EDGE NPE4_NWELC
}
// NP.C.6 is not checked by drc
// NP.E.5 is not checked by drc
NP.A.1 { @ Minimum area of NP < 0.3844
  NP AREA < 0.3844
}
NP.E.6 { @ Min enc of POLY resistor by NP < 0.18
  ENC PORES NP < 0.18 ABUT < 90 SINGULAR REGION
}
// NP.R.2 is not necessary to check



// RPO checks
//===========
CB_HOLE = HOLES CB 
CB_SR = CB TOUCH CB_HOLE ==1
RPO_NOT_SR = RPO NOT INTERACT CB_SR

RPO.W.1 { @ Minimum RPO width < 0.43
  INT RPO < 0.43 ABUT < 90 SINGULAR REGION
}
RPO.S.1 { @ Minimum RPO space < 0.43
  EXT RPO < 0.43 ABUT < 90 SINGULAR REGION
}
RPO.C.1 { @ Minimum RPO space to OD < 0.22
  EXT RPO OD < 0.22 ABUT < 90 SINGULAR REGION
}
RPO.C.2 { @ Minimum RPO space to CO < 0.22
  EXT RPO CO < 0.22 ABUT < 90 SINGULAR REGION 
  CO AND RPO     
}
RPO.C.3 { @ Minimum RPO space to gate < 0.45 
    	  @exclude ESD part
  A = ((((ALL_GATE NOT DRCDMY) NOT ESD1DMY) NOT ESD2DMY) NOT ESD3DMY ) NOT SDI
  EXT RPO A < 0.45 ABUT < 90 SINGULAR REGION 
  RPO AND A
}
RPO.C.4 { @ Minimum RPO overhang OD < 0.22
  ENC OD RPO < 0.22 ABUT < 90 SINGULAR REGION
  RPO_NOT_SR INSIDE OD    
}
RPO.E.1 { @ Minimum OD overhang RPO < 0.22
  ENC RPO OD < 0.22 ABUT < 90 SINGULAR REGION
}
RPO.C.5 { @ Minimum RPO overhang POLY < 0.22
  ENC POLY RPO < 0.22 ABUT < 90 SINGULAR REGION
  RPO_NOT_SR INSIDE POLY
}
RPO.C.6 { @ Minimum clearance RPO to unrelated poly < 0.3um
  EXT RPO POLY_ISO < 0.30 ABUT < 90 SINGULAR REGION
}
RPO.A.1 { @ RPO min. area < 2 um*um
  AREA RPO < 2
}


// CO checks
//===============
CO.W.1 { @ contact width != 0.22
  X = CO NOT SR_CO
  NOT RECTANGLE X == 0.22 BY == 0.22 ORTHOGONAL ONLY
}
CO.S.1 { @ contact spacing < 0.25
  EXT CO < 0.25 ABUT < 90 SINGULAR REGION
}
CO.S.2  { @ Min space between two contacts in larger than 4x4 array.
  A = SIZE CO BY 0.30/2 OVERUNDER	// space < 0.3um treat as array
  B = SIZE A BY 0.7 UNDEROVER	// (0.22*3+0.3*2) = 1.26  (3 COs Mix.)
  C = B INTERACT CO >= 16	// 1.63-0.22 = 1.41       (Max. CO shift space) 
  D = CO INTERACT C		// so 1.26 < CONTY width < 1.41
  EXT D < 0.28			// & we use CONTY width = 1.4
}
CO.C.1_CO.R.1 { @ diff contact to gate space < 0.16, or contact on gate
  EXT CO_DIFF ALL_GATE < 0.16 ABUT < 90 SINGULAR REGION
  CO_DIFF AND ALL_GATE    
}
CO.C.2 { @ poly contact space to OD < 0.20
  EXT CO_POLY OD < 0.20 ABUT < 90 SINGULAR REGION
}
CO.E.1 { @ active olap contact < 0.10, also floating contacts
  ENC CO_DIFF OD < 0.10 ABUT < 90 SINGULAR REGION
  CO_DIFF OUTSIDE EDGE OD    
}
CO.E.2 { @ poly olap contact < 0.10
  ENC CO_POLY POLY_ISO < 0.10 ABUT < 90 SINGULAR REGION
  CO_POLY CUT POLY_ISO    
}
CO.E.3 { @ Minimum extension of a PP region beyond a OD CO region must >=0.18um except SBD region
    ENC CO_DIFF PP_NSBD < 0.12 ABUT < 90 SINGULAR REGION 
    PP_NSBD INSIDE EDGE CO_DIFF 
}
CO.E.4 { @ implant olap contact < 0.12
  ENC CO_DIFF NP < 0.12 ABUT < 90 SINGULAR REGION 
  NP INSIDE EDGE CO_DIFF    
}
// CO.R.2 is checked by CO.E.3/CO.E.4
// CO.R.3 is checked by RPO.C.2


// M1 checks
//=============
M1.W.1 { @ Min. M1 width < 0.23
  INT M1 < 0.23 ABUT < 90 SINGULAR REGION
}
M1.S.1 { @ Min. M1 space < 0.23
  EXT M1 < 0.23 ABUT < 90 SINGULAR REGION
}
M1.S.2 { @ Min. space to wide M1 (>10um) < 0.6
  M1_S5 = SHRINK (SHRINK (SHRINK (SHRINK M1 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M1_G5 = GROW (GROW (GROW (GROW M1_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M1_Wide = M1_G5 AND M1
  M1_Exp = SIZE M1_Wide BY 1 INSIDE OF M1 STEP 0.161
  M1_Branch = M1_Exp NOT M1_Wide
  M1_Branch_edge = M1_Branch COIN INSIDE EDGE M1
  M1_Check = M1 AND (SIZE M1_Exp BY 0.6)
  M1_Branch_Check = M1 AND (EXPAND EDGE M1_Branch_edge OUTSIDE BY 0.6 CORNER FILL)
  M1_WideC = STAMP M1_Wide BY M1xd
  M1_CheckC = STAMP M1_Check BY M1xd
  M1_BranchC = STAMP M1_Branch BY M1xd
  M1_Branch_CheckC = STAMP M1_Branch_Check BY M1xd
  EXT M1_WideC M1_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M1_BranchC M1_Branch_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
}
M1.E.1 { @ Min. extension of a M1 region beyond a CO region < 0.005
  ENC CO M1 < 0.005 ABUT < 90 SINGULAR REGION
  CO NOT M1    
}
M1.E.2 { @ Min. extension of M1 end-of-line region beyond CO region < 0.06
  X = ENC [CO] M1 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.22 ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}

M1.A.1{ @ Min. M1 area < 0.202
  AREA M1_A < 0.202
}

// Density check M1.R.1 included at the end of this file



// VIA1 checks
//=============
VIA1_CORE = VIA1 NOT SR_VIA1
VIA1.W.1 { @ VIA1 must be 0.26 x 0.26
  A = NOT RECTANGLE VIA1_CORE == 0.26 BY == 0.26 ORTHOGONAL ONLY
  A OUTSIDE RNGX   // exclude from metal fuse protection ring area
}
VIA1.S.1 { @ Min. VIA1 space < 0.26
  EXT VIA1 < 0.26 ABUT < 90 SINGULAR REGION 
}
VIA1.E.1 { @ Min. extension of a M1 region beyond a VIA1 region < 0.01
  ENC VIA1 M1 < 0.01 ABUT < 90 SINGULAR REGION
  VIA1 NOT M1    
}
VIA1.E.2 { @ Min. extension of M1 end-of-line region beyond VIA1 region < 0.06
  X = ENC [VIA1] M1 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.26  ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}

// M2 checks
//=============
M2.W.1 { @ Min. M2 width < 0.28
  INT M2 < 0.28 ABUT < 90 SINGULAR REGION
}
M2.S.1 { @ Min. M2 space < 0.28
  EXT M2 < 0.28 ABUT < 90 SINGULAR REGION
}
M2.S.2 { @ Min. space to wide M2 (>10um) < 0.6
  M2_S5 = SHRINK (SHRINK (SHRINK (SHRINK M2 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M2_G5 = GROW (GROW (GROW (GROW M2_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M2_Wide = M2_G5 AND M2
  M2_Exp = SIZE M2_Wide BY 1 INSIDE OF M2 STEP 0.196
  M2_Branch = M2_Exp NOT M2_Wide
  M2_Branch_edge = M2_Branch COIN INSIDE EDGE M2
  M2_Check = M2 AND (SIZE M2_Exp BY 0.6)
  M2_Branch_Check = M2 AND (EXPAND EDGE M2_Branch_edge OUTSIDE BY 0.6 CORNER FILL)
  M2_WideC = STAMP M2_Wide BY M2xd
  M2_CheckC = STAMP M2_Check BY M2xd
  M2_BranchC = STAMP M2_Branch BY M2xd
  M2_Branch_CheckC = STAMP M2_Branch_Check BY M2xd
  EXT M2_WideC M2_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M2_BranchC M2_Branch_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
}
M2.E.1 { @ Min. extension of a M2 region beyond a VIA1 region < 0.01
  ENC VIA1 M2 < 0.01 ABUT < 90 SINGULAR REGION
  VIA1 NOT M2
}
M2.E.2 { @ Min. extension of M2 end-of-line region beyond VIA1 region < 0.06
  X = ENC [VIA1] M2 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.26 ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}
M2.A.1{ @ Min M2 area region < 0.202
  AREA M2 < 0.202
}
// Density check M2.R.1 included at the end of this file

// VIA2 checks
//=============
VIA2_CORE = VIA2 NOT SR_VIA2
VIA2.W.1 { @ VIA2 must be 0.26 x 0.26
  A = NOT RECTANGLE VIA2_CORE == 0.26 BY == 0.26 ORTHOGONAL ONLY
  A OUTSIDE RNGX   // exclude from metal fuse protection ring area
}
VIA2.S.1 { @ Min. VIA2 space < 0.26
  EXT VIA2 < 0.26 ABUT < 90 SINGULAR REGION 
}
VIA2.E.1 { @ Min. extension of a M2 region beyond a VIA2 region < 0.01
  ENC VIA2 M2 < 0.01 ABUT < 90 SINGULAR REGION
  VIA2 NOT M2    
}
VIA2.E.2 { @ Min. extension of M2 end-of-line region beyond VIA2 region < 0.06
  X = ENC [VIA2] M2 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.26  ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}

// M3 checks
//=============
M3.W.1 { @ Min. M3 width < 0.28
  INT M3 < 0.28 ABUT < 90 SINGULAR REGION
}
M3.S.1 { @ Min. M3 space < 0.28
  EXT M3 < 0.28 ABUT < 90 SINGULAR REGION
}
M3.S.2 { @ Min. space to wide M3 (>10um) < 0.6
  M3_S5 = SHRINK (SHRINK (SHRINK (SHRINK M3 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M3_G5 = GROW (GROW (GROW (GROW M3_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M3_Wide = M3_G5 AND M3
  M3_Exp = SIZE M3_Wide BY 1 INSIDE OF M3 STEP 0.196
  M3_Branch = M3_Exp NOT M3_Wide
  M3_Branch_edge = M3_Branch COIN INSIDE EDGE M3
  M3_Check = M3 AND (SIZE M3_Exp BY 0.6)
  M3_Branch_Check = M3 AND (EXPAND EDGE M3_Branch_edge OUTSIDE BY 0.6 CORNER FILL)
  M3_WideC = STAMP M3_Wide BY M3xd
  M3_CheckC = STAMP M3_Check BY M3xd
  M3_BranchC = STAMP M3_Branch BY M3xd
  M3_Branch_CheckC = STAMP M3_Branch_Check BY M3xd
  EXT M3_WideC M3_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M3_BranchC M3_Branch_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
}
M3.E.1 { @ Min. extension of a M3 region beyond a VIA2 region < 0.01
  ENC VIA2 M3 < 0.01 ABUT < 90 SINGULAR REGION
  VIA2 NOT M3
}
M3.E.2 { @ Min. extension of M3 end-of-line region beyond VIA2 region < 0.06
  X = ENC [VIA2] M3 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.26 ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}
M3.A.1{ @ Min M3 area region < 0.202
  AREA M3 < 0.202
}
// Density check M3.R.1 included at the end of this file

// VIA3 checks
//=============
VIA3_CORE = VIA3 NOT SR_VIA3
VIA3.W.1 { @ VIA3 must be 0.26 x 0.26
  A = NOT RECTANGLE VIA3_CORE == 0.26 BY == 0.26 ORTHOGONAL ONLY
  A OUTSIDE RNGX   // exclude from metal fuse protection ring area
}
VIA3.S.1 { @ Min. VIA3 space < 0.26
  EXT VIA3 < 0.26 ABUT < 90 SINGULAR REGION 
}
VIA3.E.1 { @ Min. extension of a M3 region beyond a VIA3 region < 0.01
  ENC VIA3 M3 < 0.01 ABUT < 90 SINGULAR REGION
  VIA3 NOT M3    
}
VIA3.E.2 { @ Min. extension of M3 end-of-line region beyond VIA3 region < 0.06
  X = ENC [VIA3] M3 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.26  ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}

// M4 checks
//=============
M4.W.1 { @ Min. M4 width < 0.28
  INT M4 < 0.28 ABUT < 90 SINGULAR REGION
}
M4.S.1 { @ Min. M4 space < 0.28
  EXT M4 < 0.28 ABUT < 90 SINGULAR REGION
}
M4.S.2 { @ Min. space to wide M4 (>10um) < 0.6
  M4_S5 = SHRINK (SHRINK (SHRINK (SHRINK M4 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M4_G5 = GROW (GROW (GROW (GROW M4_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M4_Wide = M4_G5 AND M4
  M4_Exp = SIZE M4_Wide BY 1 INSIDE OF M4 STEP 0.196
  M4_Branch = M4_Exp NOT M4_Wide
  M4_Branch_edge = M4_Branch COIN INSIDE EDGE M4
  M4_Check = M4 AND (SIZE M4_Exp BY 0.6)
  M4_Branch_Check = M4 AND (EXPAND EDGE M4_Branch_edge OUTSIDE BY 0.6 CORNER FILL)
  M4_WideC = STAMP M4_Wide BY M4xd
  M4_CheckC = STAMP M4_Check BY M4xd
  M4_BranchC = STAMP M4_Branch BY M4xd
  M4_Branch_CheckC = STAMP M4_Branch_Check BY M4xd
  EXT M4_WideC M4_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M4_BranchC M4_Branch_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
}
M4.E.1 { @ Min. extension of a M4 region beyond a VIA3 region < 0.01
  ENC VIA3 M4 < 0.01 ABUT < 90 SINGULAR REGION
  VIA3 NOT M4
}
M4.E.2 { @ Min. extension of M4 end-of-line region beyond VIA3 region < 0.06
  X = ENC [VIA3] M4 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.26 ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}
M4.A.1{ @ Min M4 area region < 0.202
  AREA M4 < 0.202
}
// Density check M4.R.1 included at the end of this file

// VIA4 checks
//=============
VIA4_CORE = VIA4 NOT SR_VIA4
VIA4.W.1 { @ VIA4 must be 0.26 x 0.26
  A = NOT RECTANGLE VIA4_CORE == 0.26 BY == 0.26 ORTHOGONAL ONLY
  A OUTSIDE RNGX   // exclude from metal fuse protection ring area
}
VIA4.S.1 { @ Min. VIA4 space < 0.26
  EXT VIA4 < 0.26 ABUT < 90 SINGULAR REGION 
}
VIA4.E.1 { @ Min. extension of a M4 region beyond a VIA4 region < 0.01
  ENC VIA4 M4 < 0.01 ABUT < 90 SINGULAR REGION
  VIA4 NOT M4    
}
VIA4.E.2 { @ Min. extension of M4 end-of-line region beyond VIA4 region < 0.06
  X = ENC [VIA4] M4 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.26  ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}

// M5 checks
//=============
M5.W.1 { @ Min. M5 width < 0.28
  INT M5 < 0.28 ABUT < 90 SINGULAR REGION
}
M5.S.1 { @ Min. M5 space < 0.28
  EXT M5 < 0.28 ABUT < 90 SINGULAR REGION
}
M5.S.2 { @ Min. space to wide M5 (>10um) < 0.6
  M5_S5 = SHRINK (SHRINK (SHRINK (SHRINK M5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M5_G5 = GROW (GROW (GROW (GROW M5_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M5_Wide = M5_G5 AND M5
  M5_Exp = SIZE M5_Wide BY 1 INSIDE OF M5 STEP 0.196
  M5_Branch = M5_Exp NOT M5_Wide
  M5_Branch_edge = M5_Branch COIN INSIDE EDGE M5
  M5_Check = M5 AND (SIZE M5_Exp BY 0.6)
  M5_Branch_Check = M5 AND (EXPAND EDGE M5_Branch_edge OUTSIDE BY 0.6 CORNER FILL)
  M5_WideC = STAMP M5_Wide BY M5xd
  M5_CheckC = STAMP M5_Check BY M5xd
  M5_BranchC = STAMP M5_Branch BY M5xd
  M5_Branch_CheckC = STAMP M5_Branch_Check BY M5xd
  EXT M5_WideC M5_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M5_BranchC M5_Branch_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
}
M5.E.1 { @ Min. extension of a M5 region beyond a VIA4 region < 0.01
  ENC VIA4 M5 < 0.01 ABUT < 90 SINGULAR REGION
  VIA4 NOT M5
}
M5.E.2 { @ Min. extension of M5 end-of-line region beyond VIA4 region < 0.06
  X = ENC [VIA4] M5 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.26 ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}
M5.A.1{ @ Min M5 area region < 0.202
  AREA M5 < 0.202
}
// Density check M5.R.1 included at the end of this file




/*****  Variables for IMD crack check *****/
#IFNDEF C016
VARIABLE  VIA_W_1      8   //The width of ViaArray
VARIABLE  VIA_S_1      3.2 //VIA ARAAY interal space. 
VARIABLE  VIA_S_2      2.8 //Space of via array to via array.
VARIABLE  VIA_S_2L     15  //via array parrallel run length
VARIABLE  VIA_A_5      300 //The overlap area of 5 level continuous stack via array.
VARIABLE  VIA_A_4      725 //The overlap area of 4 level continuous stack via array.
VARIABLE  VIA_A_3      960 //The overlap area of 3 level continuous stack via array.
VARIABLE  VIA_A_2     6000 //The overlap area of 2 level continuous stack via array.
VARIABLE  VIA_Merge   1.605  //The Merge error VIAs and highlight error vias region
#ENDIF
#IFDEF C016
VARIABLE  VIA_W_1      8.9   //The width of ViaArray
VARIABLE  VIA_S_1      3.56 //VIA ARAAY interal space. 
VARIABLE  VIA_S_2      3.12 //Space of via array to via array.
VARIABLE  VIA_S_2L     16.7  //via array parrallel run length
VARIABLE  VIA_A_5      333 //The overlap area of 5 level continuous stack via array.
VARIABLE  VIA_A_4      806 //The overlap area of 4 level continuous stack via array.
VARIABLE  VIA_A_3      1067 //The overlap area of 3 level continuous stack via array.
VARIABLE  VIA_A_2      6667 //The overlap area of 2 level continuous stack via array
VARIABLE  VIA_Merge   1.785  //The Merge error VIAs and highlight error vias region
#ENDIF
VARIABLE  VIA_D_1     0.10 //The highlight array minimum density
VARIABLE  VIA_S_3     0.49 //Space of via in via array.
VARIABLE  VIA_Filter   3.0 // Shrink via arrary For broken small metal connection.

//********************************************
/***** Pre-processing for IMD crack check ****/ 
//********************************************
//
// Processing for SAME Array Merged 
//*********************************
  VIA1_M = VIA1 INTERACT M1 
  VIA1Merge1 = SIZE VIA1_M BY VIA_S_1/2 INSIDE OF M1 STEP 0.46
  VIA1Merge2 = SIZE VIA1_M BY VIA_S_1/2 OVERUNDER                 // Any space <= VIA1_S_1 um treated as "array"
  VIA1Merge.pre1 = VIA1Merge1 AND VIA1Merge2                      // Find merged via array(s)
  VIA1Merge.pre11 = ENCLOSE RECTANGLE VIA1Merge.pre1 VIA_S_2L VIA_W_1  // Find at least one width >= VIA_W_1
  VIA1Merge.pre12 = VIA1_M INTERACT VIA1Merge.pre11                    // find VIA1 in the effective via arrary
  VIA1Merge.pre13 = SIZE VIA1Merge.pre12 BY VIA_S_1/2 OVERUNDER        // Any space <= VIA1_S_1 um treated as "array"
  VIA1Merge.pre2  = VIA1Merge1 AND VIA1Merge.pre13                     // Find merged via array(s)
  VIA1_same_array = SIZE VIA1Merge.pre2 BY VIA_Filter/2 UNDEROVER // For broken small metal connection
  VIA2_M = VIA2 INTERACT M2 
  VIA2Merge1 = SIZE VIA2_M BY VIA_S_1/2 INSIDE OF M2 STEP 0.46
  VIA2Merge2 = SIZE VIA2_M BY VIA_S_1/2 OVERUNDER                 // Any space <= VIA1_S_1 um treated as "array"
  VIA2Merge.pre1 = VIA2Merge1 AND VIA2Merge2                      // Find merged via array(s)
  VIA2Merge.pre11 = ENCLOSE RECTANGLE VIA2Merge.pre1 VIA_S_2L VIA_W_1  // Find at least one width >= VIA_W_1
  VIA2Merge.pre12 = VIA2_M INTERACT VIA2Merge.pre11                    // find VIA2 in the effective via arrary
  VIA2Merge.pre13 = SIZE VIA2Merge.pre12 BY VIA_S_1/2 OVERUNDER        // Any space <= VIA1_S_1 um treated as "array"
  VIA2Merge.pre2  = VIA2Merge1 AND VIA2Merge.pre13                     // Find merged via array(s)
  VIA2_same_array = SIZE VIA2Merge.pre2 BY VIA_Filter/2 UNDEROVER // For broken small metal connection
  VIA3_M = VIA3 INTERACT M3 
  VIA3Merge1 = SIZE VIA3_M BY VIA_S_1/2 INSIDE OF M3 STEP 0.46
  VIA3Merge2 = SIZE VIA3_M BY VIA_S_1/2 OVERUNDER                 // Any space <= VIA1_S_1 um treated as "array"
  VIA3Merge.pre1 = VIA3Merge1 AND VIA3Merge2                      // Find merged via array(s)
  VIA3Merge.pre11 = ENCLOSE RECTANGLE VIA3Merge.pre1 VIA_S_2L VIA_W_1  // Find at least one width >= VIA_W_1
  VIA3Merge.pre12 = VIA3_M INTERACT VIA3Merge.pre11                    // find VIA3 in the effective via arrary
  VIA3Merge.pre13 = SIZE VIA3Merge.pre12 BY VIA_S_1/2 OVERUNDER        // Any space <= VIA1_S_1 um treated as "array"
  VIA3Merge.pre2  = VIA3Merge1 AND VIA3Merge.pre13                     // Find merged via array(s)
  VIA3_same_array = SIZE VIA3Merge.pre2 BY VIA_Filter/2 UNDEROVER // For broken small metal connection
  VIA4_M = VIA4 INTERACT M4 
  VIA4Merge1 = SIZE VIA4_M BY VIA_S_1/2 INSIDE OF M4 STEP 0.46
  VIA4Merge2 = SIZE VIA4_M BY VIA_S_1/2 OVERUNDER                 // Any space <= VIA1_S_1 um treated as "array"
  VIA4Merge.pre1 = VIA4Merge1 AND VIA4Merge2                      // Find merged via array(s)
  VIA4Merge.pre11 = ENCLOSE RECTANGLE VIA4Merge.pre1 VIA_S_2L VIA_W_1  // Find at least one width >= VIA_W_1
  VIA4Merge.pre12 = VIA4_M INTERACT VIA4Merge.pre11                    // find VIA4 in the effective via arrary
  VIA4Merge.pre13 = SIZE VIA4Merge.pre12 BY VIA_S_1/2 OVERUNDER        // Any space <= VIA1_S_1 um treated as "array"
  VIA4Merge.pre2  = VIA4Merge1 AND VIA4Merge.pre13                     // Find merged via array(s)
  VIA4_same_array = SIZE VIA4Merge.pre2 BY VIA_Filter/2 UNDEROVER // For broken small metal connection
  VIA5_M = VIA5 INTERACT M5 
  VIA5Merge1 = SIZE VIA5_M BY VIA_S_1/2 INSIDE OF M5 STEP 0.46
  VIA5Merge2 = SIZE VIA5_M BY VIA_S_1/2 OVERUNDER                 // Any space <= VIA1_S_1 um treated as "array"
  VIA5Merge.pre1 = VIA5Merge1 AND VIA5Merge2                      // Find merged via array(s)
  VIA5Merge.pre11 = ENCLOSE RECTANGLE VIA5Merge.pre1 VIA_S_2L VIA_W_1  // Find at least one width >= VIA_W_1
  VIA5Merge.pre12 = VIA5_M INTERACT VIA5Merge.pre11                    // find VIA5 in the effective via arrary
  VIA5Merge.pre13 = SIZE VIA5Merge.pre12 BY VIA_S_1/2 OVERUNDER        // Any space <= VIA1_S_1 um treated as "array"
  VIA5Merge.pre2  = VIA5Merge1 AND VIA5Merge.pre13                     // Find merged via array(s)
  VIA5_same_array = SIZE VIA5Merge.pre2 BY VIA_Filter/2 UNDEROVER // For broken small metal connection

// Processing for 5 ~ 2 Stack Array  
//**********************************

  VIA1_same_array_5stack.pre1 = ((((AREA VIA1_same_array >= VIA_A_5) AND (AREA VIA2_same_array>= VIA_A_5 )) AND ( AREA VIA3_same_array>= VIA_A_5)) AND (AREA VIA4_same_array >= VIA_A_5)) AND ( AREA VIA5_same_array >= VIA_A_5 ) 
  VIA1_same_array_5stack.pre2 = AREA VIA1_same_array_5stack.pre1 >= VIA_A_5

  VIA1_same_array_4stack.pre1 = ((( AREA VIA1_same_array >= VIA_A_4)  AND (AREA VIA2_same_array >= VIA_A_4)) AND ( AREA VIA3_same_array>= VIA_A_4 )) AND ( AREA VIA4_same_array >= VIA_A_4 )
  VIA1_same_array_4stack.pre2 = AREA VIA1_same_array_4stack.pre1 >= VIA_A_4
  VIA2_same_array_4stack.pre1 = ((( AREA VIA2_same_array >= VIA_A_4)  AND (AREA VIA3_same_array >= VIA_A_4)) AND ( AREA VIA4_same_array>= VIA_A_4 )) AND ( AREA VIA5_same_array >= VIA_A_4 )
  VIA2_same_array_4stack.pre2 = AREA VIA2_same_array_4stack.pre1 >= VIA_A_4

  VIA1_same_array_3stack.pre1 = ((AREA VIA1_same_array >= VIA_A_3 ) AND (AREA VIA2_same_array >= VIA_A_3)) AND ( AREA VIA3_same_array >= VIA_A_3 )
  VIA1_same_array_3stack.pre2 = AREA VIA1_same_array_3stack.pre1 >= VIA_A_3
  VIA2_same_array_3stack.pre1 = ((AREA VIA2_same_array >= VIA_A_3 ) AND (AREA VIA3_same_array >= VIA_A_3)) AND ( AREA VIA4_same_array >= VIA_A_3 )
  VIA2_same_array_3stack.pre2 = AREA VIA2_same_array_3stack.pre1 >= VIA_A_3
  VIA3_same_array_3stack.pre1 = ((AREA VIA3_same_array >= VIA_A_3 ) AND (AREA VIA4_same_array >= VIA_A_3)) AND ( AREA VIA5_same_array >= VIA_A_3 )
  VIA3_same_array_3stack.pre2 = AREA VIA3_same_array_3stack.pre1 >= VIA_A_3
  
  VIA1_same_array_2stack.pre1 = ( AREA VIA1_same_array >= VIA_A_2 ) AND (AREA VIA2_same_array >= VIA_A_2 )
  VIA1_same_array_2stack.pre2 = AREA VIA1_same_array_2stack.pre1 >= VIA_A_2
  VIA2_same_array_2stack.pre1 = ( AREA VIA2_same_array >= VIA_A_2 ) AND (AREA VIA3_same_array >= VIA_A_2 )
  VIA2_same_array_2stack.pre2 = AREA VIA2_same_array_2stack.pre1 >= VIA_A_2
  VIA3_same_array_2stack.pre1 = ( AREA VIA3_same_array >= VIA_A_2 ) AND (AREA VIA4_same_array >= VIA_A_2 )
  VIA3_same_array_2stack.pre2 = AREA VIA3_same_array_2stack.pre1 >= VIA_A_2
  VIA4_same_array_2stack.pre1 = ( AREA VIA4_same_array >= VIA_A_2 ) AND (AREA VIA5_same_array >= VIA_A_2 )
  VIA4_same_array_2stack.pre2 = AREA VIA4_same_array_2stack.pre1 >= VIA_A_2

//**********************  
// Small 5 stack array
//**********************
// Processing for SAME Array Size Check    
//**************************************
  VIA1_5stack.pre3 = ENCLOSE RECTANGLE VIA1_same_array_5stack.pre2 VIA_S_2L VIA_W_1  // Find at least one width >= VIA_W_1
  VIA1_Reg_3_S_5 = EXT VIA1_5stack.pre3 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90
  VIA1_Reg_3_S_5_1 = ENCLOSE RECTANGLE VIA1_Reg_3_S_5 0.005 VIA_S_2L // Find parallel run length >= VIA_S_2L
  VIA1_5stack.pre4 = VIA1_5stack.pre3 INTERACT VIA1_Reg_3_S_5_1 // Find parallel run length >= VIA_S_2L  
  VIA1ArrayS1_S_5 = EXT VIA1_5stack.pre4 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90   // Space of different "smae array" smaller than VIA_S_2
  VIA1ArrayS2_S_5 = ((((VIA1ArrayS1_S_5 NOT INSIDE M1) NOT INSIDE M2) NOT INSIDE M3) NOT INSIDE M4) NOT INSIDE M5
  VIA1_5stack.Final = VIA1_5stack.pre4 INTERACT VIA1ArrayS2_S_5
    
  VIA1_S_5_A1 = VIA1 INTERACT VIA1_5stack.Final 
  VIA1_Reg_4_S_5_A1 = EXT VIA1_S_5_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA1s space smaller than 0.49 (inside small array)  
  VIA1_Violate_S_5_A1= VIA1_S_5_A1 INTERACT VIA1_Reg_4_S_5_A1                 
  VIA2_S_5_A1 = VIA2 INTERACT VIA1_5stack.Final 
  VIA2_Reg_4_S_5_A1 = EXT VIA2_S_5_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_5_A1 = VIA2_S_5_A1 INTERACT VIA2_Reg_4_S_5_A1  
  VIA3_S_5_A1 = VIA3 INTERACT VIA1_5stack.Final 
  VIA3_Reg_4_S_5_A1 = EXT VIA3_S_5_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION  // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_5_A1 = VIA3_S_5_A1 INTERACT VIA3_Reg_4_S_5_A1  
  VIA4_S_5_A1 = VIA4 INTERACT VIA1_5stack.Final 
  VIA4_Reg_4_S_5_A1 = EXT VIA4_S_5_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_5_A1 = VIA4_S_5_A1 INTERACT VIA4_Reg_4_S_5_A1  
  VIA5_S_5_A1 = VIA5 INTERACT VIA1_5stack.Final 
  VIA5_Reg_4_S_5_A1 = EXT VIA5_S_5_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION // VIA5s space smaller than 0.49 (inside small array)  
  VIA5_Violate_S_5_A1 = VIA5_S_5_A1 INTERACT VIA5_Reg_4_S_5_A1  





  
// Rule Check    
//**************************************
  CONNECT VIA1_5stack.Final VIA1_Violate_S_5_A1
  CONNECT VIA1_5stack.Final VIA2_Violate_S_5_A1
  CONNECT VIA1_5stack.Final VIA3_Violate_S_5_A1
  CONNECT VIA1_5stack.Final VIA4_Violate_S_5_A1
  CONNECT VIA1_5stack.Final VIA5_Violate_S_5_A1

VIA1.S.2_Array1_2_3_4_5_M {@Minimum space between two VIAs in 5-level continuous stacking VIA arrays with below condition. >=0.49um
    @ Via1 violate VIA_S_3 spacing in Via1/Via2/Via3/Via4/Via5 array & density large or equal VIA_D_1 
  A1 = NET AREA RATIO VIA1_Violate_S_5_A1 VIA1_5stack.Final >= VIA_D_1
  A2 = NET AREA RATIO VIA2_Violate_S_5_A1 VIA1_5stack.Final >= VIA_D_1
  A3 = NET AREA RATIO VIA3_Violate_S_5_A1 VIA1_5stack.Final >= VIA_D_1
  A4 = NET AREA RATIO VIA4_Violate_S_5_A1 VIA1_5stack.Final >= VIA_D_1
  B1 = ((A1 OR A2) OR A3) OR A4
  SIZE B1 BY VIA_Merge OVERUNDER 
}




//**********************  
// Small 4 stack array
//**********************
// Processing for SAME Array Size Check    
//**************************************
  VIA1_4stack.pre3 = ENCLOSE RECTANGLE VIA1_same_array_4stack.pre2 VIA_S_2L VIA_W_1  // Find at least one width >= VIA_W_1
  VIA1_Reg_3_S_4 = EXT VIA1_4stack.pre3 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90
  VIA1_Reg_3_S_4_1 = ENCLOSE RECTANGLE VIA1_Reg_3_S_4 0.005 VIA_S_2L // Find parallel run length >= VIA_S_2L
  VIA1_4stack.pre4 = VIA1_4stack.pre3 INTERACT VIA1_Reg_3_S_4_1
  VIA1ArrayS1_S_4 = EXT VIA1_4stack.pre4 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90    // Space of different "smae array" smaller than VIA_S_2
  VIA1ArrayS2_S_4 = (((VIA1ArrayS1_S_4 NOT INSIDE M1) NOT INSIDE M2) NOT INSIDE M3) NOT INSIDE M4
  VIA1_4stack.Final = VIA1_4stack.pre4 INTERACT VIA1ArrayS2_S_4

  VIA1_S_4_A1 = VIA1 INTERACT VIA1_4stack.Final 
  VIA1_Reg_4_S_4_A1 = EXT VIA1_S_4_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION               // VIA1s space smaller than 0.49 (inside small array)  
  VIA1_Violate_S_4_A1= VIA1_S_4_A1 INTERACT VIA1_Reg_4_S_4_A1                 
  VIA2_S_4_A1 = VIA2 INTERACT VIA1_4stack.Final 
  VIA2_Reg_4_S_4_A1 = EXT VIA2_S_4_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION             // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_4_A1 = VIA2_S_4_A1 INTERACT VIA2_Reg_4_S_4_A1  
  VIA3_S_4_A1 = VIA3 INTERACT VIA1_4stack.Final 
  VIA3_Reg_4_S_4_A1 = EXT VIA3_S_4_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION           // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_4_A1 = VIA3_S_4_A1 INTERACT VIA3_Reg_4_S_4_A1  
  VIA4_S_4_A1 = VIA4 INTERACT VIA1_4stack.Final 
  VIA4_Reg_4_S_4_A1 = EXT VIA4_S_4_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION           // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_4_A1 = VIA4_S_4_A1 INTERACT VIA4_Reg_4_S_4_A1  


  VIA2_4stack.pre3 = ENCLOSE RECTANGLE VIA2_same_array_4stack.pre2 VIA_S_2L VIA_W_1  // Find at least one width >= VIA_W_1
  VIA2_Reg_3_S_4 = EXT VIA2_4stack.pre3 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90
  VIA2_Reg_3_S_4_1 = ENCLOSE RECTANGLE VIA2_Reg_3_S_4 0.005 VIA_S_2L // Find parallel run length >= VIA_S_2L
  VIA2_4stack.pre4 = VIA2_4stack.pre3 INTERACT VIA2_Reg_3_S_4_1
  VIA2ArrayS1_S_4 = EXT VIA2_4stack.pre4 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90    // Space of different "smae array" smaller than VIA_S_2
  VIA2ArrayS2_S_4 = (((VIA2ArrayS1_S_4 NOT INSIDE M2) NOT INSIDE M3) NOT INSIDE M4) NOT INSIDE M5
  VIA2_4stack.Final = VIA2_4stack.pre4 INTERACT VIA2ArrayS2_S_4

  VIA2_S_4_A2 = VIA2 INTERACT VIA2_4stack.Final 
  VIA2_Reg_4_S_4_A2 = EXT VIA2_S_4_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION               // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_4_A2= VIA2_S_4_A2 INTERACT VIA2_Reg_4_S_4_A2                 
  VIA3_S_4_A2 = VIA3 INTERACT VIA2_4stack.Final 
  VIA3_Reg_4_S_4_A2 = EXT VIA3_S_4_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION             // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_4_A2 = VIA3_S_4_A2 INTERACT VIA3_Reg_4_S_4_A2  
  VIA4_S_4_A2 = VIA4 INTERACT VIA2_4stack.Final 
  VIA4_Reg_4_S_4_A2 = EXT VIA4_S_4_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION           // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_4_A2 = VIA4_S_4_A2 INTERACT VIA4_Reg_4_S_4_A2  
  VIA5_S_4_A2 = VIA5 INTERACT VIA2_4stack.Final 
  VIA5_Reg_4_S_4_A2 = EXT VIA5_S_4_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION           // VIA5s space smaller than 0.49 (inside small array)  
  VIA5_Violate_S_4_A2 = VIA5_S_4_A2 INTERACT VIA5_Reg_4_S_4_A2  



// Rule Check    
//**************************************
  CONNECT VIA1_4stack.Final VIA1_Violate_S_4_A1
  CONNECT VIA1_4stack.Final VIA2_Violate_S_4_A1
  CONNECT VIA1_4stack.Final VIA3_Violate_S_4_A1
  CONNECT VIA1_4stack.Final VIA4_Violate_S_4_A1
  CONNECT VIA2_4stack.Final VIA2_Violate_S_4_A2
  CONNECT VIA2_4stack.Final VIA3_Violate_S_4_A2
  CONNECT VIA2_4stack.Final VIA4_Violate_S_4_A2
  CONNECT VIA2_4stack.Final VIA5_Violate_S_4_A2

VIA1.S.3_Array1_2_3_4_M { @ Minimum space between two VIAs in 4-level continuous stacking VIA arrays with below condition >=0.49um
                               @ Via1 violate VIA_S_3 spacing in Via1/Via2/Via3/Via4 array & density large or equal VIA_D_1 
  A1 = NET AREA RATIO VIA1_Violate_S_4_A1 VIA1_4stack.Final >= VIA_D_1
  A2 = NET AREA RATIO VIA2_Violate_S_4_A1 VIA1_4stack.Final >= VIA_D_1
  A3 = NET AREA RATIO VIA3_Violate_S_4_A1 VIA1_4stack.Final >= VIA_D_1
  A4 = NET AREA RATIO VIA4_Violate_S_4_A1 VIA1_4stack.Final >= VIA_D_1
  B1 = ((A1 OR A2) OR A3) OR A4
  SIZE B1 BY VIA_Merge OVERUNDER 
}

VIA2.S.3_Array2_3_4_5_M { @ Minimum space between two VIAs in 4-level continuous stacking VIA arrays with below condition >=0.49um
                               @ Via2 violate VIA_S_3 spacing in Via2/Via3/Via4/Via5 array & density large or equal VIA_D_1 
  A2 = NET AREA RATIO VIA2_Violate_S_4_A2 VIA2_4stack.Final >= VIA_D_1
  A3 = NET AREA RATIO VIA3_Violate_S_4_A2 VIA2_4stack.Final >= VIA_D_1
  A4 = NET AREA RATIO VIA4_Violate_S_4_A2 VIA2_4stack.Final >= VIA_D_1
  B2 = (A2 OR A3) OR A4
  SIZE B2 BY VIA_Merge OVERUNDER 
}




//**********************  
// Small 3 stack array
//**********************
// Processing for SAME Array Size Check    
//**************************************
  VIA1_3stack.pre3 = ENCLOSE RECTANGLE VIA1_same_array_3stack.pre2 VIA_S_2L VIA_W_1    // Find at least one width >=VIA_W_1
  VIA1_Reg_3_S_3 = EXT VIA1_3stack.pre3 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90
  VIA1_Reg_3_S_3_1 = ENCLOSE RECTANGLE VIA1_Reg_3_S_3 0.005 VIA_S_2L // Find parallel run length >= VIA_S_2L
  VIA1_3stack.pre4 = VIA1_3stack.pre3 INTERACT VIA1_Reg_3_S_3_1 // Find parallel run length >= VIA_S_2L
  VIA1ArrayS1_S_3 = EXT VIA1_3stack.pre4 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90  // Space of different "smae array" smaller than VIA_S_2
  VIA1ArrayS2_S_3 = ((VIA1ArrayS1_S_3 NOT INSIDE M1) NOT INSIDE M2) NOT INSIDE M3
  VIA1_3stack.Final = VIA1_3stack.pre4 INTERACT VIA1ArrayS2_S_3
  
  VIA1_S_3_A1 = VIA1 INTERACT VIA1_3stack.Final 
  VIA1_Reg_4_S_3_A1 = EXT VIA1_S_3_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION               // VIA1s space smaller than 0.49 (inside small array)  
  VIA1_Violate_S_3_A1= VIA1_S_3_A1 INTERACT VIA1_Reg_4_S_3_A1                 
  VIA2_S_3_A1 = VIA2 INTERACT VIA1_3stack.Final 
  VIA2_Reg_4_S_3_A1 = EXT VIA2_S_3_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION             // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_3_A1 = VIA2_S_3_A1 INTERACT VIA2_Reg_4_S_3_A1  
  VIA3_S_3_A1 = VIA3 INTERACT VIA1_3stack.Final 
  VIA3_Reg_4_S_3_A1 = EXT VIA3_S_3_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION           // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_3_A1 = VIA3_S_3_A1 INTERACT VIA3_Reg_4_S_3_A1  

  
  VIA2_3stack.pre3 = ENCLOSE RECTANGLE VIA2_same_array_3stack.pre2 VIA_S_2L VIA_W_1    // Find at least one width >=VIA_W_1
  VIA2_Reg_3_S_3 = EXT VIA2_3stack.pre3 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90
  VIA2_Reg_3_S_3_1 = ENCLOSE RECTANGLE VIA2_Reg_3_S_3 0.005 VIA_S_2L // Find parallel run length >= VIA_S_2L
  VIA2_3stack.pre4 = VIA2_3stack.pre3 INTERACT VIA2_Reg_3_S_3_1 // Find parallel run length >= VIA_S_2L
  VIA2ArrayS1_S_3 = EXT VIA2_3stack.pre4 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90  // Space of different "smae array" smaller than VIA_S_2
  VIA2ArrayS2_S_3 = ((VIA2ArrayS1_S_3 NOT INSIDE M2) NOT INSIDE M3) NOT INSIDE M4
  VIA2_3stack.Final = VIA2_3stack.pre4 INTERACT VIA2ArrayS2_S_3
  
  VIA2_S_3_A2 = VIA2 INTERACT VIA2_3stack.Final 
  VIA2_Reg_4_S_3_A2 = EXT VIA2_S_3_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION               // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_3_A2= VIA2_S_3_A2 INTERACT VIA2_Reg_4_S_3_A2                 
  VIA3_S_3_A2 = VIA3 INTERACT VIA2_3stack.Final 
  VIA3_Reg_4_S_3_A2 = EXT VIA3_S_3_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION             // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_3_A2 = VIA3_S_3_A2 INTERACT VIA3_Reg_4_S_3_A2  
  VIA4_S_3_A2 = VIA4 INTERACT VIA2_3stack.Final 
  VIA4_Reg_4_S_3_A2 = EXT VIA4_S_3_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION           // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_3_A2 = VIA4_S_3_A2 INTERACT VIA4_Reg_4_S_3_A2  

  
  VIA3_3stack.pre3 = ENCLOSE RECTANGLE VIA3_same_array_3stack.pre2 VIA_S_2L VIA_W_1    // Find at least one width >=VIA_W_1
  VIA3_Reg_3_S_3 = EXT VIA3_3stack.pre3 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90
  VIA3_Reg_3_S_3_1 = ENCLOSE RECTANGLE VIA3_Reg_3_S_3 0.005 VIA_S_2L // Find parallel run length >= VIA_S_2L
  VIA3_3stack.pre4 = VIA3_3stack.pre3 INTERACT VIA3_Reg_3_S_3_1 // Find parallel run length >= VIA_S_2L
  VIA3ArrayS1_S_3 = EXT VIA3_3stack.pre4 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90  // Space of different "smae array" smaller than VIA_S_2
  VIA3ArrayS2_S_3 = ((VIA3ArrayS1_S_3 NOT INSIDE M3) NOT INSIDE M4) NOT INSIDE M5
  VIA3_3stack.Final = VIA3_3stack.pre4 INTERACT VIA3ArrayS2_S_3
  
  VIA3_S_3_A3 = VIA3 INTERACT VIA3_3stack.Final 
  VIA3_Reg_4_S_3_A3 = EXT VIA3_S_3_A3 < VIA_S_3 ABUT < 90 SINGULAR REGION               // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_3_A3= VIA3_S_3_A3 INTERACT VIA3_Reg_4_S_3_A3                 
  VIA4_S_3_A3 = VIA4 INTERACT VIA3_3stack.Final 
  VIA4_Reg_4_S_3_A3 = EXT VIA4_S_3_A3 < VIA_S_3 ABUT < 90 SINGULAR REGION             // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_3_A3 = VIA4_S_3_A3 INTERACT VIA4_Reg_4_S_3_A3  
  VIA5_S_3_A3 = VIA5 INTERACT VIA3_3stack.Final 
  VIA5_Reg_4_S_3_A3 = EXT VIA5_S_3_A3 < VIA_S_3 ABUT < 90 SINGULAR REGION           // VIA5s space smaller than 0.49 (inside small array)  
  VIA5_Violate_S_3_A3 = VIA5_S_3_A3 INTERACT VIA5_Reg_4_S_3_A3  

  

// Rule Check    
//**************************************
  CONNECT VIA1_3stack.Final VIA1_Violate_S_3_A1
  CONNECT VIA1_3stack.Final VIA2_Violate_S_3_A1
  CONNECT VIA1_3stack.Final VIA3_Violate_S_3_A1
  CONNECT VIA2_3stack.Final VIA2_Violate_S_3_A2
  CONNECT VIA2_3stack.Final VIA3_Violate_S_3_A2
  CONNECT VIA2_3stack.Final VIA4_Violate_S_3_A2
  CONNECT VIA3_3stack.Final VIA3_Violate_S_3_A3
  CONNECT VIA3_3stack.Final VIA4_Violate_S_3_A3
  CONNECT VIA3_3stack.Final VIA5_Violate_S_3_A3

VIA1.S.4_Array1_2_3_M { @ Minimum space between two VIAs in 3-level continuous stacking VIA arrays with below condition >=0.49um
                           @ Via1 violate VIA_S_3 spacing in Via1/Via2/Via3 array & density large or equal VIA_D_1 
  A1 = NET AREA RATIO VIA1_Violate_S_3_A1 VIA1_3stack.Final >= VIA_D_1
  A2 = NET AREA RATIO VIA2_Violate_S_3_A1 VIA1_3stack.Final >= VIA_D_1
  A3 = NET AREA RATIO VIA3_Violate_S_3_A1 VIA1_3stack.Final >= VIA_D_1
  B1 = (A1 OR A2) OR A3
  SIZE B1 BY VIA_Merge OVERUNDER 
}

VIA2.S.4_Array2_3_4_M { @ Minimum space between two VIAs in 3-level continuous stacking VIA arrays with below condition >=0.49um
                           @ Via2 violate VIA_S_3 spacing in Via2/Via3/Via4 array & density large or equal VIA_D_1 
  A2 = NET AREA RATIO VIA2_Violate_S_3_A2 VIA2_3stack.Final >= VIA_D_1
  A3 = NET AREA RATIO VIA3_Violate_S_3_A2 VIA2_3stack.Final >= VIA_D_1
  A4 = NET AREA RATIO VIA4_Violate_S_3_A2 VIA2_3stack.Final >= VIA_D_1
  B2 = (A2 OR A3) OR A4
  SIZE B2 BY VIA_Merge OVERUNDER 
}

VIA3.S.4_Array3_4_5_M { @ Minimum space between two VIAs in 3-level continuous stacking VIA arrays with below condition >=0.49um
                           @ Via3 violate VIA_S_3 spacing in Via3/Via4/Via5 array & density large or equal VIA_D_1 
  A3 = NET AREA RATIO VIA3_Violate_S_3_A3 VIA3_3stack.Final >= VIA_D_1
  A4 = NET AREA RATIO VIA4_Violate_S_3_A3 VIA3_3stack.Final >= VIA_D_1
  B3 = A3 OR A4
  SIZE B3 BY VIA_Merge OVERUNDER 
}




//**********************  
// Small 2 stack array
//**********************
// Processing for SAME Array Size Check    
//**************************************
  VIA1_2stack.pre3 = ENCLOSE RECTANGLE VIA1_same_array_2stack.pre2 VIA_S_2L VIA_W_1 // Find at least one width >= VIA_W_1
  VIA1_Reg_3_S_2 = EXT VIA1_2stack.pre3 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90
  VIA1_Reg_3_S_2_1 = ENCLOSE RECTANGLE VIA1_Reg_3_S_2 0.005 VIA_S_2L // Find parallel run length >= VIA_S_2L 
  VIA1_2stack.pre4 = VIA1_2stack.pre3 INTERACT VIA1_Reg_3_S_2_1  // Find parallel run length >= VIA_S_2L
  VIA1ArrayS1_S_2 = EXT VIA1_2stack.pre4 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90  // Space of different "smae array" smaller than >= VIA_S_2
  VIA1ArrayS2_S_2 = (VIA1ArrayS1_S_2 NOT INSIDE M1) NOT INSIDE M2
  VIA1_2stack.Final = VIA1_2stack.pre4 INTERACT VIA1ArrayS2_S_2
  
  VIA1_S_2_A1 = VIA1 INTERACT VIA1_2stack.Final 
  VIA1_Reg_4_S_2_A1 = EXT VIA1_S_2_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION               // VIA1s space smaller than 0.49 (inside small array)  
  VIA1_Violate_S_2_A1= VIA1_S_2_A1 INTERACT VIA1_Reg_4_S_2_A1                 
  VIA2_S_2_A1 = VIA2 INTERACT VIA1_2stack.Final 
  VIA2_Reg_4_S_2_A1 = EXT VIA2_S_2_A1 < VIA_S_3 ABUT < 90 SINGULAR REGION             // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_2_A1 = VIA2_S_2_A1 INTERACT VIA2_Reg_4_S_2_A1  


  VIA2_2stack.pre3 = ENCLOSE RECTANGLE VIA2_same_array_2stack.pre2 VIA_S_2L VIA_W_1 // Find at least one width >= VIA_W_1
  VIA2_Reg_3_S_2 = EXT VIA2_2stack.pre3 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90
  VIA2_Reg_3_S_2_1 = ENCLOSE RECTANGLE VIA2_Reg_3_S_2 0.005 VIA_S_2L // Find parallel run length >= VIA_S_2L 
  VIA2_2stack.pre4 = VIA2_2stack.pre3 INTERACT VIA2_Reg_3_S_2_1  // Find parallel run length >= VIA_S_2L
  VIA2ArrayS1_S_2 = EXT VIA2_2stack.pre4 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90  // Space of different "smae array" smaller than >= VIA_S_2
  VIA2ArrayS2_S_2 = (VIA2ArrayS1_S_2 NOT INSIDE M2) NOT INSIDE M3
  VIA2_2stack.Final = VIA2_2stack.pre4 INTERACT VIA2ArrayS2_S_2
  
  VIA2_S_2_A2 = VIA2 INTERACT VIA2_2stack.Final 
  VIA2_Reg_4_S_2_A2 = EXT VIA2_S_2_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION               // VIA2s space smaller than 0.49 (inside small array)  
  VIA2_Violate_S_2_A2= VIA2_S_2_A2 INTERACT VIA2_Reg_4_S_2_A2                 
  VIA3_S_2_A2 = VIA3 INTERACT VIA2_2stack.Final 
  VIA3_Reg_4_S_2_A2 = EXT VIA3_S_2_A2 < VIA_S_3 ABUT < 90 SINGULAR REGION             // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_2_A2 = VIA3_S_2_A2 INTERACT VIA3_Reg_4_S_2_A2  


  VIA3_2stack.pre3 = ENCLOSE RECTANGLE VIA3_same_array_2stack.pre2 VIA_S_2L VIA_W_1 // Find at least one width >= VIA_W_1
  VIA3_Reg_3_S_2 = EXT VIA3_2stack.pre3 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90
  VIA3_Reg_3_S_2_1 = ENCLOSE RECTANGLE VIA3_Reg_3_S_2 0.005 VIA_S_2L // Find parallel run length >= VIA_S_2L 
  VIA3_2stack.pre4 = VIA3_2stack.pre3 INTERACT VIA3_Reg_3_S_2_1  // Find parallel run length >= VIA_S_2L
  VIA3ArrayS1_S_2 = EXT VIA3_2stack.pre4 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90  // Space of different "smae array" smaller than >= VIA_S_2
  VIA3ArrayS2_S_2 = (VIA3ArrayS1_S_2 NOT INSIDE M3) NOT INSIDE M4
  VIA3_2stack.Final = VIA3_2stack.pre4 INTERACT VIA3ArrayS2_S_2
  
  VIA3_S_2_A3 = VIA3 INTERACT VIA3_2stack.Final 
  VIA3_Reg_4_S_2_A3 = EXT VIA3_S_2_A3 < VIA_S_3 ABUT < 90 SINGULAR REGION               // VIA3s space smaller than 0.49 (inside small array)  
  VIA3_Violate_S_2_A3= VIA3_S_2_A3 INTERACT VIA3_Reg_4_S_2_A3                 
  VIA4_S_2_A3 = VIA4 INTERACT VIA3_2stack.Final 
  VIA4_Reg_4_S_2_A3 = EXT VIA4_S_2_A3 < VIA_S_3 ABUT < 90 SINGULAR REGION             // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_2_A3 = VIA4_S_2_A3 INTERACT VIA4_Reg_4_S_2_A3  


  VIA4_2stack.pre3 = ENCLOSE RECTANGLE VIA4_same_array_2stack.pre2 VIA_S_2L VIA_W_1 // Find at least one width >= VIA_W_1
  VIA4_Reg_3_S_2 = EXT VIA4_2stack.pre3 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90
  VIA4_Reg_3_S_2_1 = ENCLOSE RECTANGLE VIA4_Reg_3_S_2 0.005 VIA_S_2L // Find parallel run length >= VIA_S_2L 
  VIA4_2stack.pre4 = VIA4_2stack.pre3 INTERACT VIA4_Reg_3_S_2_1  // Find parallel run length >= VIA_S_2L
  VIA4ArrayS1_S_2 = EXT VIA4_2stack.pre4 <= VIA_S_2 SINGULAR OPPOSITE REGION ABUT < 90  // Space of different "smae array" smaller than >= VIA_S_2
  VIA4ArrayS2_S_2 = (VIA4ArrayS1_S_2 NOT INSIDE M4) NOT INSIDE M5
  VIA4_2stack.Final = VIA4_2stack.pre4 INTERACT VIA4ArrayS2_S_2
  
  VIA4_S_2_A4 = VIA4 INTERACT VIA4_2stack.Final 
  VIA4_Reg_4_S_2_A4 = EXT VIA4_S_2_A4 < VIA_S_3 ABUT < 90 SINGULAR REGION               // VIA4s space smaller than 0.49 (inside small array)  
  VIA4_Violate_S_2_A4= VIA4_S_2_A4 INTERACT VIA4_Reg_4_S_2_A4                 
  VIA5_S_2_A4 = VIA5 INTERACT VIA4_2stack.Final 
  VIA5_Reg_4_S_2_A4 = EXT VIA5_S_2_A4 < VIA_S_3 ABUT < 90 SINGULAR REGION             // VIA5s space smaller than 0.49 (inside small array)  
  VIA5_Violate_S_2_A4 = VIA5_S_2_A4 INTERACT VIA5_Reg_4_S_2_A4  



// Rule Check    
//**************************************
  CONNECT VIA1_2stack.Final VIA1_Violate_S_2_A1
  CONNECT VIA1_2stack.Final VIA2_Violate_S_2_A1
  CONNECT VIA2_2stack.Final VIA2_Violate_S_2_A2
  CONNECT VIA2_2stack.Final VIA3_Violate_S_2_A2
  CONNECT VIA3_2stack.Final VIA3_Violate_S_2_A3
  CONNECT VIA3_2stack.Final VIA4_Violate_S_2_A3
  CONNECT VIA4_2stack.Final VIA4_Violate_S_2_A4
  CONNECT VIA4_2stack.Final VIA5_Violate_S_2_A4
  
VIA1.S.5_Array1_2_M { @ Minimum space between two VIAs in 2-level continuous stacking VIA arrays with below condition >=0.49um
                       @ Via1 violate VIA_S_3 spacing in Via1/Via2 array & density large or equal VIA_D_1 
  A1 = NET AREA RATIO VIA1_Violate_S_2_A1 VIA1_2stack.Final >= VIA_D_1
  A2 = NET AREA RATIO VIA2_Violate_S_2_A1 VIA1_2stack.Final >= VIA_D_1
  B1 = A1 OR A2
  SIZE B1 BY VIA_Merge OVERUNDER 
}

VIA2.S.5_Array2_3_M { @ Minimum space between two VIAs in 2-level continuous stacking VIA arrays with below condition >=0.49um
                       @ Via2 violate VIA_S_3 spacing in Via2/Via3 array & density large or equal VIA_D_1 
  A2 = NET AREA RATIO VIA2_Violate_S_2_A2 VIA2_2stack.Final >= VIA_D_1
  A3 = NET AREA RATIO VIA3_Violate_S_2_A2 VIA2_2stack.Final >= VIA_D_1
  B2 = A2 OR A3
  SIZE B2 BY VIA_Merge OVERUNDER 
}

VIA3.S.5_Array3_4_M { @ Minimum space between two VIAs in 2-level continuous stacking VIA arrays with below condition >=0.49um
                       @ Via3 violate VIA_S_3 spacing in Via3/Via4 array & density large or equal VIA_D_1 
  A3 = NET AREA RATIO VIA3_Violate_S_2_A3 VIA3_2stack.Final >= VIA_D_1
  A4 = NET AREA RATIO VIA4_Violate_S_2_A3 VIA3_2stack.Final >= VIA_D_1
  B3 = A3 OR A4
  SIZE B3 BY VIA_Merge OVERUNDER 
}

VIA4.S.5_Array4_5_M { @ Minimum space between two VIAs in 2-level continuous stacking VIA arrays with below condition >=0.49um
                       @ Via4 violate VIA_S_3 spacing in Via4/Via5 array & density large or equal VIA_D_1 
  A4 = NET AREA RATIO VIA4_Violate_S_2_A4 VIA4_2stack.Final >= VIA_D_1
  SIZE A4 BY VIA_Merge OVERUNDER 
}





CB_CUP = CB INTERACT WBDMY

// VIA5 checks
//=============

VIA5R = VIA5 OUTSIDE CB_CUP
VIA5R_CORE = VIA5R NOT SR_VIA5
VIA5.W.1 { @ VIA5 must be 0.36 x 0.36
  A = NOT RECTANGLE VIA5R_CORE == 0.36 BY == 0.36 ORTHOGONAL ONLY
  A OUTSIDE RNGX     // exclude from metal fuse protection ring area
}
VIA5.S.1 { @ Min. VIA5 spacing < 0.35
  EXT VIA5R < 0.35 ABUT < 90 SINGULAR REGION
}
VIA5.E.1 { @ Min. extension of a M5 region beyond a VIA5 region < 0.01
  ENC VIA5R M5 < 0.01 ABUT < 90 SINGULAR REGION
  VIA5R NOT M5    
}
VIA5.E.2 { @ Min. extension of a M5 end-of-line region beyond VIA5 region < 0.06
  X = ENC [VIA5R] M5 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.36 ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}

#IFDEF CHECK_ALRDL
#IFNDEF THICK_20K
#IFNDEF THICK_40K

// VIAD checks
//=============

VIADR = VIAD OUTSIDE CB_CUP
VIADR_CORE = VIADR NOT SR_VIAD
VIAD.W.1 { @ VIAD must be 0.36 x 0.36
  A = NOT RECTANGLE VIADR_CORE == 0.36 BY == 0.36 ORTHOGONAL ONLY
  A OUTSIDE RNGX     // exclude from metal fuse protection ring area
}
VIAD.S.1 { @ Min. VIAD spacing < 0.35
  EXT VIADR < 0.35 ABUT < 90 SINGULAR REGION
}
VIAD.E.1 { @ Min. extension of a M6 region beyond a VIAD region < 0.01
  ENC VIADR M6 < 0.01 ABUT < 90 SINGULAR REGION
  VIADR NOT M6    
}
VIAD.E.2 { @ Min. extension of a M6 end-of-line region beyond VIAD region < 0.06
  X = ENC [VIADR] M6 < 0.06 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.36 ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}
#ENDIF
#ENDIF
#ENDIF






#IFNDEF THICK_20K
#IFNDEF THICK_40K


// M6 checks
//=============
M6.W.1 { @ Min. M6 width < 0.44
  INT M6 < 0.44 ABUT < 90 SINGULAR REGION
}
M6.S.1 { @ Min. M6 space < 0.46
  EXT M6 < 0.46 ABUT < 90 SINGULAR REGION
}
M6.S.2 { @ Min. space to wide M6 (>10um) < 0.6
  M6_S5 = SHRINK (SHRINK (SHRINK (SHRINK M6 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M6_G5 = GROW (GROW (GROW (GROW M6_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  M6_Wide = M6_G5 AND M6
  M6_Exp = SIZE M6_Wide BY 1 INSIDE OF M6 STEP 0.322
  M6_Branch = M6_Exp NOT M6_Wide
  M6_Branch_edge = M6_Branch COIN INSIDE EDGE M6
  M6_Check = M6 AND (SIZE M6_Exp BY 0.6)
  M6_Branch_Check = M6 AND (EXPAND EDGE M6_Branch_edge OUTSIDE BY 0.6 CORNER FILL)
  M6_WideC = STAMP M6_Wide BY M6xd
  M6_CheckC = STAMP M6_Check BY M6xd
  M6_BranchC = STAMP M6_Branch BY M6xd
  M6_Branch_CheckC = STAMP M6_Branch_Check BY M6xd
  EXT M6_WideC M6_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M6_BranchC M6_Branch_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
}
M6.E.1 { @ Min. extension of a M6 region beyond a VIA5 region < 0.09
   ENC VIA5 M6 < 0.09 ABUT<90 SINGULAR 
   VIA5 NOT M6    
}
M6.A.1 { @ Min. M6 area region < 0.562
  AREA M6 < 0.562
}



#IFDEF CHECK_ALRDL
// MD checks
//=============
MD.W.1 { @ Min. MD width < 0.44
  INT MD < 0.44 ABUT < 90 SINGULAR REGION
}
MD.S.1 { @ Min. MD space < 0.46
  EXT MD < 0.46 ABUT < 90 SINGULAR REGION
}
MD.S.2 { @ Min. space to wide MD (>10um) < 0.6
  MD_S5 = SHRINK (SHRINK (SHRINK (SHRINK MD RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  MD_G5 = GROW (GROW (GROW (GROW MD_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
  MD_Wide = MD_G5 AND MD
  MD_Exp = SIZE MD_Wide BY 1 INSIDE OF MD STEP 0.322
  MD_Branch = MD_Exp NOT MD_Wide
  MD_Branch_edge = MD_Branch COIN INSIDE EDGE MD
  MD_Check = MD AND (SIZE MD_Exp BY 0.6)
  MD_Branch_Check = MD AND (EXPAND EDGE MD_Branch_edge OUTSIDE BY 0.6 CORNER FILL)
  MD_WideC = STAMP MD_Wide BY MDxd
  MD_CheckC = STAMP MD_Check BY MDxd
  MD_BranchC = STAMP MD_Branch BY MDxd
  MD_Branch_CheckC = STAMP MD_Branch_Check BY MDxd
  EXT MD_WideC MD_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT MD_BranchC MD_Branch_CheckC < 0.6 ABUT >0 <89.5 NOT CONNECTED REGION
}
MD.E.1 { @ Min. extension of a MD region beyond a VIAD region < 0.09
   ENC VIAD MD < 0.09 ABUT<90 SINGULAR 
   VIAD NOT MD    
}
MD.A.1 { @ Min. MD area region < 0.562
  AREA MD < 0.562
}
#ENDIF
#ENDIF
#ENDIF






// METAL RATIO CHECKS
//======================
PO.R.3 {@ Min poly area coverage < 14%
  ALL_POLY = POLYi OR DPO
  DENSITY ALL_POLY < 0.14 PRINT POLY_DENSITY.log
}
M1.R.1 { @ Min M1 area coverage < 30%
  DENSITY M1xd < 0.3 PRINT M1_DENSITY.log
}

M2.R.1 { @ Min M2 area coverage < 30%
  DENSITY M2xd < 0.3 PRINT M2_DENSITY.log
}

M3.R.1 { @ Min M3 area coverage < 30%
  DENSITY M3xd < 0.3 PRINT M3_DENSITY.log
}

M4.R.1 { @ Min M4 area coverage < 30%
  DENSITY M4xd < 0.3 PRINT M4_DENSITY.log
}

M5.R.1 { @ Min M5 area coverage < 30%
  DENSITY M5xd < 0.3 PRINT M5_DENSITY.log
}


#IFNDEF THICK_20K
#IFNDEF THICK_40K
M6.R.1 { @ Min M6 area coverage < 30%
  DENSITY M6xd < 0.3 PRINT M6_DENSITY.log
}
MD.R.1 { @ Min MD area coverage < 30%
  DENSITY MDxd > 0 < 0.3 PRINT MD_DENSITY.log
}  

#ENDIF
#ENDIF





// Dummy Pad
//==========

GROUP DUMMY_PAD_CHECK ADP.S.2g ADP.W.3g ADP.W.4g

DP_V1 = DPDMY AND VIA1
DP_V2 = DPDMY AND VIA2
DP_V3 = DPDMY AND VIA3
DP_V4 = DPDMY AND VIA4
DP_V5 = DPDMY AND VIA5
DP_VD = DPDMY AND VIAD

ADP.R.0A { @ chip corner dummy pad structure should be M1/M2.../M6
  DPDMY NOT M1
  DPDMY NOT M2
  DPDMY NOT M3
  DPDMY NOT M4
  DPDMY NOT M5
  DPDMY NOT M6
}  

ADP.R.0B { @ chip corner dummy pad structure should be VIA1/VIA2.../VIA6
  DPDMY NOT ENCLOSE VIA1
  DPDMY NOT ENCLOSE VIA2
  DPDMY NOT ENCLOSE VIA3
  DPDMY NOT ENCLOSE VIA4
  DPDMY NOT ENCLOSE VIA5
}

ADP.R.0C { @ Via structure in Dummy Pad
  GRP1 = (DP_V2 OR DP_V4) OR DP_VD
  GRP2 = (DP_V1 OR DP_V3) OR DP_V5
  GRP1 AND GRP2
}
ADP.S.1_VIA1 { @ Via1 spacing (the same level) < 0.58um.
  EXT DP_V1 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_VIA2 { @ Via2 spacing (the same level) < 0.58um.
  EXT DP_V2 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_VIA3 { @ Via3 spacing (the same level) < 0.58um.
  EXT DP_V3 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_VIA4 { @ Via4 spacing (the same level) < 0.58um.
  EXT DP_V4 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_VIA5 { @ Via5 spacing (the same level) < 0.58um.
  EXT DP_V5 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_VIAD { @ ViaD spacing (the same level) < 0.58um.
  EXT DP_VD < 0.58 ABUT<90 SINGULAR REGION
}

ADP.C.1_V1_V2 { @ Vias spacing (different level) < 0.23um.
  EXT DP_V1 DP_V2 < 0.23 ABUT<90 SINGULAR REGION
}
ADP.C.1_V2_V3 { @ Vias spacing (different level) < 0.23um.
  EXT DP_V2 DP_V3 < 0.23 ABUT<90 SINGULAR REGION
}
ADP.C.1_V3_V4 { @ Vias spacing (different level) < 0.23um.
  EXT DP_V3 DP_V4 < 0.23 ABUT<90 SINGULAR REGION
}

ADP.C.2_V4_V5 { @ Via4 and Via5 spacing < 0.16um.
  EXT DP_V4 DP_V5 < 0.16 ABUT<90 SINGULAR REGION
}
ADP.C.2_V5_VD { @ Via5 and ViaD spacing < 0.16um.
  EXT DP_V5 DP_VD < 0.16 ABUT<90 SINGULAR REGION
}

ADP.E.1_V1_M1 { @ Metal1 enclose Via1 in dummy pad < 3um.
  ENC DP_V1 M1 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_V1_M2 { @ Metal2 enclose Via1 in dummy pad < 3um.
  ENC DP_V1 M2 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_V2_M2 { @ Metal2 enclose Via2 in dummy pad < 3um.
  ENC DP_V2 M2 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_V2_M3 { @ Metal3 enclose Via2 in dummy pad < 3um.
  ENC DP_V2 M3 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_V3_M3 { @ Metal3 enclose Via3 in dummy pad < 3um.
  ENC DP_V3 M3 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_V3_M4 { @ Metal4 enclose Via3 in dummy pad < 3um.
  ENC DP_V3 M4 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_V4_M4 { @ Metal4 enclose Via4 in dummy pad < 3um.
  ENC DP_V4 M4 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_V4_M5 { @ Metal5 enclose Via4 in dummy pad < 3um.
  ENC DP_V4 M5 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_V5_M5 { @ Metal5 enclose Via5 in dummy pad < 3um.
  ENC DP_V5 M5 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_V5_M6 { @ Metal6 enclose Via5 in dummy pad < 3um.
  ENC DP_V5 M6 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_VD_M6 { @ Meta6l enclose ViaD in dummy pad < 3um.
  ENC DP_VD M6 < 3 ABUT<90 SINGULAR REGION
}
ADP.E.1_VD_MD { @ MD enclose ViaD in dummy pad < 3um.
  ENC DP_VD MD < 3 ABUT<90 SINGULAR REGION
}

// ADP.W.1 is checked by VIAx.W.1 ( x= 1..4)
// ADP.W.2 is checked by VIA5.W.1

// Guideline

ADP.S.2g { @ dummy pad spacing < 2um.
  EXT DPDMY < 2 ABUT<90 SINGULAR REGION
}

ADP.W.3g { @ dummy pad width > 80um
  DPADG = INT DPDMY <= 80 REGION OPPOSITE ABUT>0<90
  DPDMY NOT DPADG
}

ADP.W.4g { @ dummy pad width < 40um
  INT DPDMY < 40  ABUT>0<90 SINGULAR REGION
}



// Power Line
//===========

PL_V1 = PLDMY AND VIA1
PL_V2 = PLDMY AND VIA2
PL_V3 = PLDMY AND VIA3
PL_V4 = PLDMY AND VIA4
PL_V5 = PLDMY AND VIA5
PL_VD = PLDMY AND VIAD

ADP.R.0D { @ Via structure in Power Line
  GRP1 = (PL_V2 OR PL_V4) OR PL_VD
  GRP2 = (PL_V1 OR PL_V3) OR PL_V5
  GRP1 AND GRP2
}

ADP.S.1_PL_V1 { @ Via1 spacing (the same level) < 0.58um.
  EXT PL_V1 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_PL_V2 { @ Via2 spacing (the same level) < 0.58um.
  EXT PL_V2 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_PL_V3 { @ Via3 spacing (the same level) < 0.58um.
  EXT PL_V3 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_PL_V4 { @ Via4 spacing (the same level) < 0.58um.
  EXT PL_V4 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_PL_V5 { @ Via5 spacing (the same level) < 0.58um.
  EXT PL_V5 < 0.58 ABUT<90 SINGULAR REGION
}
ADP.S.1_PL_VD { @ ViaD spacing (the same level) < 0.58um.
  EXT PL_VD < 0.58 ABUT<90 SINGULAR REGION
}

ADP.C.1_PL_V1_V2 { @ Vias spacing (different level) < 0.23um.
  EXT PL_V1 PL_V2 < 0.23 ABUT<90 SINGULAR REGION
}
ADP.C.1_PL_V2_V3 { @ Vias spacing (different level) < 0.23um.
  EXT PL_V2 PL_V3 < 0.23 ABUT<90 SINGULAR REGION
}
ADP.C.1_PL_V3_V4 { @ Vias spacing (different level) < 0.23um.
  EXT PL_V3 PL_V4 < 0.23 ABUT<90 SINGULAR REGION
}
ADP.C.2_PL_V4_V5 { @ Via4 and Via5 spacing < 0.16um.
  EXT PL_V4 PL_V5 < 0.16 ABUT<90 SINGULAR REGION
}
ADP.C.2_PL_V5_VD { @ Via5 and ViaD spacing < 0.16um.
  EXT PL_V5 PL_VD < 0.16 ABUT<90 SINGULAR REGION
}

ADP.E.2_V1_M1 { @ Metal1 enclose Via1 in chip corner power line < 0.2um.
  ENC PL_V1 M1 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_V1_M2 { @ Metal2 enclose Via1 in chip corner power line < 0.2um.
  ENC PL_V1 M2 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_V2_M2 { @ Metal2 enclose Via2 in chip corner power line < 0.2um.
  ENC PL_V2 M2 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_V2_M3 { @ Metal3 enclose Via2 in chip corner power line < 0.2um.
  ENC PL_V2 M3 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_V3_M3 { @ Metal3 enclose Via3 in chip corner power line < 0.2um.
  ENC PL_V3 M3 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_V3_M4 { @ Metal4 enclose Via3 in chip corner power line < 0.2um.
  ENC PL_V3 M4 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_V4_M4 { @ Metal4 enclose Via4 in chip corner power line < 0.2um.
  ENC PL_V4 M4 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_V4_M5 { @ Metal5 enclose Via4 in chip corner power line < 0.2um.
  ENC PL_V4 M5 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_V5_M5 { @ Metal5 enclose Via5 in chip corner power line < 0.2um.
  ENC PL_V5 M5 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_V5_M6 { @ Metal6 enclose Via5 in chip corner power line < 0.2um.
  ENC PL_V5 M6 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_VD_M6 { @ Metal6 enclose ViaD in chip corner power line < 0.2um.
  ENC PL_VD M6 < 0.2 ABUT<90 SINGULAR REGION
}
ADP.E.2_VD_MD { @ MD enclose ViaD in chip corner power line < 0.2um.
  ENC PL_VD MD < 0.2 ABUT<90 SINGULAR REGION
}



//METAL SLOT CHECKS
//================
//Bonding pad ,chip corner dummy pad ,and inductor need not put slot
CB_NON_CUP = CBi NOT INTERACT WBDMY
SLT_EXD  = CB_NON_CUP OR DPDMY
SLT_EXDT = CBi OR DPDMY

PAD_EXD = UBMi NOT INTERACT MDxd

M1EXD = M1xd NOT SLT_EXD

//M1 SLOT CHECKS
//==============

M1InnerHole = HOLES M1EXD INNER
M1BigHole   = SIZE M1InnerHole BY -5
M1Hole      = M1InnerHole OUTSIDE M1BigHole 
M1HoleSpace = M1Hole NOT M1EXD
FIM1c       = M1EXD OR M1HoleSpace
LM1XA       = (SIZE (SIZE FIM1c BY 1.0 UNDEROVER) BY 17.5 UNDEROVER TRUNCATE 17.5) AND FIM1c
LM1X        = ENCLOSE RECTANGLE LM1XA 35.005 35.005
M1HoleD    = M1HoleSpace AND LM1X

AMS.1.M1 { @ Wide Metal (>35um) must have slot.
  A = (SIZE ( SIZE M1EXD BY 1.0 UNDEROVER ) BY 17.5 UNDEROVER TRUNCATE 17.5 ) AND M1EXD
  ENCLOSE RECTANGLE A 35.005 35.005    
}

CONNECT M1HoleD LM1X
AMS.DN.M1 { @ Min. Hole density for metal lines that need to apply slot  1.5%
    NET AREA RATIO LM1X M1HoleD < 0.015
	[ AREA(M1HoleD) / AREA(LM1X) ] RDB M1Hole.density2 LM1X M1HoleD 
}
DISCONNECT

M2EXD = M2xd NOT SLT_EXD

//M2 SLOT CHECKS
//==============

M2InnerHole = HOLES M2EXD INNER
M2BigHole   = SIZE M2InnerHole BY -5
M2Hole      = M2InnerHole OUTSIDE M2BigHole 
M2HoleSpace = M2Hole NOT M2EXD
FIM2c       = M2EXD OR M2HoleSpace
LM2XA       = (SIZE (SIZE FIM2c BY 1.0 UNDEROVER) BY 17.5 UNDEROVER TRUNCATE 17.5) AND FIM2c
LM2X        = ENCLOSE RECTANGLE LM2XA 35.005 35.005
M2HoleD    = M2HoleSpace AND LM2X

AMS.1.M2 { @ Wide Metal (>35um) must have slot.
  A = (SIZE ( SIZE M2EXD BY 1.0 UNDEROVER ) BY 17.5 UNDEROVER TRUNCATE 17.5 ) AND M2EXD
  ENCLOSE RECTANGLE A 35.005 35.005    
}

CONNECT M2HoleD LM2X
AMS.DN.M2 { @ Min. Hole density for metal lines that need to apply slot  1.5%
    NET AREA RATIO LM2X M2HoleD < 0.015
	[ AREA(M2HoleD) / AREA(LM2X) ] RDB M2Hole.density2 LM2X M2HoleD 
}
DISCONNECT

M3EXD = M3xd NOT SLT_EXD

//M3 SLOT CHECKS
//==============

M3InnerHole = HOLES M3EXD INNER
M3BigHole   = SIZE M3InnerHole BY -5
M3Hole      = M3InnerHole OUTSIDE M3BigHole 
M3HoleSpace = M3Hole NOT M3EXD
FIM3c       = M3EXD OR M3HoleSpace
LM3XA       = (SIZE (SIZE FIM3c BY 1.0 UNDEROVER) BY 17.5 UNDEROVER TRUNCATE 17.5) AND FIM3c
LM3X        = ENCLOSE RECTANGLE LM3XA 35.005 35.005
M3HoleD    = M3HoleSpace AND LM3X

AMS.1.M3 { @ Wide Metal (>35um) must have slot.
  A = (SIZE ( SIZE M3EXD BY 1.0 UNDEROVER ) BY 17.5 UNDEROVER TRUNCATE 17.5 ) AND M3EXD
  ENCLOSE RECTANGLE A 35.005 35.005    
}

CONNECT M3HoleD LM3X
AMS.DN.M3 { @ Min. Hole density for metal lines that need to apply slot  1.5%
    NET AREA RATIO LM3X M3HoleD < 0.015
	[ AREA(M3HoleD) / AREA(LM3X) ] RDB M3Hole.density2 LM3X M3HoleD 
}
DISCONNECT

M4EXD = M4xd NOT SLT_EXD

//M4 SLOT CHECKS
//==============

M4InnerHole = HOLES M4EXD INNER
M4BigHole   = SIZE M4InnerHole BY -5
M4Hole      = M4InnerHole OUTSIDE M4BigHole 
M4HoleSpace = M4Hole NOT M4EXD
FIM4c       = M4EXD OR M4HoleSpace
LM4XA       = (SIZE (SIZE FIM4c BY 1.0 UNDEROVER) BY 17.5 UNDEROVER TRUNCATE 17.5) AND FIM4c
LM4X        = ENCLOSE RECTANGLE LM4XA 35.005 35.005
M4HoleD    = M4HoleSpace AND LM4X

AMS.1.M4 { @ Wide Metal (>35um) must have slot.
  A = (SIZE ( SIZE M4EXD BY 1.0 UNDEROVER ) BY 17.5 UNDEROVER TRUNCATE 17.5 ) AND M4EXD
  ENCLOSE RECTANGLE A 35.005 35.005    
}

CONNECT M4HoleD LM4X
AMS.DN.M4 { @ Min. Hole density for metal lines that need to apply slot  1.5%
    NET AREA RATIO LM4X M4HoleD < 0.015
	[ AREA(M4HoleD) / AREA(LM4X) ] RDB M4Hole.density2 LM4X M4HoleD 
}
DISCONNECT

M5EXD = M5xd NOT SLT_EXDT

//M5 SLOT CHECKS
//==============

M5InnerHole = HOLES M5EXD INNER
M5BigHole   = SIZE M5InnerHole BY -5
M5Hole      = M5InnerHole OUTSIDE M5BigHole 
M5HoleSpace = M5Hole NOT M5EXD
FIM5c       = M5EXD OR M5HoleSpace
LM5XA       = (SIZE (SIZE FIM5c BY 1.0 UNDEROVER) BY 17.5 UNDEROVER TRUNCATE 17.5) AND FIM5c
LM5X        = ENCLOSE RECTANGLE LM5XA 35.005 35.005
M5HoleD    = M5HoleSpace AND LM5X

AMS.1.M5 { @ Wide Metal (>35um) must have slot.
  A = (SIZE ( SIZE M5EXD BY 1.0 UNDEROVER ) BY 17.5 UNDEROVER TRUNCATE 17.5 ) AND M5EXD
  ENCLOSE RECTANGLE A 35.005 35.005    
}

CONNECT M5HoleD LM5X
AMS.DN.M5 { @ Min. Hole density for metal lines that need to apply slot  1.5%
    NET AREA RATIO LM5X M5HoleD < 0.015
	[ AREA(M5HoleD) / AREA(LM5X) ] RDB M5Hole.density2 LM5X M5HoleD 
}
DISCONNECT

PAD_EXD6 = SIZE PAD_EXD BY 2 INSIDE OF M6xd STEP 0.32 
M6EXD = M6xd NOT ( SLT_EXDT OR PAD_EXD6 )

//M6 SLOT CHECKS
//==============

M6InnerHole = HOLES M6EXD INNER
M6BigHole   = SIZE M6InnerHole BY -5
M6Hole      = M6InnerHole OUTSIDE M6BigHole 
M6HoleSpace = M6Hole NOT M6EXD
FIM6c       = M6EXD OR M6HoleSpace
LM6XA       = (SIZE (SIZE FIM6c BY 1.0 UNDEROVER) BY 17.5 UNDEROVER TRUNCATE 17.5) AND FIM6c
LM6X        = ENCLOSE RECTANGLE LM6XA 35.005 35.005
M6HoleD    = M6HoleSpace AND LM6X

AMS.1.M6 { @ Wide Metal (>35um) must have slot.
  A = (SIZE ( SIZE M6EXD BY 1.0 UNDEROVER ) BY 17.5 UNDEROVER TRUNCATE 17.5 ) AND M6EXD
  ENCLOSE RECTANGLE A 35.005 35.005    
}

CONNECT M6HoleD LM6X
AMS.DN.M6 { @ Min. Hole density for metal lines that need to apply slot  1.5%
    NET AREA RATIO LM6X M6HoleD < 0.015
	[ AREA(M6HoleD) / AREA(LM6X) ] RDB M6Hole.density2 LM6X M6HoleD 
}
DISCONNECT


//MD SLOT CHECKS
//==============
// Bonding pad, chip corner dummy pad, and inductor need not put slot

UBM_EXDD    = SIZE UBMi BY 2 INSIDE OF MDxd STEP 0.32 	// For RDL
MDEXD       = MDxd NOT ( DPDMY OR UBM_EXDD )
MDInnerHole = HOLES MDEXD INNER
MDBigHole   = SIZE MDInnerHole BY -5  	// Holes with width less than 10um will be filled back
MDHole      = MDInnerHole OUTSIDE MDBigHole	
MDHoleSpace = MDHole NOT MDEXD
FIMDc       = MDEXD OR MDHoleSpace
LMDXA       = (SIZE (SIZE FIMDc BY 1.0 UNDEROVER) BY 17.5 UNDEROVER TRUNCATE 17.5) AND FIMDc
LMDX        = ENCLOSE RECTANGLE LMDXA 35.005 35.005 
MDHoleD     = MDHoleSpace AND LMDX

AMS.1.MD { @ Wide Metal (>35um) must have slot
  A = (SIZE ( SIZE MDEXD BY 1.0 UNDEROVER ) BY 17.5 UNDEROVER TRUNCATE 17.5) AND MDEXD
  ENCLOSE RECTANGLE A 35.005 35.005    
}

CONNECT MDHoleD LMDX
AMS.DN.MD { @ Min. Hole density for metal lines that need to apply slot  1.5%
  NET AREA RATIO LMDX MDHoleD < 0.015
    [ AREA(MDHoleD) / AREA(LMDX) ] RDB MDHole.density2 LMDX MDHoleD 
}
DISCONNECT



//I/O ESD Guidance 
//================

EPACT = PACT AND SDI
ENACT = NACT AND SDI
ECO = (CO AND SDI) AND OD
EPMOS = EPACT ENCLOSE ALL_GATE
ENMOS = ENACT ENCLOSE ALL_GATE
EGTE = ALL_GATE AND SDI
EGTE_W = EGTE INSIDE EDGE OD
EPSD = EPMOS NOT EGTE
ENSD = ENMOS NOT EGTE
ENSD_NCO = (ENSD NOT INTERACT ECO) NOT INTERACT PTAP
EPSD_NCO = (EPSD NOT INTERACT ECO) NOT INTERACT NTAP
ENSD_WCO = ENSD NOT ENSD_NCO
EPSD_WCO = EPSD NOT EPSD_NCO
ENSD_SRC = ENSD_WCO OUTSIDE RPO

ESD1_GATE = EGTE AND ESD1DMY
ESD1_NCS_GATE = ESD1_GATE NOT INTERACT ENSD_NCO
ESD1_TOL = (ENMOS AND ESD1DMY) INTERACT ENSD_NCO
ESD1_NCS = (ENMOS AND ESD1DMY) NOT INTERACT ENSD_NCO
ENSD_NCO_ESD1DMY = ENSD_NCO INTERACT ESD1DMY
ESD1_TOL_GATE = EGTE INTERACT ENSD_NCO_ESD1DMY
ESD1_TOL_GATE1 = ESD1_TOL_GATE NOT INTERACT ENSD_SRC
ESD1_TOL_GATE2 = ESD1_TOL_GATE INTERACT ENSD_SRC
ESD1_NCS_GATE_W = ESD1_NCS_GATE INSIDE EDGE OD
ESD1_TOL_GATE1_W = ESD1_TOL_GATE1 INSIDE EDGE OD
ESD1_TOL_GATE2_W = ESD1_TOL_GATE2 INSIDE EDGE OD

ESD2_GATE = EGTE AND ESD2DMY
ESD2_REG_GATE = ESD2_GATE NOT INTERACT ENSD_NCO
ESD2_TOL_GATE = ESD2_GATE INTERACT ENSD_NCO
ESD2_TOL_GATE1 = ESD2_TOL_GATE NOT INTERACT ENSD_SRC
ESD2_TOL_GATE2 = ESD2_TOL_GATE INTERACT ENSD_SRC
ESD2_TOL = (ENMOS AND ESD2DMY) INTERACT ENSD_NCO
ESD2_REG = (ENMOS AND ESD2DMY) NOT INTERACT ENSD_NCO
ESD2_REG_GATE_W = ESD2_REG_GATE INSIDE EDGE OD
ESD2_TOL_GATE1_W = ESD2_TOL_GATE1 INSIDE EDGE OD
ESD2_TOL_GATE2_W = ESD2_TOL_GATE2 INSIDE EDGE OD

RPO1 = ((RPO AND SDI) OUTSIDE ESD1DMY) OUTSIDE ESD2DMY
EGTE1 = ((EGTE OUTSIDE ESD1DMY) OUTSIDE ESD2DMY) NOT INTERACT ENSD_NCO
EGTE1_W = EGTE1 INSIDE EDGE OD

ERPO = RPO AND SDI
ERPOH = HOLES ERPO
ERPOA = ERPOH OR ERPO
ECOS = ECO OUTSIDE ERPOA
HEGT = EGTE AND OD2
LEGT = EGTE NOT OD2
HEGN = HEGT AND NP
HEGP = HEGT AND PP

#IFDEF GUIDELINE_ESD
ESD.6g { @ Unit finger width of NMOS and PMOS for I/O buffer and power clamp device 15um <= width <= 60um.
  PATH LENGTH EGTE_W >0  < 15
  PATH LENGTH EGTE_W >60 < 999
}
// begin of ESD.8, butted or inserted pickup is not allowed
ESD.8g { @ It is strictly prohitibied to butting or inserted substrat/well pickups for ESD N/PMOS.
  
  EAct = EPACT OR ENACT
  DTap = NTAP OR PTAP
  EActUp3 = SIZE EAct BY 3 OUTSIDE OF DTap STEP 0.22*0.7
  D1 = DTap INTERACT EActUp3
  
  D1R1 = SHRINK D1 RIGHT BY 0.001
  D1R2 = D1 NOT D1R1 
  D1R3 = D1 COIN EDGE D1R2
  D1R4 = LENGTH D1R3 > 0.001
  D1R5 = EXT [D1R4] EAct < 3 ABUT < 90 OPPOSITE  
  D1L  = D1 WITH EDGE D1R5 
  D1L1 = SHRINK D1L LEFT BY 0.001
  D1L2 = D1L NOT D1L1 
  D1L3 = D1L COIN EDGE D1L2
  D1L4 = LENGTH D1L3 > 0.001
  D1L5 = EXT [D1L4] EAct < 3 ABUT < 90 OPPOSITE  
  D1X  = D1L WITH EDGE D1L5 
  D1T1 = SHRINK D1 TOP BY 0.001
  D1T2 = D1 NOT D1T1 
  D1T3 = D1 COIN EDGE D1T2
  D1T4 = LENGTH D1T3 > 0.001
  D1T5 = EXT [D1T4] EAct < 3 ABUT < 90 OPPOSITE  
  D1B  = D1 WITH EDGE D1T5 
  D1B1 = SHRINK D1B BOTTOM BY 0.001
  D1B2 = D1B NOT D1B1 
  D1B3 = D1B COIN EDGE D1B2
  D1B4 = LENGTH D1B3 > 0.001
  D1B5 = EXT [D1B4] EAct < 3 ABUT < 90 OPPOSITE  
  D1Y  = D1B WITH EDGE D1B5
  DTap2Check=D1X OR D1Y
  
  DTapHole = HOLES DTap2Check INNER
  DTapSuspect = DTap2Check NOT TOUCH DTapHole
  ENCLOSE RECTANGLE DTapSuspect 0.22 20
}

#IFDEF 1.5V
ESD.18g_1.5V { @ Minimum 1.5V IO ESD NMOS/PMOS gate length >=0.2um
  INT LEGT < 0.2 ABUT < 90 SINGULAR REGION
}
#ENDIF
#IFDEF 1.8V
ESD.18g_1.8V { @ Minimum 1.8V IO ESD NMOS/PMOS gate length >=0.25um
  INT LEGT < 0.25 ABUT < 90 SINGULAR REGION
}
#ENDIF
#IFDEF 2.5V
ESD.18g_2.5V_N { @ Minimum 2.5V IO ESD NMOS gate length < 0.3um
  INT HEGN < 0.3 ABUT < 90 SINGULAR REGION
}
ESD.18g_2.5V_P { @ Minimum 2.5V IO ESD PMOS gate length < 0.25um
  INT HEGP < 0.25 ABUT < 90 SINGULAR REGION
}
#ENDIF
#IFDEF 3.3V
ESD.18g_3.3V_N { @ Minimum 3.3V IO ESD NMOS gate length < 0.4um
  INT HEGN < 0.4 ABUT < 90 SINGULAR REGION
}
ESD.18g_3.3V_P { @ Minimum 3.3V IO ESD PMOS gate length < 0.3um
  INT HEGP < 0.3 ABUT < 90 SINGULAR REGION
}
#ENDIF

#IFDEF 5V
HEGN1 = HEGN INTERACT ESD
HEGN2 = HEGN NOT HEGN1
ESD.18g_5V_NESD { @ Minimum 5.0V IO ESD NMOS(without ESD implant)/PMOS gate length >= 0.6um
  INT HEGN2 < 0.6 ABUT<90 SINGULAR REGION
}
ESD.18g_5V_P { @ Minimum 5.0V IO ESD NMOS(without ESD implant)/PMOS gate length >= 0.6um
  INT HEGP < 0.6 ABUT<90 SINGULAR REGION
}
ESD.18g_5V_WESD { @ Minimum 5.0V IO ESD NMOS (with ESD implant) gate length >=0.9um
  INT HEGN1 < 0.9 ABUT<90 SINGULAR REGION
}
#ENDIF

ESD.19g { @ NMOS and PMOS of I/O buffer should have a nonsalicide area on drain side, that is, RPO mask should
          @ block drain side of device (except contact region should keep silicided).
   ( EGTE INSIDE EPMOS ) NOT INTERACT ( EPSD INTERACT RPO )
   ( EGTE INSIDE ( ENMOS INTERACT RPO)) NOT INTERACT ( ENSD INTERACT RPO )
}
ESD.20g { @ For high voltage tolerant I/O designed by 3.3V/2.5V/1.8V/1.5V NMOS (see N1 and N2 in Fig.5b)
          @ RPO should cover all inactive poly gates and extend to active region (Poly spacing>=0.25um). 
          @ Minimum and maximum overlap from RPO to the active poly gate 0.05um or 0.06um
  X = ESD2_TOL_GATE NOT RPO
  ESD2_TOL NOT INTERACT X
  ESD2_TOL_GATE2 OUTSIDE RPO
  ESD2_TOL_GATE1 NOT RPO
  INT ESD2_TOL_GATE2 RPO < 0.05 ABUT < 90 OPPOSITE REGION
  ESD2_TOL_GATE_RPO = ESD2_TOL_GATE CUT RPO
  ESD2_TOL_GATE_RPO_CH = ESD2_TOL_GATE_RPO AND RPO
  A = SIZE ESD2_TOL_GATE_RPO_CH BY 0.025 UNDEROVER
  INT A < 0.06 ABUT < 90 OPPOSITE REGION
  SIZE A BY 0.03 UNDEROVER
}
ESD.20g_A { @ For high voltage tolerant I/O designed by 3.3V/2.5V/1.8V/1.5V NMOS (see N1 and N2 in Fig.5b)
          @ RPO should cover all inactive poly gates and extend to active region (Poly spacing>=0.25um). 
          @ Minimum and maximum overlap from RPO to the active poly gate by 0.05um
  X = ENSD_NCO INTERACT ESD2DMY
  INT X < 0.25 ABUT < 90 REGION	  
  SIZE X BY 0.25/2 UNDEROVER
}

ESD.21g { @ For regular I/O designed by 5V, 3.3V, 2.5V, 1.8V and 1.5V NMOS (see N3 in Fig.6a) 
    	  @ Minimum and maximum overlap from RPO on the drain side to the active poly gate 0.05um or 0.06um
  X = ESD2_REG_GATE NOT RPO
  ESD2_REG NOT INTERACT X
  ESD2_REG_GATE OUTSIDE RPO
  INT ESD2_REG_GATE RPO < 0.05 ABUT < 90 OPPOSITE REGION 
  ESD2_REG_GATE_RPO = ESD2_REG_GATE CUT RPO
  ESD2_REG_GATE_RPO_CH = ESD2_REG_GATE_RPO AND RPO
  A = SIZE ESD2_REG_GATE_RPO_CH BY 0.025 UNDEROVER
  INT A < 0.06 ABUT < 90 OPPOSITE REGION
  SIZE A BY 0.03 UNDEROVER
}
// ESD.22g is checked by ESD.21g
// ESD.23g is checked by ESD.21g
ESD.24g { @ The minimum width of RPO on drain side (X) for 5V,3.3V, 2.5V, 1.8V and 1.5V NMOS and PMOS.
    	  @ 1.8V and 1.5V NMOS when used as power clamp device>=1.95um 
  X = ((ENSD_WCO OR EPSD_WCO ) AND ESD2DMY) AND RPO
  Y = EGTE COIN OUTSIDE EDGE X
  Z = RPO COIN INSIDE EDGE X 
  ENC Y Z < 1.95 ABUT < 90 REGION 
}
ESD.25g { @ The minimum clearance from poly edge to CO edge on source side for NMOS and PMOS (Except ESD.26g)>=0.5um
  X = ECOS AND ((ENMOS OR EPMOS ) INTERACT RPO)     
  EXT X EGTE_W < 0.5 ABUT < 90 OPPOSITE REGION
  Y = ECO AND ESD1_NCS
  EXT Y EGTE_W < 0.5 ABUT < 90 OPPOSITE REGION
}
ESD.26g { @ The minimum clearance of poly edge to CO edge on D/S side for 1.8V and 1.5V power clamp device>=0.25um 
  X = ECO AND ( ENMOS NOT INTERACT RPO)
  EXT X EGTE_W < 0.25 ABUT < 90 OPPOSITE REGION    
}
ESD.27g { @ For RPO DRC purpose,we need a dummy layers in ESD protection device.layers should cover all ESD protection devices.
          @ ESD2DMY is for the cascade NMOS in high voltage tolerant I/O designed by 3.3V/2.5V NMOS (see Fig.5b), regular IO designed by
	  @ 5V/3.3V/2.5V/1.8V/1.5V NMOS and PMOS (see Fig.6b), power clmap designed by 5V/3.3V/2.5V NMOS.    
   X = EGTE CUT RPO
   ( EGTE INSIDE ( ENMOS ENCLOSE X )) NOT ESD2DMY
   ( EGTE INSIDE ( EPMOS ENCLOSE X )) NOT ESD2DMY
}
#IFNDEF 5V
ESD.28g { @ ESD implant is required for High Voltage Tolerant I/O designed by 3.3V NMOS device for 5V signal 
    	  @ input or 2.5V NMOS device for 3.3V signal input at I/O pad. ESD mask (No. 111) can be generated by 
	  @ logical operation. It is not allowed to use ESD mask (No. 111) for 5V NMOS device.
	  @ ESD3DMY is for the cascade NMOS in high voltage tolerant I/O designed by 3.3V/2.5V NMOS (see Fig.5b). 
   (( ENMOS ENCLOSE LEGT ) INTERACT ESD2DMY) INTERACT ESD3DMY
   ( ESD2_TOL_GATE AND OD2 ) NOT ESD3DMY
   ESD3DMY AND GATE_PP 
}
#ENDIF
// ESD.29g is checked by ESD.19g
ESD.30g { @ For regular 1.8V I/O in NMOS region : Minumum clearance from RPO to poly spacing >=0.45um.
  EXT RPO1 EGTE1_W < 0.45 ABUT < 90 OPPOSITE REGION
  EGTE1 AND RPO1
}
//ESD.31g is checked by ESD.30g
ESD.32g { @The minimum width of RPO on drain side (X) for 1.8V NMOS and 5V/3.3V/1.8V/1.5V PMOS.>=1.5um
  Y = RPO1 INSIDE EDGE OD
  INT Y < 1.5 ABUT < 90 REGION
}
//ESD.33g is checked by ESD.25g
ESD.34g { @ 5V, 3.3V and 2.5V NMOS devices when used as power clamp devices, the RPO can fully cover the 
    	  @ uncontacted poly gate, source/drain (except contact region should keep silicided). 
  ( ENMOS INTERACT ESD1DMY ) NOT ERPOA        
}
NCS_SD_1 = ((OD INTERACT EGTE) NOT POLY) AND ESD1DMY
NCS_SD = STAMP NCS_SD_1 BY NSDi
NCS_S  = NET AREA RATIO NCS_SD PTAPi >0
NCS_D  = NCS_SD NOT NCS_S
ESD.35g{ @ Minimum width of RPO on drain side (X) for 5V, 3.3V and 2.5V NMOS devices when used as power clamp 
    	 @ devices. Ncs Drain is defined as (((OD INTERACT GATE) NOT PO) AND ESD1DMY) 
	 @ which not connect to PW Pickup.>=1.95um
  X = NCS_D AND RPO 
  Y = EGTE COIN OUTSIDE EDGE NCS_D
  Z = RPO COIN INSIDE EDGE X 
  ENC Y Z < 1.95 ABUT < 90 REGION 
  
}
//ESD.36g is checked by ESD.25g

ESD.37g { @  For RPO DRC purpose, we need a dummy layers for 5V, 3.3Vand 2.5V NMOS devices when used as power 
    	  @  clamp devices. The layers should cover all ESD protection devices.   
   X = EGTE NOT INSIDE RPO
   Y = ENMOS NOT ENCLOSE X
   Y NOT INTERACT ESD1DMY
   ESD1DMY AND GATE_PP
   ( EGTE INSIDE (ENMOS ENCLOSE ESD1_GATE)) NOT ESD1DMY // ESD1DMY should cover all EGTE in new design rule.
}
ESD.WARN.1 { @ CO can't inserted between gate and RPO for 1.8V NMOS and all PMOS I/O pattern.
  RED  = (EPSD OR ENSD) INTERACT RPO1
  XRPO = RED NOT RPO1
  XRPG = XRPO TOUCH EGTE1
  XRPG INTERACT ECO
}
#IFDEF 5V
ESD.WARN.2 { @ ESD3DMY is not allowed in 5V process.
  COPY ESD3DMY
}
#ENDIF
#IFNDEF 5V
ESD.WARN.3 { @ ESD3DMY is not allowed in processes except 5V.
  COPY ESD
}
#ENDIF

#ENDIF


#IFDEF 5V

// ESD checks
//===========

ESD.W.1{ @ Minimum esd width < 0.6
  INT ESD < 0.6 SINGULAR ABUT < 90 REGION
}
ESD.S.1{ @ Minimum esd space < 0.6
  EXT ESD < 0.6 ABUT < 90 REGION
}
ESD.S.2{ @ Minimum space between ESD and NP or PP < 0.3
  EXT ESD PP < 0.3 ABUT >0<90 SINGULAR REGION
  EXT ESD NP < 0.3 ABUT <90 SINGULAR REGION
  X = EXT ESD [PP] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT NPOD
}
ESD.C.1{ @ Minimum clearance from an ESD to an NP OD < 0.6
  EXT ESD NPOD < 0.6 SINGULAR ABUT < 90 REGION
}
ESD.C.2{ @ Minimum clearance from an ESD to a N-ch PO gate < 0.45
  ENC GATE_W ESD < 0.45 ABUT REGION
  ALL_GATE CUT ESD    
}
ESD.O.1{ @ Minimum overlap from an ESD edge to an OD region < 0.45
  INT ESD OD < 0.45 SINGULAR ABUT>0 <90 REGION 
}
ESD.C.4 { @ Min. space from ESD to ESD OD < 0.6
  X = NPOD INTERACT ESD
  EXT ESD X < 0.6 ABUT <90 SINGULAR REGION
}
ESD.E.1{ @ Minimum extension of an ESD region beyond an ESD OD < 0.25
  ENC OD ESD < 0.25 SINGULAR ABUT < 90 REGION
  ESD INSIDE OD
}
// ESD.C.5 is not necessary to check
ESD.R.1 { @ ESD and PP not allowed on same POLY region
  A = ESD AND POLY
  A AND PP
}
ESD.R.2 { @ ESD is for 5.0V NMOS only
  ESD AND (ALL_GATE AND PP)
  ESD AND ((ALL_GATE AND NP) NOT OD2)
}
#ENDIF


// Latch-Up CHECKS
//================
RH = (PORES OR ODRES) INTERACT RPO    
RPDMY = (DMN2V OR DMP2V) OR FFOD      
RPDMYi    = RPDMY NOT INTERACT RPOi	  
RPO_RPDMY = RPOi OR RPDMYi
NSDc  = NSDi NOT RPO_RPDMY      // NMOS source/drain for connection
PSDc  = PSDi NOT RPO_RPDMY	// PMOS source/drain for connection
RWi = PWELi INSIDE DNWi
NWRiT = (NWELi INTERACT RWDMY) NOT RWDMY // NWR terminal
SRM = COPY EXCL
UBMn = (UBMi NOT INTERACT PPIi) NOT INTERACT MDi  // UBM lie on Top Metal
UBMd = UBMi NOT UBMn                             // UBM lie on PPI or MD
CONNECT NWEL DNW
// Wire-Bond
CONNECT M6xd CBi
// Flip-chip
// 1_Ground up
CONNECT M6xd UBMn BY CBDi       
// 2_RDL (before passivation)
//CONNECT M6xd MDxd BY VIADi
CONNECT MDxd UBMd
// 3_PPI (After passivation)
CONNECT M6xd PPIi BY CBDi
CONNECT PPIi UBMd
EMPTYi = CHIP  NOT BULK
NTAPiu = NTAPi NOT EMPTYi
PTAPiu = PTAPi NOT EMPTYi
NSDiu  = NSDc  NOT EMPTYi
PSDiu  = PSDc  NOT EMPTYi
CBiu   = CBi   NOT EMPTYi 
UBMniu = UBMn NOT EMPTYi
UBMdiu = UBMd NOT EMPTYi
PWR_M1iu_BY_TEXT = M1xd WITH TEXT VDD_TEXT 40 PRIMARY ONLY
GND_M1iu_BY_TEXT = M1xd WITH TEXT VSS_TEXT 40 PRIMARY ONLY
PAD_M1iu_BY_TEXT = M1xd WITH TEXT PAD_TEXT 40 PRIMARY ONLY
GND_M1iu_TEXT = EXPAND TEXT VDD_TEXT 40 BY 1 PRIMARY ONLY
PWR_M1iu_TEXT = EXPAND TEXT VSS_TEXT 40 BY 1 PRIMARY ONLY
PWR_M2iu_BY_TEXT = M1xd WITH TEXT VDD_TEXT 41 PRIMARY ONLY
GND_M2iu_BY_TEXT = M1xd WITH TEXT VSS_TEXT 41 PRIMARY ONLY
PAD_M2iu_BY_TEXT = M1xd WITH TEXT PAD_TEXT 41 PRIMARY ONLY
GND_M2iu_TEXT = EXPAND TEXT VDD_TEXT 41 BY 1 PRIMARY ONLY
PWR_M2iu_TEXT = EXPAND TEXT VSS_TEXT 41 BY 1 PRIMARY ONLY
PWR_M3iu_BY_TEXT = M1xd WITH TEXT VDD_TEXT 42 PRIMARY ONLY
GND_M3iu_BY_TEXT = M1xd WITH TEXT VSS_TEXT 42 PRIMARY ONLY
PAD_M3iu_BY_TEXT = M1xd WITH TEXT PAD_TEXT 42 PRIMARY ONLY
GND_M3iu_TEXT = EXPAND TEXT VDD_TEXT 42 BY 1 PRIMARY ONLY
PWR_M3iu_TEXT = EXPAND TEXT VSS_TEXT 42 BY 1 PRIMARY ONLY
PWR_M4iu_BY_TEXT = M1xd WITH TEXT VDD_TEXT 43 PRIMARY ONLY
GND_M4iu_BY_TEXT = M1xd WITH TEXT VSS_TEXT 43 PRIMARY ONLY
PAD_M4iu_BY_TEXT = M1xd WITH TEXT PAD_TEXT 43 PRIMARY ONLY
GND_M4iu_TEXT = EXPAND TEXT VDD_TEXT 43 BY 1 PRIMARY ONLY
PWR_M4iu_TEXT = EXPAND TEXT VSS_TEXT 43 BY 1 PRIMARY ONLY
PWR_M5iu_BY_TEXT = M1xd WITH TEXT VDD_TEXT 44 PRIMARY ONLY
GND_M5iu_BY_TEXT = M1xd WITH TEXT VSS_TEXT 44 PRIMARY ONLY
PAD_M5iu_BY_TEXT = M1xd WITH TEXT PAD_TEXT 44 PRIMARY ONLY
GND_M5iu_TEXT = EXPAND TEXT VDD_TEXT 44 BY 1 PRIMARY ONLY
PWR_M5iu_TEXT = EXPAND TEXT VSS_TEXT 44 BY 1 PRIMARY ONLY
PWR_M6iu_BY_TEXT = M1xd WITH TEXT VDD_TEXT 45 PRIMARY ONLY
GND_M6iu_BY_TEXT = M1xd WITH TEXT VSS_TEXT 45 PRIMARY ONLY
PAD_M6iu_BY_TEXT = M1xd WITH TEXT PAD_TEXT 45 PRIMARY ONLY
GND_M6iu_TEXT = EXPAND TEXT VDD_TEXT 45 BY 1 PRIMARY ONLY
PWR_M6iu_TEXT = EXPAND TEXT VSS_TEXT 45 BY 1 PRIMARY ONLY


VARIABLE  LUP_2   20.0
VARIABLE  LUP_2_S 8.0
VARIABLE  LUP_3_1 3.0
VARIABLE  LUP_3_2 6.0
VARIABLE  LUP_3_3 12.0
VARIABLE  LUP_3_4 23.0
VARIABLE  LUP_4   0.42
VARIABLE  LUP_5_1 3.0
VARIABLE  LUP_5_2 6.0
VARIABLE  LUP_5_3 12.0
VARIABLE  LUP_5_4 23.0
VARIABLE  LUP_5_4_1 40.0 //limitation
VARIABLE  LUP_6   30.0
VARIABLE  LUP_6_SRAM 40.0
VARIABLE  NW_S_1  0.6

ODRES_a = ODRES AND (RH OR RPDMY)
NTAPux = NTAPi NOT INTERACT RNWEL

// Power PAD
VDD_CB = NET AREA RATIO CBiu NTAPux > 0
VSS_CB = NET AREA RATIO CBiu PTAPiu > 0
VDD_UBMn = NET AREA RATIO UBMniu NTAPux > 0  // VDD_UMBn connect to N+ OD pickup
VSS_UBMn = NET AREA RATIO UBMniu PTAPiu > 0  // VSS_UMBn connect to P+ OD pickup
VDD_UBMd = NET AREA RATIO UBMdiu NTAPux > 0  // VDD_UMBd connect to N+ OD pickup
VSS_UBMd = NET AREA RATIO UBMdiu PTAPiu > 0  // VSS_UMBd connect to P+ OD pickup
// Signal PAD
IO_CB  = (CBiu NOT VDD_CB) NOT VSS_CB 
IO_UBMn = (UBMniu NOT VDD_UBMn) NOT VSS_UBMn
IO_UBMd = (UBMdiu NOT VDD_UBMd) NOT VSS_UBMd
PSD_PAD = NET AREA RATIO PSDiu CBiu UBMniu UBMdiu > 0 [!!AREA(CBiu) + !!AREA(UBMniu)+ !!AREA(UBMdiu)]       // P+ S/D, and connect to all CB/UBM pad
NSD_PAD = NET AREA RATIO NSDiu CBiu UBMniu UBMdiu > 0 [!!AREA(CBiu) + !!AREA(UBMniu)+ !!AREA(UBMdiu)]
PSD_IOPAD = NET AREA RATIO PSDiu IO_CB IO_UBMn IO_UBMd > 0 [!!AREA(IO_CB) + !!AREA(IO_UBMn)+ !!AREA(IO_UBMd)] // P+ S/D, and connect to I/O pad only
NSD_IOPAD = NET AREA RATIO NSDiu IO_CB IO_UBMn IO_UBMd > 0 [!!AREA(IO_CB) + !!AREA(IO_UBMn)+ !!AREA(IO_UBMd)]

VDD_VSS_DUMMY = VDDDMY OR VSSDMY
CB_DUMMY = CBiu INTERACT VDD_VSS_DUMMY
UBMn_DUMMY = UBMniu INTERACT VDD_VSS_DUMMY
UBMd_DUMMY = UBMdiu INTERACT VDD_VSS_DUMMY
PSD_VDD_VSS_PAD_DUMMY = NET AREA RATIO PSDiu OVER CB_DUMMY UBMn_DUMMY UBMd_DUMMY >0
NSD_VDD_VSS_PAD_DUMMY = NET AREA RATIO NSDiu OVER CB_DUMMY UBMn_DUMMY UBMd_DUMMY >0

PSD_PAD_TEXT = NET AREA RATIO PSDiu OVER PAD_M6iu_BY_TEXT PAD_M5iu_BY_TEXT PAD_M4iu_BY_TEXT PAD_M3iu_BY_TEXT PAD_M2iu_BY_TEXT PAD_M1iu_BY_TEXT > 0
NSD_PAD_TEXT = NET AREA RATIO NSDiu OVER PAD_M6iu_BY_TEXT PAD_M5iu_BY_TEXT PAD_M4iu_BY_TEXT PAD_M3iu_BY_TEXT PAD_M2iu_BY_TEXT PAD_M1iu_BY_TEXT > 0
PSD_VDD_VSS_PAD_TEXT = NET AREA RATIO PSDiu OVER PWR_M6iu_BY_TEXT PWR_M5iu_BY_TEXT PWR_M4iu_BY_TEXT PWR_M3iu_BY_TEXT PWR_M2iu_BY_TEXT PWR_M1iu_BY_TEXT GND_M6iu_BY_TEXT GND_M5iu_BY_TEXT GND_M4iu_BY_TEXT GND_M3iu_BY_TEXT GND_M2iu_BY_TEXT GND_M1iu_BY_TEXT > 0 
NSD_VDD_VSS_PAD_TEXT = NET AREA RATIO NSDiu OVER PWR_M6iu_BY_TEXT PWR_M5iu_BY_TEXT PWR_M4iu_BY_TEXT PWR_M3iu_BY_TEXT PWR_M2iu_BY_TEXT PWR_M1iu_BY_TEXT GND_M6iu_BY_TEXT GND_M5iu_BY_TEXT GND_M4iu_BY_TEXT GND_M3iu_BY_TEXT GND_M2iu_BY_TEXT GND_M1iu_BY_TEXT > 0 
PWR_TEXT = (((( PWR_M1iu_TEXT OR PWR_M2iu_TEXT ) OR PWR_M3iu_TEXT ) OR PWR_M4iu_TEXT ) OR PWR_M5iu_TEXT ) OR PWR_M6iu_TEXT
GND_TEXT = (((( GND_M1iu_TEXT OR GND_M2iu_TEXT ) OR GND_M3iu_TEXT ) OR GND_M4iu_TEXT ) OR GND_M5iu_TEXT ) OR GND_M6iu_TEXT


#IFDEF  CHECK_LATCHUP_BY_TEXT
PSD_IOPAD_ALL = (PSD_IOPAD OR PSD_PAD_TEXT) NOT (PSD_VDD_VSS_PAD_TEXT OR PSD_VDD_VSS_PAD_DUMMY)
NSD_IOPAD_ALL = (NSD_IOPAD OR NSD_PAD_TEXT) NOT (NSD_VDD_VSS_PAD_TEXT OR NSD_VDD_VSS_PAD_DUMMY)
SD_IOPAD = PSD_IOPAD_ALL OR NSD_IOPAD_ALL
MOS = DACT INTERACT ALL_GATE
PMOS_filter = COPY EMPTYi
NMOS_filter = COPY EMPTYi
#ENDIF

#IFNDEF  CHECK_LATCHUP_BY_TEXT
PSD_IOPAD_ALL = PSD_IOPAD  NOT PSD_VDD_VSS_PAD_DUMMY
NSD_IOPAD_ALL = NSD_IOPAD  NOT NSD_VDD_VSS_PAD_DUMMY
SD_IOPAD = PSD_IOPAD_ALL OR NSD_IOPAD_ALL
MOS = DACT INTERACT ALL_GATE
PMOS_filter = MOS INTERACT PSD_PAD == 1 BY NET
NMOS_filter = MOS INTERACT NSD_PAD == 1 BY NET
#ENDIF

DUMMY_MOS = (MOS NOT INTERACT CO) NOT INTERACT (POLY INTERACT CO)
POST_DRIVER_DUMMY_LAYERS = COPY SDI
DACT_real = (DACT NOT INTERACT ODRES_a) NOT INTERACT RNWEL   // All MOS region not resistor region
PACT_real = PACT AND DACT_real
NACT_real = NACT AND DACT_real

// ESD device [covered by dummy layers]
POST_DRIVER_ACT1 = DACT_real AND POST_DRIVER_DUMMY_LAYERS    // MOS with active region in SDI
// ESD device [connected to Signal PAD but not connected to one PAD only]
POST_DRIVER_ACT2 = ((DACT_real NOT PMOS_filter) NOT NMOS_filter) INTERACT SD_IOPAD

#IFDEF CHECK_LATCHUP_BY_PAD_CONNECTION
POST_DRIVER_ACT = POST_DRIVER_ACT1 OR POST_DRIVER_ACT2 
#ELSE
POST_DRIVER_ACT = COPY POST_DRIVER_ACT1
#ENDIF

// For LUP.1/LUP.2/LUP.4 - GuardRing
//====================================
NW_inside_guard_ring_pre1 = NWELi NOT NTAPi
NW_inside_guard_ring_pre2 = NW_inside_guard_ring_pre1 NOT COIN OUTSIDE EDGE NTAPi
NW_inside_guard_ring = NW_inside_guard_ring_pre1 NOT WITH EDGE NW_inside_guard_ring_pre2
PW_inside_guard_ring_pre1 = PWELi NOT PTAPi
PW_inside_guard_ring_pre2 = PW_inside_guard_ring_pre1 NOT COIN OUTSIDE EDGE PTAPi
PW_inside_guard_ring = PW_inside_guard_ring_pre1 NOT WITH EDGE PW_inside_guard_ring_pre2
NTAP_guard_ring_hole = ((HOLES NTAPi INNER) INSIDE NWELi) OR NW_inside_guard_ring
PTAP_guard_ring_hole = ((HOLES PTAPi INNER) INSIDE PWELi) OR PW_inside_guard_ring

// For LUP.1 - I/O PAD N/P ACTIVE
//=================================
POST_DRIVER_PACT = (POST_DRIVER_ACT INTERACT PSDiu) NOT INSIDE LUPWDMY
POST_DRIVER_NACT = (POST_DRIVER_ACT INTERACT NSDiu) NOT INSIDE LUPWDMY

// For LUP.3
//==================
POST_DRIVER_PMOS = POST_DRIVER_PACT INTERACT ALL_GATE 
POST_DRIVER_PMOS_NW = STAMP POST_DRIVER_PMOS BY NWEL
POST_DRIVER_PMOS_NW_HV  = POST_DRIVER_PMOS_NW INTERACT HVGT
POST_DRIVER_PMOS_NW_33V = POST_DRIVER_PMOS_NW_HV INTERACT OD2i
POST_DRIVER_PMOS_NW_25V = POST_DRIVER_PMOS_NW_HV INTERACT OD2i
POST_DRIVER_PMOS_NW_50V = POST_DRIVER_PMOS_NW_HV INTERACT OD2i
POST_DRIVER_PMOS_NW_LV  = POST_DRIVER_PMOS_NW NOT POST_DRIVER_PMOS_NW_HV
POST_DRIVER_PMOS_NWi = STAMP POST_DRIVER_PMOS BY NWELi
POST_DRIVER_PMOS_NWi_HV  = POST_DRIVER_PMOS_NWi INTERACT HVGT
POST_DRIVER_PMOS_NWi_33V = POST_DRIVER_PMOS_NWi_HV INTERACT OD2i
POST_DRIVER_PMOS_NWi_25V = POST_DRIVER_PMOS_NWi_HV INTERACT OD2i
POST_DRIVER_PMOS_NWi_50V = POST_DRIVER_PMOS_NWi_HV INTERACT OD2i
POST_DRIVER_PMOS_NWi_LV  = POST_DRIVER_PMOS_NWi NOT POST_DRIVER_PMOS_NWi_HV
POST_DRIVER_NMOS = POST_DRIVER_NACT INTERACT ALL_GATE
POST_DRIVER_NMOS_RW = STAMP (POST_DRIVER_NMOS INSIDE DNW) BY DNW
POST_DRIVER_NMOS_PW = POST_DRIVER_NMOS NOT POST_DRIVER_NMOS_RW
POST_DRIVER_NMOS_RW_HV  = POST_DRIVER_NMOS_RW INTERACT HVGT
POST_DRIVER_NMOS_RW_33V = POST_DRIVER_NMOS_RW_HV INTERACT OD2i
POST_DRIVER_NMOS_RW_25V = POST_DRIVER_NMOS_RW_HV INTERACT OD2i
POST_DRIVER_NMOS_RW_50V = POST_DRIVER_NMOS_RW_HV INTERACT OD2i
POST_DRIVER_NMOS_RW_LV  = POST_DRIVER_NMOS_RW NOT POST_DRIVER_NMOS_RW_HV
POST_DRIVER_NMOS_PW_HV  = POST_DRIVER_NMOS_PW INTERACT HVGT
POST_DRIVER_NMOS_PW_33V = POST_DRIVER_NMOS_PW_HV INTERACT OD2i
POST_DRIVER_NMOS_PW_25V = POST_DRIVER_NMOS_PW_HV INTERACT OD2i
POST_DRIVER_NMOS_PW_50V = POST_DRIVER_NMOS_PW_HV INTERACT OD2i
POST_DRIVER_NMOS_PW_LV  = POST_DRIVER_NMOS_PW NOT POST_DRIVER_NMOS_PW_HV
DNWc = STAMP DNW BY NWELi
POST_DRIVER_NMOS_RWi = STAMP (POST_DRIVER_NMOS INSIDE DNWc) BY DNWc
POST_DRIVER_NMOS_RWi_HV  = POST_DRIVER_NMOS_RWi INTERACT HVGT
POST_DRIVER_NMOS_RWi_33V = POST_DRIVER_NMOS_RWi_HV INTERACT OD2i
POST_DRIVER_NMOS_RWi_25V = POST_DRIVER_NMOS_RWi_HV INTERACT OD2i
POST_DRIVER_NMOS_RWi_50V = POST_DRIVER_NMOS_RWi_HV INTERACT OD2i
POST_DRIVER_NMOS_RWi_LV  = POST_DRIVER_NMOS_RWi NOT POST_DRIVER_NMOS_RWi_HV


POST_DRIVER_MOS = POST_DRIVER_NMOS OR POST_DRIVER_PMOS
BESIDE_POST_DRIVER = SIZE POST_DRIVER_MOS BY LUP_2
BESIDE_POST_DRIVER_NMOS = (((NACT_real INTERACT ALL_GATE) NOT OUTSIDE BESIDE_POST_DRIVER) NOT POST_DRIVER_NACT) NOT DUMMY_MOS
BESIDE_POST_DRIVER_PMOS = (((PACT_real INTERACT ALL_GATE) NOT OUTSIDE BESIDE_POST_DRIVER) NOT POST_DRIVER_PACT) NOT DUMMY_MOS

// for LUP.5.4
BESIDE_POST_DRIVER_1 = SIZE POST_DRIVER_MOS BY LUP_5_4_1
BESIDE_POST_DRIVER_NMOS_1 = (((NACT_real INTERACT ALL_GATE) NOT OUTSIDE BESIDE_POST_DRIVER_1) NOT POST_DRIVER_NACT) NOT DUMMY_MOS
BESIDE_POST_DRIVER_PMOS_1 = (((PACT_real INTERACT ALL_GATE) NOT OUTSIDE BESIDE_POST_DRIVER_1) NOT POST_DRIVER_PACT) NOT DUMMY_MOS


BESIDE_POST_DRIVER_PMOS_NW = STAMP BESIDE_POST_DRIVER_PMOS BY NWEL
BESIDE_POST_DRIVER_PMOS_NW_HV  = BESIDE_POST_DRIVER_PMOS_NW INTERACT HVGT
BESIDE_POST_DRIVER_PMOS_NW_33V = BESIDE_POST_DRIVER_PMOS_NW_HV INTERACT OD2i
BESIDE_POST_DRIVER_PMOS_NW_25V = BESIDE_POST_DRIVER_PMOS_NW_HV INTERACT OD2i
BESIDE_POST_DRIVER_PMOS_NW_50V = BESIDE_POST_DRIVER_PMOS_NW_HV INTERACT OD2i
BESIDE_POST_DRIVER_PMOS_NW_LV  = BESIDE_POST_DRIVER_PMOS_NW NOT BESIDE_POST_DRIVER_PMOS_NW_HV
BESIDE_POST_DRIVER_PMOS_NWi = STAMP BESIDE_POST_DRIVER_PMOS BY NWELi
BESIDE_POST_DRIVER_PMOS_NWi_HV  = BESIDE_POST_DRIVER_PMOS_NWi INTERACT HVGT
BESIDE_POST_DRIVER_PMOS_NWi_33V = BESIDE_POST_DRIVER_PMOS_NWi_HV INTERACT OD2i
BESIDE_POST_DRIVER_PMOS_NWi_25V = BESIDE_POST_DRIVER_PMOS_NWi_HV INTERACT OD2i
BESIDE_POST_DRIVER_PMOS_NWi_50V = BESIDE_POST_DRIVER_PMOS_NWi_HV INTERACT OD2i
BESIDE_POST_DRIVER_PMOS_NWi_LV  = BESIDE_POST_DRIVER_PMOS_NWi NOT BESIDE_POST_DRIVER_PMOS_NWi_HV
BESIDE_POST_DRIVER_NMOS_RW = STAMP (BESIDE_POST_DRIVER_NMOS INSIDE DNW) BY DNW
BESIDE_POST_DRIVER_NMOS_PW = BESIDE_POST_DRIVER_NMOS NOT BESIDE_POST_DRIVER_NMOS_RW
BESIDE_POST_DRIVER_NMOS_RW_HV  = BESIDE_POST_DRIVER_NMOS_RW INTERACT HVGT
BESIDE_POST_DRIVER_NMOS_RW_33V = BESIDE_POST_DRIVER_NMOS_RW_HV INTERACT OD2i
BESIDE_POST_DRIVER_NMOS_RW_25V = BESIDE_POST_DRIVER_NMOS_RW_HV INTERACT OD2i
BESIDE_POST_DRIVER_NMOS_RW_50V = BESIDE_POST_DRIVER_NMOS_RW_HV INTERACT OD2i
BESIDE_POST_DRIVER_NMOS_RW_LV  = BESIDE_POST_DRIVER_NMOS_RW NOT BESIDE_POST_DRIVER_NMOS_RW_HV
BESIDE_POST_DRIVER_NMOS_PW_HV  = BESIDE_POST_DRIVER_NMOS_PW INTERACT HVGT
BESIDE_POST_DRIVER_NMOS_PW_33V = BESIDE_POST_DRIVER_NMOS_PW_HV INTERACT OD2i
BESIDE_POST_DRIVER_NMOS_PW_25V = BESIDE_POST_DRIVER_NMOS_PW_HV INTERACT OD2i
BESIDE_POST_DRIVER_NMOS_PW_50V = BESIDE_POST_DRIVER_NMOS_PW_HV INTERACT OD2i
BESIDE_POST_DRIVER_NMOS_PW_LV  = BESIDE_POST_DRIVER_NMOS_PW NOT BESIDE_POST_DRIVER_NMOS_PW_HV
BESIDE_POST_DRIVER_NMOS_RWi = STAMP (BESIDE_POST_DRIVER_NMOS INSIDE DNWc) BY DNWc
BESIDE_POST_DRIVER_NMOS_RWi_HV  = BESIDE_POST_DRIVER_NMOS_RWi INTERACT HVGT
BESIDE_POST_DRIVER_NMOS_RWi_33V = BESIDE_POST_DRIVER_NMOS_RWi_HV INTERACT OD2i
BESIDE_POST_DRIVER_NMOS_RWi_25V = BESIDE_POST_DRIVER_NMOS_RWi_HV INTERACT OD2i
BESIDE_POST_DRIVER_NMOS_RWi_50V = BESIDE_POST_DRIVER_NMOS_RWi_HV INTERACT OD2i
BESIDE_POST_DRIVER_NMOS_RWi_LV  = BESIDE_POST_DRIVER_NMOS_RWi NOT BESIDE_POST_DRIVER_NMOS_RWi_HV

// for LUP.5.4 
BESIDE_POST_DRIVER_PMOS_NW_1 = STAMP BESIDE_POST_DRIVER_PMOS_1 BY NWEL
BESIDE_POST_DRIVER_PMOS_NWi_1 = STAMP BESIDE_POST_DRIVER_PMOS_1 BY NWELi
BESIDE_POST_DRIVER_NMOS_RW_1 = STAMP (BESIDE_POST_DRIVER_NMOS_1 INSIDE DNW) BY DNW
BESIDE_POST_DRIVER_NMOS_PW_1 = BESIDE_POST_DRIVER_NMOS_1 NOT BESIDE_POST_DRIVER_NMOS_RW_1
BESIDE_POST_DRIVER_NMOS_RWi_1 = STAMP (BESIDE_POST_DRIVER_NMOS_1 INSIDE DNWc) BY DNWc



#IFDEF GUIDELINE_LUP
LUP.1g {@ Any N+Active or an N+Active cluster connected to an I/O pad must be surrounded by a P+ guard-ring.
@ Any P+Active or a P+Active cluster connected to an I/O pad must be surrounded by a N+ guard-ring
   POST_DRIVER_NACT NOT INSIDE PTAP_guard_ring_hole  
   POST_DRIVER_PACT NOT INSIDE NTAP_guard_ring_hole 
}

LUP.2g {@ Within ^LUP_2 um space from the MOS connected to an I/O pad, a P+ guard-ring is required to surround an NMOS or an NMOS cluster. And an N+ guard-ring is required to surround a PMOS or a PMOS cluster.
  X = EXT POST_DRIVER_PMOS_NW BESIDE_POST_DRIVER_NMOS_RW < LUP_2_S ABUT < 90 SINGULAR REGION CONNECTED
  Y = EXT POST_DRIVER_PMOS_NWi BESIDE_POST_DRIVER_NMOS_RWi < LUP_2_S ABUT < 90 SINGULAR REGION NOT CONNECTED
  BESIDE_POST_DRIVER_NMOS_waive = (BESIDE_POST_DRIVER_NMOS_RWi NOT INTERACT X) NOT INTERACT Y
  (BESIDE_POST_DRIVER_NMOS NOT BESIDE_POST_DRIVER_NMOS_waive) NOT INSIDE PTAP_guard_ring_hole
  BESIDE_POST_DRIVER_PMOS NOT INSIDE NTAP_guard_ring_hole
}

#IFDEF 1.8V
LUP.3.1g_1.8V {@ For the 1.8V or 1.5V N/PMOS which connects to an I/O pad, space between the NMOS and the PMOS.Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= ^LUP_3_1 um
  EXT POST_DRIVER_NMOS_PW_LV POST_DRIVER_PMOS_NW_LV < LUP_3_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_LV POST_DRIVER_PMOS_NW_LV < LUP_3_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV POST_DRIVER_PMOS_NWi_LV < LUP_3_1 ABUT < 90 SINGULAR REGION NOT CONNECTED  
}
#ENDIF

#IFDEF 1.5V
LUP.3.1g_1.5V {@ For the 1.8V or 1.5V N/PMOS which connects to an I/O pad, space between the NMOS and the PMOS.Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= ^LUP_3_1 um
  EXT POST_DRIVER_NMOS_PW_LV POST_DRIVER_PMOS_NW_LV < LUP_3_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_LV POST_DRIVER_PMOS_NW_LV < LUP_3_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV POST_DRIVER_PMOS_NWi_LV < LUP_3_1 ABUT < 90 SINGULAR REGION NOT CONNECTED  
}
#ENDIF

#IFDEF 2.5V
LUP.3.2g_2.5V {@ For the 2.5V N/PMOS which connects to an I/O pad directly, space between the 2.5V NMOS and the 2.5V/1.5V PMOS, space between the 2.5V PMOS and the 2.5V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.>= ^LUP_3_2 um
  EXT POST_DRIVER_NMOS_PW_25V POST_DRIVER_PMOS_NW_25V < LUP_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_25V POST_DRIVER_PMOS_NW_LV  < LUP_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_25V < LUP_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_25V POST_DRIVER_PMOS_NW_25V < LUP_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_25V POST_DRIVER_PMOS_NW_LV  < LUP_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_25V < LUP_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V POST_DRIVER_PMOS_NWi_25V < LUP_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V POST_DRIVER_PMOS_NWi_LV  < LUP_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_25V < LUP_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
#ENDIF

#IFDEF 3.3V
LUP.3.3g_3.3V {@ For the 3.3V N/PMOS which connects to an I/O pad directly, space between the 3.3V NMOS and the 3.3V/1.8V/1.5V PMOS, space between the 3.3V PMOS and the 3.3V/1.8V/1.5V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= ^LUP_3_3 um
  EXT POST_DRIVER_NMOS_PW_33V POST_DRIVER_PMOS_NW_33V < LUP_3_3 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_33V POST_DRIVER_PMOS_NW_LV  < LUP_3_3 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_33V < LUP_3_3 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_33V POST_DRIVER_PMOS_NW_33V < LUP_3_3 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_33V POST_DRIVER_PMOS_NW_LV  < LUP_3_3 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_33V < LUP_3_3 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_33V POST_DRIVER_PMOS_NWi_33V < LUP_3_3 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_33V POST_DRIVER_PMOS_NWi_LV  < LUP_3_3 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_33V < LUP_3_3 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
#ENDIF

#IFDEF 5V 
LUP.3.4g_5V {@ For the 5V N/PMOS which connects to an I/O pad directly, space between the 1.8V NMOS and the 5V/1.8V PMOS, space between the 1.8V PMOS and the 5V/1.8V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.  >= ^LUP_3_4 um
  EXT POST_DRIVER_NMOS_PW_50V POST_DRIVER_PMOS_NW_50V < LUP_3_4 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_50V POST_DRIVER_PMOS_NW_LV  < LUP_3_4 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_50V < LUP_3_4 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_50V POST_DRIVER_PMOS_NW_50V < LUP_3_4 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_50V POST_DRIVER_PMOS_NW_LV  < LUP_3_4 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_50V < LUP_3_4 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_50V POST_DRIVER_PMOS_NWi_50V < LUP_3_4 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_50V POST_DRIVER_PMOS_NWi_LV  < LUP_3_4 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_50V < LUP_3_4 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
#ENDIF

LUP.4g {@ Width of the N+ guard-ring, P+ guard-ring, N+ STRAP and P+ STRAP for the Active connected to an I/O pad, and also MOS within 20um space from the MOS connected to an I/O pad. >= ^LUP_4 um
  PTAP_guard_ring_holex = PTAP_guard_ring_hole ENCLOSE (POST_DRIVER_NACT OR BESIDE_POST_DRIVER_NMOS)
  NTAP_guard_ring_holex = NTAP_guard_ring_hole ENCLOSE (POST_DRIVER_PACT OR BESIDE_POST_DRIVER_PMOS)
  PTAP_guard_ring_wide = (PTAPi TOUCH PTAP_guard_ring_holex) WITH WIDTH >= LUP_4
  NTAP_guard_ring_wide = (NTAPi TOUCH NTAP_guard_ring_holex) WITH WIDTH >= LUP_4
  PTAP_guard_ring_wide_hole = (HOLES PTAP_guard_ring_wide INNER) INSIDE PWELi
  NTAP_guard_ring_wide_hole = (HOLES NTAP_guard_ring_wide INNER) INSIDE NWELi
  PTAP_guard_ring_hole_check = PTAP_guard_ring_holex NOT INSIDE PTAP_guard_ring_wide_hole
  NTAP_guard_ring_hole_check = NTAP_guard_ring_holex NOT INSIDE NTAP_guard_ring_wide_hole
  PTAP_guard_ring_check = PTAPi COIN OUTSIDE EDGE PTAP_guard_ring_hole_check
  NTAP_guard_ring_check = NTAPi COIN OUTSIDE EDGE NTAP_guard_ring_hole_check
  INT PTAP_guard_ring_check PTAPi < LUP_4 ABUT < 90 REGION
  INT NTAP_guard_ring_check NTAPi < LUP_4 ABUT < 90 REGION
}

#IFDEF 1.8V
LUP.5.1g_1.8V {@ Minimum space >= ^LUP_5_1 um
@ 1. between 1.8V-1.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
@ 2. between 1.8V-1.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
   EXT POST_DRIVER_PMOS_NW_LV BESIDE_POST_DRIVER_NMOS_PW  < LUP_5_1  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_LV BESIDE_POST_DRIVER_NMOS_RW  < LUP_5_1  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_LV BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_1  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_LV BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_1 ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_LV BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_1 ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_LV BESIDE_POST_DRIVER_PMOS_NWi  < LUP_5_1 ABUT <90 SINGULAR REGION NOT CONNECTED
}
#ENDIF

#IFDEF 1.5V
LUP.5.1g_1.5V {@ Minimum space >= ^LUP_5_1 um
@ 1. between 1.8V-1.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
@ 2. between 1.8V-1.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
   EXT POST_DRIVER_PMOS_NW_LV BESIDE_POST_DRIVER_NMOS_PW  < LUP_5_1  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_LV BESIDE_POST_DRIVER_NMOS_RW  < LUP_5_1  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_LV BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_1  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_LV BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_1 ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_LV BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_1 ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_LV BESIDE_POST_DRIVER_PMOS_NWi  < LUP_5_1 ABUT <90 SINGULAR REGION NOT CONNECTED
}
#ENDIF

#IFDEF 2.5V
LUP.5.2g_2.5V {@ Minimum space >= ^LUP_5_2 um
@ 1. between 2.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
@ 2. between 2.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
   EXT POST_DRIVER_PMOS_NW_25V BESIDE_POST_DRIVER_NMOS_PW  < LUP_5_2  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_25V BESIDE_POST_DRIVER_NMOS_RW  < LUP_5_2  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_25V BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_2  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_25V BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_2 ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_25V BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_2 ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_25V BESIDE_POST_DRIVER_PMOS_NWi  < LUP_5_2 ABUT <90 SINGULAR REGION NOT CONNECTED
}
#ENDIF

#IFDEF 3.3V
LUP.5.3g_3.3V {@ Minimum space >= ^LUP_5_3 um
@ 1. between 3.3V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
@ 2. between 3.3V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
   EXT POST_DRIVER_PMOS_NW_33V BESIDE_POST_DRIVER_NMOS_PW  < LUP_5_3  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_33V BESIDE_POST_DRIVER_NMOS_RW  < LUP_5_3  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_33V BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_3  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_33V BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_3 ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_33V BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_3 ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_33V BESIDE_POST_DRIVER_PMOS_NWi  < LUP_5_3 ABUT <90 SINGULAR REGION NOT CONNECTED
}
#ENDIF

#IFDEF 5V
LUP.5.4g_5V {@ Minimum space >= ^LUP_5_4 um
@ 1. between 5V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
@ 2. between 5V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
   EXT POST_DRIVER_PMOS_NW_50V BESIDE_POST_DRIVER_NMOS_PW_1  < LUP_5_4  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_50V BESIDE_POST_DRIVER_NMOS_RW_1  < LUP_5_4  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_50V BESIDE_POST_DRIVER_NMOS_RWi_1 < LUP_5_4  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_50V BESIDE_POST_DRIVER_PMOS_NW_1  < LUP_5_4 ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_50V BESIDE_POST_DRIVER_PMOS_NW_1  < LUP_5_4 ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_50V BESIDE_POST_DRIVER_PMOS_NWi_1  < LUP_5_4 ABUT <90 SINGULAR REGION NOT CONNECTED
}
#ENDIF
#ENDIF

CO_PACT = COi OR (PSDc NOT OUTSIDE COi)
NPUi = NTAPi INTERACT CO_PACT
NPUi_SRAM = NPUi INSIDE SRM
NSTP_OS = SIZE NPUi BY LUP_6 INSIDE OF NWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
NSTP_OS_SRAM = SIZE NPUi_SRAM BY LUP_6_SRAM INSIDE OF NWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
PACT_CHECK = ((PACTi INTERACT COi) INTERACT POLYi) NOT POLYi
PACT_CHECK_NON_SRAM = PACT_CHECK NOT INSIDE SRM 
PACT_CHECK_SRAM =  PACT_CHECK INSIDE SRM

CO_NACT = COi OR (NSDc NOT OUTSIDE COi)
PPUi = PTAPi INTERACT CO_NACT
PPUi_SRAM = PPUi INSIDE SRM
PSTP_OS = SIZE PPUi BY LUP_6 INSIDE OF PWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
PSTP_OS_SRAM = SIZE PPUi_SRAM BY LUP_6_SRAM INSIDE OF PWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
NACT_CHECK = ((NACTi INTERACT COi) INTERACT POLYi) NOT POLYi
NACT_CHECK_NON_SRAM = NACT_CHECK NOT INSIDE SRM 
NACT_CHECK_SRAM =  NACT_CHECK INSIDE SRM

LUP.6 { @ Any point inside NMOS source/drain space to the nearest PW STRAP in the same PW <= ^LUP_6 um
        @ Any point inside PMOS source/drain space to the nearest NW STRAP in the same NW <= ^LUP_6 um
	@ In SRAM bit cell region, the rule is relaxed to ^LUP_6_SRAM um    
  PACT_CHECK_NON_SRAM NOT NSTP_OS
  PACT_CHECK_SRAM NOT (NSTP_OS OR NSTP_OS_SRAM)
  NACT_CHECK_NON_SRAM NOT PSTP_OS
  NACT_CHECK_SRAM NOT (PSTP_OS OR PSTP_OS_SRAM)

}






// LOGO CHECKS
//============

LOGO.S.1 { @ Min. LOGO space to NW, OD, PO, or Metals (non-dummy patterns) >= 3um
  LOGO_EXT = (SIZE LOGO BY 3) NOT LOGO      
  LOGO_EXT AND NWELi
  LOGO_EXT AND ODi
  LOGO_EXT AND POLYi
  LOGO_EXT AND M1i
  LOGO_EXT AND M2i
  LOGO_EXT AND M3i
  LOGO_EXT AND M4i
  LOGO_EXT AND M5i
  LOGO_EXT AND M6i
  LOGO_EXT AND MDi
}




LOGO.O.1 { @ LOGO overlap of CB, CBD, FW, PM, UBM, DOD, DPO, or DMx is not allowed.
  LOGO AND CBi
  LOGO AND CBDi
  LOGO AND PPIi
  LOGO AND FWI
  LOGO AND PLMIDEi
  LOGO AND UBMi
  LOGO AND DOD
  LOGO AND DPO
  LOGO AND M1DMY
  LOGO AND M2DMY
  LOGO AND M3DMY
  LOGO AND M4DMY
  LOGO AND M5DMY
  LOGO AND M6DMY
  LOGO AND MDDMY
}

LOGO.R.1 { @ A circuit in LOGO is not allowed.
  LOGO AND ALL_GATE
  LOGO AND PORES
  LOGO AND ODRES
  LOGO AND RNWEL
  LOGO AND BJTDUMMY
  LOGO AND DIODUMMY
  LOGO AND VARDMY
  LOGO AND CTM5i
}

//LOGO.R.2 has been check by other DRC rules



#IFDEF MIX_MODE

//===============================================================================
// Mixed-Singal/RF part
//===============================================================================


// POLY CHECKS
//==============

PO.W.1_HRI { @ Min. width of PO region for HRI poly resistor >= 1.0um
  HREPC = HREP INTERACT RLPPDMY
  INT HREPC < 1.0 ABUT < 90 SINGULAR REGION    
}
_PO.R.1A.MM { @ 90 degree L shape and U shape bent gates are not allowed
  NORM_GATE_W = GATE_W OUTSIDE EDGE VARDMY
  EXT NORM_GATE_W < 0.18 ABUT == 90 INTERSECTING ONLY
  INT NORM_GATE_W < 0.18 ABUT == 90 INTERSECTING ONLY
}

// PP CHECKS
//============

_PP.E.6.MM { @ Min. extension of a PP region beyond a PO as resistor >= 0.18um
  ENC PORES PP < 0.18 ABUT < 90 SINGULAR REGION
  ((RPO AND POLY) NOT IMP) NOT HRI
}

// RPO CHECKS
//=============

RPO.O.1_HRI { @ Min. and Max. overlap of a PP region to RPO region for HRI == 0.3um
  X = POLY_ISO INTERACT HRI
  Y = RPO INSIDE EDGE X
  INT PP Y < 0.3 ABUT < 90
  Y OUTSIDE EDGE PP	// not overlap by P+ not allowed.
  Z = EXPAND EDGE Y INSIDE BY 0.30
  PPPO = PP AND POLY
  A = PPPO AND PORES
  B = A INTERACT HRI
  B NOT Z
}

#IFNDEF C016

CONNECT	NTAPi NWELi
CONNECT	NTAPi PSDi
CONNECT	PTAPi NSDi
CONNECT	M1xd ILP1i NTAPi PTAPi PSDi NSDi BY COi
CONNECT	M1xd M2xd BY VIA1i
CONNECT	M2xd M3xd BY VIA2i
CONNECT	M3xd M4xd BY VIA3i
CONNECT	M4xd M5xd BY VIA4i
CONNECT	M5xd  M6xd BY VIAt 
CONNECT	CTM5i M6xd BY VIAc
CONNECT	M6xd  MDxd BY VIADi

// M6 checks
//=============


M6T_NIND = M6xd NOT INDDMY

INDDMYI = SIZE INDDMY BY -7 //exclude M1 substrate pick up node
INDM = INDDMY AND M4
INDME = INDM COINCIDENT INSIDE EDGE INDDMY
INDDMYA = INDDMY WITH EDGE INDME <2
INDDMY3 = INDDMYA ENCLOSE M5 //for 3 terminals inductor(central tap)
INDDMY2 = INDDMY NOT INDDMY3 //for 2 terminals inductor

#IFDEF THICK_20K

UTM20K.W.1 { @ Min. M6 width >= 1.50 um
  INT M6 < 1.50 ABUT < 90 SINGULAR REGION
}
UTM20K.S.1 { @ Min. M6 spacing >= 1.50 um
  EXT M6 < 1.50 ABUT < 90 SINGULAR REGION
}
UTM20K.E.1 { @ Min. extension of a M6 region beyond a VIA5 region >= 0.3 um
  ENC VIA5 M6 < 0.3 ABUT < 90 SINGULAR REGION
  VIA5 NOT M6    
}
UTM20K.E.2 { @ Min. extension of M6 end-of-line region beyond VIA5 region >= 0.45 um
  X = ENC [VIA5] M6 < 0.45 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.36 ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}
UTM20K.S.2 { @ Min. space of Wide M6 (>16um) and M6 >= 3.0 um (exclude application for inductor)
  M6T_NIND_S8 = SHRINK (SHRINK (SHRINK (SHRINK M6T_NIND RIGHT BY 8) LEFT BY 8) TOP BY 8) BOTTOM BY 8
  M6T_NIND_G8 = GROW (GROW (GROW (GROW M6T_NIND_S8 RIGHT BY 8) LEFT BY 8) TOP BY 8) BOTTOM BY 8
  M6T_NIND_Wide = M6T_NIND_G8 AND M6T_NIND
  M6T_NIND_Exp = SIZE M6T_NIND_Wide BY 1 INSIDE OF M6T_NIND STEP 1.05
  M6T_NIND_Branch = M6T_NIND_Exp NOT M6T_NIND_Wide
  M6T_NIND_Branch_edge = M6T_NIND_Branch COIN INSIDE EDGE M6T_NIND
  M6T_NIND_Check = M6T_NIND AND (SIZE M6T_NIND_Exp BY 3.0)
  M6T_NIND_Branch_Check = M6T_NIND AND (EXPAND EDGE M6T_NIND_Branch_edge OUTSIDE BY 3.0 CORNER FILL)
  M6T_NIND_WideC = STAMP M6T_NIND_Wide BY M6xd
  M6T_NIND_CheckC = STAMP M6T_NIND_Check BY M6xd
  M6T_NIND_BranchC = STAMP M6T_NIND_Branch BY M6xd
  M6T_NIND_Branch_CheckC = STAMP M6T_NIND_Branch_Check BY M6xd
  EXT M6T_NIND_WideC M6T_NIND_CheckC < 3.0 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M6T_NIND_BranchC M6T_NIND_Branch_CheckC < 3.0 ABUT >0 <89.5 NOT CONNECTED REGION
}
UTM20K.A.1 { @ Min. area of M6 region >= 2.25 um2
  AREA M6 < 2.25
}
UTM20K.R.1 { @ Min. density of M6 area >= 30% (exclude application for inductor)
  CHIP_NIND = CHIP NOT INDDMY
  DENSITY M6T_NIND CHIP_NIND < 0.3 PRINT M6T_DENSITY.log
  [ AREA(M6T_NIND)/AREA(CHIP_NIND) ]
}
#IFDEF Recommend
UTM20K.C.1 { @ Min. clearance from M6 as inductor to M6 >= 50 um
  IND_M6 =  M6 INTERACT ( SIZE INDDMY BY -50.5 ) 
  IND_M6V5 = VIA5 INTERACT IND_M6
  IND_M5 = M5 INTERACT IND_M6V5
  IND_M5V5 = VIA5 INTERACT IND_M5
  IND_M6_CONN = M6 INTERACT IND_M5V5
  IND_M6_ALL = IND_M6 OR IND_M6_CONN
  IM6 = IND_M6_ALL AND INDDMY
  RM6 = M6 NOT IND_M6_ALL
  OM6 = IND_M6_ALL NOT IM6
  EXT RM6 IM6 < 50 ABUT < 90 SINGULAR REGION 
  EXT IM6 OM6 < 50 ABUT > 0 < 90 PROJ > 0 REGION 
}
#ENDIF
UTM20K.E.3 { @ Min. extension of INDDMY beyond M6 >= 50 um
  ENC M6 INDDMY < 50 ABUT > 0 < 90 SINGULAR REGION
}
UTM20K.I.1 { @ No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect,
           @ and the M1 substrate pick up node of inductor
  AND INDDMYI M1
  AND INDDMY VIA1	
  AND INDDMY M2
  AND INDDMY VIA2
  AND INDDMY M3
  AND INDDMY VIA3
  AND INDDMY2 M4
  AND INDDMY2 VIA4	    
}
UTM20K.I.2 { @ Both active and passive devices not allow inside INDDMY besides guard ring
  AND INDDMY NWEL
  AND INDDMY POLY
  AND INDDMYI OD //exclude M1 substrate pick up node of inductor
}
#ENDIF
#IFDEF THICK_40K
UTM40K.W.1 { @ Min. M6 width >= 2.60 um
  INT M6 < 2.60 ABUT < 90 SINGULAR REGION
}
UTM40K.S.1 { @ Min. M6 space >= 2.50 um
  EXT M6 < 2.50 ABUT < 90 SINGULAR REGION
}
UTM40K.E.1 { @ Min. extension of a M6 region beyond a VIA5 region >= 0.4 um
  ENC VIA5 M6 < 0.4 ABUT < 90 SINGULAR REGION
  VIA5 NOT M6  
}
UTM40K.E.2 { @ Min. extension of M6 end-of-line region beyond VIA5 region >= 0.45 um
  X = ENC [VIA5] M6 < 0.45 ABUT < 90 OPPOSITE	// a narrow side
  INT X < 0.36 ABUT == 90 INTERSECTING ONLY	// adjacent narrow sides
}
UTM40K.S.2 { @ Min. space of Wide M6 (>16um) and M6 >= 4.0 um (exclude application for inductor)
  M6T_NIND_S8 = SHRINK (SHRINK (SHRINK (SHRINK M6T_NIND RIGHT BY 8) LEFT BY 8) TOP BY 8) BOTTOM BY 8
  M6T_NIND_G8 = GROW (GROW (GROW (GROW M6T_NIND_S8 RIGHT BY 8) LEFT BY 8) TOP BY 8) BOTTOM BY 8
  M6T_NIND_Wide = M6T_NIND_G8 AND M6T_NIND
  M6T_NIND_Exp = SIZE M6T_NIND_Wide BY 1 INSIDE OF M6T_NIND STEP 1.75
  M6T_NIND_Branch = M6T_NIND_Exp NOT M6T_NIND_Wide
  M6T_NIND_Branch_edge = M6T_NIND_Branch COIN INSIDE EDGE M6T_NIND
  M6T_NIND_Check = M6T_NIND AND (SIZE M6T_NIND_Exp BY 4.0)
  M6T_NIND_Branch_Check = M6T_NIND AND (EXPAND EDGE M6T_NIND_Branch_edge OUTSIDE BY 4.0 CORNER FILL)
  M6T_NIND_WideC = STAMP M6T_NIND_Wide BY M6xd
  M6T_NIND_CheckC = STAMP M6T_NIND_Check BY M6xd
  M6T_NIND_BranchC = STAMP M6T_NIND_Branch BY M6xd
  M6T_NIND_Branch_CheckC = STAMP M6T_NIND_Branch_Check BY M6xd
  EXT M6T_NIND_WideC M6T_NIND_CheckC < 4.0 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT M6T_NIND_BranchC M6T_NIND_Branch_CheckC < 4.0 ABUT >0 <89.5 NOT CONNECTED REGION
}
UTM40K.A.1 { @ Min. area of M6 region >= 6.76 um2
  AREA M6 < 6.76
}
UTM40K.R.1 { @ Min. density of M6 area >= 30% (exclude application for inductor)
  CHIP_NIND = CHIP NOT INDDMY
  DENSITY M6T_NIND CHIP_NIND < 0.3 PRINT M6T_DENSITY.log
  [ AREA(M6T_NIND)/AREA(CHIP_NIND) ]
}
#IFDEF Recommend
UTM40K.C.1 { @ Min. clearance from M6 as inductor to M6 >= 50 um
  IND_M6 =  M6 INTERACT ( SIZE INDDMY BY -50.5 ) 
  IND_M6V5 = VIA5 INTERACT IND_M6
  IND_M5 = M5 INTERACT IND_M6V5
  IND_M5V5 = VIA5 INTERACT IND_M5
  IND_M6_CONN = M6 INTERACT IND_M5V5
  IND_M6_ALL = IND_M6 OR IND_M6_CONN
  IM6 = IND_M6_ALL AND INDDMY
  RM6 = M6 NOT IND_M6_ALL
  OM6 = IND_M6_ALL NOT IM6
  EXT RM6 IM6 < 50 ABUT < 90 SINGULAR REGION 
  EXT IM6 OM6 < 50 ABUT > 0 < 90 PROJ > 0 REGION 
}
#ENDIF
UTM40K.E.3 { @ Min. extension of INDDMY beyond M6 >= 50 um
  ENC M6 INDDMY < 50 ABUT > 0 < 90 SINGULAR REGION
}
UTM40K.I.1 { @ No via and metal inside INDDMY are allowed, except underpass vias and metal interconnect,
           @ and the M1 substrate pick up node of inductor
  AND INDDMYI M1
  AND INDDMY VIA1	
  AND INDDMY M2
  AND INDDMY VIA2
  AND INDDMY M3
  AND INDDMY VIA3
  AND INDDMY2 M4
  AND INDDMY2 VIA4	    
}
UTM40K.I.2 { @ Both active and passive devices not allow inside INDDMY besides guard ring
  AND INDDMY NWEL
  AND INDDMY POLY
  AND INDDMYI OD //exclude M1 substrate pick up node of inductor
}
#ENDIF
#ENDIF

// DNW CHECKS
//==============

RW  = DNW NOT NWEL // RW is PW in DNW

#IFNDEF C016
DNW.W.1 { @ Min. width of a DNW region >= 3um
  INT DNW < 3 ABUT < 90 SINGULAR REGION
}
DNW.S.1 { @ Min. space between two DNW regions >= 5um
  EXT DNW < 5 ABUT < 90 SINGULAR REGION
}
#ENDIF
#IFDEF Recommend
CONNECT	PTAPi PWELi
DNW.S.2 { @ Min. space between RW and {RW OR PW} with different potential >= 1.4um
  RW_NODAL = STAMP RW BY PWELi
  PWEL_NODAL = STAMP PWEL BY PWELi
  EXT RW_NODAL PWEL_NODAL < 1.4 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
#ENDIF
DNW.O.1 { @ Min. overlap from a NW edge to a DNW region >= 2.0um
  INT DNW NWEL < 2.0 ABUT < 90 SINGULAR REGION
}
CONNECT NWEL DNW
DNW.C.1 { @ Min. clearance from DNW to NW >= 3.5um
  EXT NWEL DNW < 3.5 ABUT < 90 SINGULAR REGION NOT CONNECTED MEASURE ALL
}
DNW.C.4 { @ Min. clearance from DNW to N+OD outside NW >= 3.0um
  A = PWEL NOT DNW
  B = NPOD INTERACT A
  EXT B DNW < 3.0 ABUT < 90 SINGULAR REGION
  CUT B DNW
}
#IFDEF Recommend
// DNW.R.3 is a recommended rule and un-checkable.
DNW.E.1 { @ Min. extension of NW beyond DNW for a better noise isolation >= 1.5um
  ENC DNW NWEL < 1.5 ABUT < 90 SINGULAR REGION
  ( DNW NOT INTERACT SBDDMY ) OUTSIDE EDGE NWEL
}
#ENDIF
DNW.E.2 { @ Min. extension of DNW beyond N+OD outside NW >= 1.5um
  A = PWEL AND DNW
  B = NPOD INTERACT A
  ENC B DNW < 1.5 ABUT < 90 SINGULAR REGION
  CUT B DNW
}
DNW.R.4 { @ It is not allowed to use DNW as a resistor
  AND DNW RWDMY
}
DNW.R.5 { @ It is not allowed to use {NW interact DNW} as a resistor
  INTERACT RNWEL DNW
  INTERACT NWRES DNW
}

#IFDEF C016
DNW.W.1 { @ Min. DNW width < 3.3
  INT DNW < 3.3 ABUT<90 SINGULAR REGION
}
DNW.S.1 { @ Min. DNW space < 5.5
  EXT DNW < 5.5 ABUT<90 SINGULAR REGION
}
#ENDIF



//VTM_N
//=====
 
VTM_N.W.1 { @ Min. dimension of a VTM_N region >= 0.74um
  INT VTMN < 0.74 ABUT < 90 SINGULAR REGION
}
VTM_N.W.2 { @ Min. PO gate dimension of a 1.8V medium Vt NMOS >= 0.3um
  Z = GATE_W INSIDE EDGE VTMN
  INT Z < 0.3 ABUT < 90 REGION
}
VTM_N.W.3 { @ Min. PO gate dimension of a 3.3V medium Vt NMOS >= 0.6um
  Z = HV_NGATE_W INSIDE EDGE VTMN
  INT Z < 0.6 ABUT < 90 REGION
}
VTM_N.S.1 { @ Min. space between two VTM_N regions >= 0.44um
  EXT VTMN < 0.44 ABUT < 90 SINGULAR REGION
}
VTM_N.E.1 { @ Min. extension from a VTM_N region beyond an N+OD region >= 0.26um
  ENC NACT VTMN < 0.26 ABUT < 90 SINGULAR REGION
  NACT CUT VTMN    
}
VTM_N.C.1 { @ Min. clearance from a VTM_N region to an N+OD region >= 0.7um
  EXT NACT VTMN < 0.7 ABUT < 90 SINGULAR REGION
}
VTM_N.C.2 { @ Min. clearance from a VTM_N region to an NW edge >= 0.43um
  EXT VTMN NWEL < 0.43 ABUT < 90 SINGULAR REGION
  VTMN AND NWEL    
}
VTM_N.R.2 {@ VTM_N interact NT_N is not allowed
  VTMN AND NTN
}

VTM_N.R.3 {@ A P+ Gate is not allowed in VTM_N region
  VTMN AND GATE_PP
}
VTM_N.R.4 {@ A bent PO region is not allowed in VTM_N region
  VTMN_PO = POLY AND VTMN
  VERTEX VTMN_PO != 4
}
VTM_N.R.5 { @ Min. clearance from an OD region in VTM_N region to a PO on field oxide >= 0.26um
  VTMN_OD = VTMN AND OD
  EXT VTMN_OD POLY_ISO < 0.26 ABUT > 0 < 90 SINGULAR REGION
}   
  


// VTM_P
//======
 
VTM_P.W.1 { @ Min. dimension of a VTM_P region >= 0.74um
  INT VTMP < 0.74 ABUT < 90 SINGULAR REGION
}
VTM_P.W.2 { @ Min. PO gate dimension of a 1.8V medium Vt PMOS >= 0.25um
  Z = GATE_W INSIDE EDGE VTMP
  INT Z < 0.25 ABUT < 90 REGION
}
VTM_P.S.1 { @ Min. space between two VTM_P regions >= 0.44um
  EXT VTMP < 0.44 ABUT < 90 SINGULAR REGION
}
VTM_P.E.1 { @ Min. extension from a VTM_P region beyond a P+OD region >= 0.26um
  ENC PACT VTMP < 0.26 ABUT < 90 SINGULAR REGION
  PACT CUT VTMP    
}
VTM_P.C.1 { @ Min. clearance from a VTM_P region to a P+OD region >= 0.7um
  EXT PACT VTMP < 0.7 ABUT < 90 SINGULAR REGION
}
VTM_P.C.2 { @ Min. clearance from a VTM_P region to a PW edge >= 0.43um
  ENC VTMP NWEL < 0.43 ABUT < 90 SINGULAR REGION
  VTMP NOT NWEL    
}
VTM_P.R.2 {@ VTM_P interact NT_N is not allowed
  VTMP AND NTN
}
VTM_P.R.3 { @ VTM_P interact OD2 is not allowed.
  VTMP AND OD2 
}
VTM_P.R.4 {@ A N+ Gate is not allowed in VTM_P region
  VTMP AND GATE_NP
}
VTM_P.R.5 {@ A bent PO region is not allowed in VTM_P region
  VTMP_PO = POLY AND VTMP
  VERTEX VTMP_PO != 4
}
VTM_P.R.6 { @ Min. clearance from an OD region in VTM_P region to a PO on field oxide >= 0.26um
  VTMP_OD = VTMP AND OD
  EXT VTMP_OD POLY_ISO < 0.26 ABUT > 0 < 90 SINGULAR REGION
}   




//HRI  
//===  
 
HRI.W.1 { @ Min. width of a HRI region >= 0.44um
  INT HRI < 0.44 ABUT < 90 SINGULAR REGION
}
HRI.S.1 { @ Min. space between two HRI regions >= 0.44um
  EXT HRI < 0.44 ABUT < 90 SINGULAR REGION
}
HRI.C.1 { @ Min. clearance from an HRI region to an NP region >= 0.26um
  X = EXT HRI NP < 0.26 ABUT < 90 SINGULAR REGION
  X NOT INTERACT BUTT_PTAP
}
HRI.C.2 { @ Min. clearance from an HRI region to a PP region >= 0.26um
  EXT HRI PP < 0.26 ABUT < 90 SINGULAR REGION
}
HRI.C.3_C.4 { @ Min. clearance from an HRI edge to Poly gate >= 0.32um
  EXT HRI ALL_GATE < 0.32 ABUT < 90 SINGULAR REGION
}
HRI.E.1 { @ Min. enclosure from an HRI region beyond a PO resistor region >= 0.26um
  ENC PORES HRI < 0.26 ABUT < 90 SINGULAR REGION
  ( PORES NOT OUTSIDE HRI ) NOT HRI    
}
HRI.R.1 { @ Overlap of NP and HRI is not allowed
  HRI AND NP
}
HRI.R.2 { @ Overlap of OD and HRI is not allowed
  HRI AND OD
}  
HRI.A.1 { @ Min. area of a HRI region >= 0.3844um2
  HRI AREA < 0.3844
}



// CTM CHECK
//============
TCTM  = CTM5 INTERACT VIA5	// True CTM
DCTM  = CTM5 NOT INTERACT VIA5	// Dummy CTM
BPM5  = SIZE TCTM BY 2 INSIDE OF M5 STEP 0.28*0.7 TRUNCATE 0.28*0.7	// CBM = TCTM SIZE 2
DPM5  = M5 INTERACT DCTM	// M5 as a dummy CBM
BPM5C = BPM5 COIN EDGE M5

CTM.W.1 { @ Min. width of a CTM region >= 4.0um
  INT TCTM < 4.0 ABUT < 90 SINGULAR REGION
}
CTM.W.2 { @ Min. width of a dummy CTM region >= 0.4um
  INT DCTM < 0.4 ABUT < 90 SINGULAR REGION
}
CTM.S.1 { @ Min. space between two CTM regions >= 1.2um
  EXT TCTM < 1.2 ABUT < 90 SINGULAR REGION
}
CTM.S.2 { @ Min. space between a dummy CTM and a CTM region or two dummy CTM regions >= 0.8um
  EXT DCTM TCTM < 0.8 ABUT < 90 SINGULAR REGION
  EXT DCTM < 0.8 ABUT < 90 SINGULAR REGION
}
CTM.R.2 { @ Min. density of all CTM area >= 3%
  DENSITY CTM5i > 0 < 0.03 PRINT CTM5i.density
}
//CTM.R.3 is not necessary to check
CTM.W.4 { @ Max. dimension (one side) of a CTM region <= 30um
  ENCLOSE RECTANGLE TCTM 4 30.005 ORTHOGONAL ONLY // 4um is min TCTM width
  ENCLOSE RECTANGLE DCTM 0.4 30.005 ORTHOGONAL ONLY // 0.4um is min DCTM width
}
CTM.A.1 { @ Min. area of CTM region >= 0.202um2
  AREA CTM5 < 0.202
}
//CTM.R.1 is checked by MIM_M5.E.3
CTM.R.5 { @ The MIM capacitor must be placed between M6 amd M5
  COPY CTM2
  COPY CTM3
  COPY CTM4

} 

// MIM_M5 CHECK
//==============

MIM_M5.W.1 { @ Max. dimension (both width and length) of M5 as MIM capacitor bottom metal <= 35um
  SIZE BPM5 BY 17.5 UNDEROVER
}
MIM_M5.S.1 { @ Min. space between two M5 regions as MIM capacitor bottom metal >= 0.8um
  EXT BPM5C < 0.8 ABUT < 90 REGION
}
MIM_M5.S.2 { @ Min. space between one M5 region as a dummy MIM capacitor bottom metal and 
              @ the other M5 region as MIM capacitor bottom metal >= 0.8um
  EXT BPM5C DPM5 < 0.8 ABUT < 90 REGION
}
MIM_M5.E.3  { @ Minimum extension of an M5 resgion as MIM capacitor bottom metal beyound 
              @ a CTM resgion and dummy CTM region >=0.40um 
  ENC CTM5 M5 < 0.4 ABUT < 90 SINGULAR REGION
  CTM5 NOT M5  
}
// MIMVIA CHECK
//===============

CTMV5 = VIA5 AND CTM5		// VIA5 locate on CTM
CBMV5 = (VIA5 AND BPM5) NOT CTM5	// VIA5 locate on CBM

CONNECT CTMV5 TCTM
CONNECT CBMV5 BPM5

MIMVIA.S.1 { @ Min. space between two VIA5 on the same CTM >= 2.0um
  EXT CTMV5 < 2.0 ABUT < 90 SINGULAR REGION CONNECTED   
}
MIMVIA.S.2 { @ Min. space between two VIA5 on the same M5 as MIM capacitor bottom metal >= 4.0um
  EXT CBMV5 < 4.0 ABUT < 90 SINGULAR REGION CONNECTED     
}
MIMVIA.E.1 { @ Min. extension of a CTM region beyond a VIA5 region >= 0.24um
  ENC VIA5 CTM5 < 0.24 ABUT < 90 SINGULAR REGION
  VIA5 CUT CTM5    
}
MIMVIA.E.2 { @ Min. extension of an M5 region as MIM capacitor bottom metal beyond a VIA4 or a VIA5 region >= 0.12um
  ENC VIA4 BPM5C < 0.12 ABUT < 90 REGION
  ENC VIA5 BPM5C < 0.12 ABUT < 90 REGION
}
MIMVIA.C.1 { @ Min. clearance of a VIA4 or a VIA5 to a CTM region >= 0.4um
  EXT VIA4 CTM5 < 0.4 ABUT < 90 SINGULAR REGION
  EXT VIA5 CTM5 < 0.4 ABUT < 90 SINGULAR REGION
}
MIMVIA.R.1 { @ Min. density of VIA5 on CTM >= 1%
  NET AREA RATIO CTMV5 TCTM < 0.01 RDB VIA5_DENSITY.log CTMV5 TCTM
}
MIMVIA.R.3 { @ VIA4 under CTM region is not allowed
  VIA4 AND CTM5
}


//================SBD rules Check================================



PPOD_SBD_H = (HOLES (((PPOD AND PWEL) AND RFDUMMY) NOT DNW) INNER) ENCLOSE SBDOD

SBD.W.1_SBD.W.1.1 { @ Minimum width of an OD region to define the width of the
          @ P+ active OD region of the SBD. >=1.0um <= 16.0um
    LENGTH PPOD_SBD_W > 0 < 1
    PATH LENGTH PPOD_SBD_W > 16 < 999
}
SBD.W.2_SBD.W.2.1 { @ Minimum length of an OD region to define the length of the
          @ P+ active OD region of the SBD. >=1.0um <=4.0um
    LENGTH PPOD_SBD_L > 0 < 1
    PATH LENGTH PPOD_SBD_L > 4 < 999 
}
SBD.W.3 { @ Minimum and Maximum length of an OD region to define
          @ the length of the NP OD region of the SBD.==0.42um
    NOT RECTANGLE NPOD_SBD	      
    INT NPOD_SBD < 0.42 ABUT <90 SINGULAR REGION
    SIZE NPOD_SBD BY 0.42/2 UNDEROVER
}
SBD.W.4 { @ The width of NP OD region of the SBD must be equal to P+
          @ active OD region of the SBD.
    NPOD_SBD_W NOT COIN OUTSIDE EDGE PPOD_SBD_G	      
    PPOD_SBD_W NOT COIN OUTSIDE EDGE NPOD_SBD_G        
}
SBD.S.1 { @ Space between P+ active OD region and NP OD region of the SBD ==0.48um
    EXT PPOD_SBD NPOD_SBD < 0.48 ABUT < 90 SINGULAR REGION
    PPOD_SBD INTERACT NPOD
   
    PPOD_SBD NOT TOUCH PPOD_SBD_G == 2
    
    A = PPOD_SBD TOUCH PPOD_SBD_G == 2
    B = A TOUCH OUTSIDE EDGE PPOD_SBD_G 
    C = INT B < 0.48 ABUT == 90 INTERSECTING ONLY REGION 
    PPOD_SBD INTERACT C 
}
SBD.E.1 { @ Minimum and maximum extension from NW edge to an OD
          @ region used for the SBD. ==0.80um
    X = PPOD_SBD OR NPOD_SBD
    Y = SIZE X BY 0.8
    Y XOR NW_SBD
}
SBD.E.2 { @ Minimum and maximum extension of a PP region beyond
          @ an enclosed P+ active OD region of the SBD.==0.22um
    X = SIZE PPOD_SBD BY 0.22
    X XOR PP_SBD_ALL
}
SBD.O.1 { @ Minimum and maximum overlap from a PP edge to a P+
          @ active OD region of the SBD.==0.22um
    X = SIZE PPOD_SBD BY -0.22
    X XOR PP_SBD_HOLE
}
SBD.E.1.1 { @ Minimum extension of DNW beyond NW for a better noise isolation.>=0.60um
    ENC NW_SBD DNW_SBD < 0.6 ABUT <90 SINGULAR REGION
    NW_SBD CUT DNW_SBD
}

SBD.E.3 { @ Maximum and Minimum extension of SBDDMY beyond NW==0.00um
    SBDDMY XOR NW_SBD
}
//SBD.R.1 is checked by SBD.S.1 { @ The P+ active OD region of the SBD must be located between the NP OD regions.
//          The NP OD region must be located parallel with the width of the P+ active OD region at left and right sides.

SBD.R.2 { @ Maximum Finger Number of the P+ active OD region of the SBD should be <=16um
    X = SBDDMY INTERACT PPOD_SBD < 17
    Y = SBDDMY NOT X 
    PPOD_SBD INTERACT Y
}
SBD.R.3 { @ The each NW of SBD should be surrounded by the P+ Guard Ring (P+ pickup ring).
    NW_SBD NOT PPOD_SBD_H 
    PPOD_SBD_H INTERACT SBDOD_ALL >1

    PPOD_SBD_H INTERACT NW_SBD > 1
}

SBD.R.4 { @ Use RFDUMMY to fully cover SBD and P+ Guard Ring for LVS to recognize RF Device.
          @// for P+ guard Ring part is checked by SBD.R.3
    SBDDMY NOT RFDUMMY
    NW_SBD NOT RFDUMMY
}
SBD.R.5 { @ PP for SBD must be a rectangle ring. PP rectangle ring must surround OD. Other shape is not allowed.
    NOT RECTANGLE PP_SBD_HOLE	
    NOT RECTANGLE PP_SBD_ALL
}
//SBD.R.7R don't need check. 

#ENDIF

